<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cocos2d-x | 喜气羊羊]]></title>
  <link href="http://young40.github.io/blog/categories/cocos2d-x/atom.xml" rel="self"/>
  <link href="http://young40.github.io/"/>
  <updated>2013-08-02T09:09:48+08:00</updated>
  <id>http://young40.github.io/</id>
  <author>
    <name><![CDATA[Young40]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CocosBuilder 多分辨率]]></title>
    <link href="http://young40.github.io/blog/2013/08/01/cocosbuilder-multi-resolution/"/>
    <updated>2013-08-01T22:10:00+08:00</updated>
    <id>http://young40.github.io/blog/2013/08/01/cocosbuilder-multi-resolution</id>
    <content type="html"><![CDATA[<p>最近两个项目大量使用了CocosBuilder, 对于开发效率提高是巨大的. 一直计划写一篇博客谈谈CocosBuilder的多分辨率问题, 懒病加上一些疙疙瘩瘩的小事情, 拖延了一个多月, 才终于下定决定要尽快完成这篇博客.</p>

<p>在这篇文章中, 假定你比较熟悉CocosBuilder, 如果您还不是很熟悉CocosBuilder, 推荐您看下我的另外一篇文章. <a href="http://www.ityran.com/archives/2614">从零开始学习CocosBuilder</a> 我还是小菜鸟一个, 难免会有很多错误, 还望各位看客不吝赐教.</p>

<p>版本:</p>

<ul>
<li>Cocos2d-x 2.1.4 <a href="http://cocos2d-x.googlecode.com/files/cocos2d-x-2.1.4.zip">http://cocos2d-x.googlecode.com/files/cocos2d-x-2.1.4.zip</a></li>
<li>CocosBuilder 3.0alpha5 <a href="http://cocosbuilder.googlecode.com/files/CocosBuilder-3.0-alpha5.zip">http://cocosbuilder.googlecode.com/files/CocosBuilder-3.0-alpha5.zip</a></li>
</ul>


<p>最近几次Cocos2d-x和CocosBuilder(以下简写为2dx和ccb)都是联合发布的, 使用联合发布的版本会减少不兼容的可能.</p>

<!--more-->


<h2>基本概念</h2>

<p>我觉得在分辨率中重要的概念就是<code>位置</code>, <code>大小</code>, <code>节点关系</code>, 可以通过位置, 大小, 节点关系的合理组合, 最终达到理想的界面. 当然, 换而言之, 这需要ccb的使用者更多的思考.</p>

<h3>位置</h3>

<p>{% img /upload/2013-08/ccb-multi-r-01.png %}
我们可以看到ccb中位置共有6种设置. 其中前四种设置方式代表了当前节点相对于其父节点的一个顶点的绝对位置.</p>

<p>{% img /upload/2013-08/ccb-multi-r-02.png %}
如上图所示, 我们把<code>Click me</code> 按钮, 放在了距离其父节点右上角各50px.
这种位置的设置方式, 一般在节点需要放在父节点一个角上时很有用.</p>

<p>{% img /upload/2013-08/ccb-multi-r-03.png %}
第5种设置方式表示当前节点的坐标由其父节点大小(宽width, 高height)的百分比组成, 其中父节点的左下角为原点.
如上图所示一个节点的父节点大小为200px*100px, 当前节点设置为(70%, 50%),那么当前节点距离其父节点左下角就应该是(140, 50).
百分比设置是位置设置中最常用的方式, 只有当百分比设置不适合时才去考虑其他设置方式.</p>

<p>{% img /upload/2013-08/ccb-multi-r-04.png %}
第6种设置方式其实就是第1种设置方式的x,y值分别乘以一个全局缩放系数. 我们接下来就讲这个全局缩放系数, 这里先假设iphone下为1, iphone retina下为2.
如上图所示, 当前节点在iphone下距离其父节点左下角(50*1, 50*1), 在iphone retina下则就是(50*2, 50*2).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于Pomelo和Cocos2d-x的聊天室]]></title>
    <link href="http://young40.github.io/blog/2013/01/08/chat-of-pomelo-for-cocos2d-x/"/>
    <updated>2013-01-08T00:39:00+08:00</updated>
    <id>http://young40.github.io/blog/2013/01/08/chat-of-pomelo-for-cocos2d-x</id>
    <content type="html"><![CDATA[<p>据说聊天室和游戏系统有很多相似之处, 并且很多游戏本身就带着多人聊天系统. 所以Pomelo将聊天室作为了一个例子.</p>

<p>开源是非常棒的思想和运动, 我简单提两点体会,
1.发现了问题可以不用等官方响应,自己有能力就可以马上修复. 2.你可以贡献自己的代码,很多人都可以贡献代码,可以让项目快速发展.
当然一旦你的代码被接受并被很多人使用, 心中的成就感是不言而喻的.</p>

<p>之所以要提到开源, 是因为今天我们要用到的东西基本上全部是开源的, 并且我们还要对其中的代码做一些修改才能正常工作. 再一次为开源鼓掌!</p>

<p>这并不是一篇Pomelo,或者Cocos2d-x的入门说明, 需要你对这两者都有一定的了解.
同时, 无论是Pomelo还是Cocos2d-x, 我都是新手, 如果文章中有错误的地方, 希望您能不吝指出.
您可以在文章下面留言, 或者在新浪微博上发微薄 @杨世玲
(需要说明的一点是, 请勿私信提问非隐私性技术问题, 我是希望您的问题, 我的或者其他朋友的回复,能被更多朋友搜索到,
我希望我们的交流, 能让更多朋友受到启发, 受益. 这也是对社区和世界和平的一点贡献吧.)</p>

<!--more-->


<p>下面是我们需要使用到的工具及其版本:</p>

<ul>
<li>平台:OS X(10.8.2) Xcode(4.5.2)</li>
<li>Cocos2d-2.1beta3-x-2.1.0</li>
<li>Pomelo <a href="https://github.com/NetEase/pomelo">https://github.com/NetEase/pomelo</a></li>
<li>socket.io-clientpp <a href="https://github.com/ebshimizu/socket.io-clientpp">https://github.com/ebshimizu/socket.io-clientpp</a></li>
<li>websocketpp <a href="https://github.com/zaphoyd/websocketpp">https://github.com/zaphoyd/websocketpp</a></li>
<li>Rapidjson <a href="https://code.google.com/p/rapidjson/">https://code.google.com/p/rapidjson/</a></li>
<li>chatofpomelo <a href="https://github.com/NetEase/chatofpomelo">https://github.com/NetEase/chatofpomelo</a></li>
</ul>


<p>查阅本文时请注意版本差异.</p>

<h3>环境配置</h3>

<p>我们的目标是实现OS X, IOS, Android三个平台下的chatofpomelo的Cocos2d-x版本. <br/>
所以需要安装各自平台的开发工具如Xcode,Eclipse,NDK等, 不是本文需要关心的内容. 相信大家也已经轻车熟路了. <br/>
Pomelo的安装 <code>npm install pomelo -g</code>, 如有疑问请查看Pomelo的Wiki. <br/>
websocketpp需要著名的C++库, boost. 我是使用了HomeBrew来安装.
其他安装方式请自省查阅相关文档, 有一点需要指出的是, 必须编译为带有x86(i386)支持lib文件.
因为Cocos2d-x在OS X下是32位的.   <br/>
<code>sh HomeBrew安装boost库
brew install boost --universal
</code>
上面这条命令中<code>--universal</code>即代表编译出来的boost的lib文件同时支持x86和x64.</p>

<h3>项目配置</h3>

<p>Cocos2d-x跨平台无疑做的很好, 但是如果手动创建一个结构良好的跨平台项目,还是一件非常棘手的事. <br/>
幸好我们可以偷懒, 打开Cocos2d-x的源代码, samples目录下面都是已经配置好的跨平台的项目文件.
合理利用, 将事半功倍.</p>

<p>我们将samples目录下HelloCpp复制为ChatOfPomelo,打开找到proj.mac目录下面的<code>HelloCpp.xcodeproj</code>,
可以将其重命名为<code>ChatOfPomelo-Mac.xcodeproj</code>, 以便于和接下来的ios项目有所区分.</p>

<p>在ChatOfPomelo下创建lib目录, 下载socket.io-clientpp和websocketpp并解压到lib目录下面.
并将socket.io-clientpp/lib/rapidjson 复制到lib目录下面.  <br/>
目录结构应该是这样的.
<code>sh 目录
ChatOfPomelo/
├── Classes
├── Resources
├── lib
│   ├── rapidjson
│   ├── socket.io-clientpp
│   └── websocketpp
├── proj.android
├── proj.blackberry
├── proj.ios
├── proj.linux
├── proj.mac
├── proj.marmalade
└── proj.win32
</code>
我们打开proj.mac下的项目文件, 在Xcode中打开项目设置页, 点开Targets的设置.
在Build Settings下面找到<code>Search Paths</code>, 将<code>Always Search User Paths</code>设置为<code>Yes</code>. <br/>
给<code>Header Search Paths</code> 依次添加下面路径:
<code>
/usr/local/include_code
"$(SRCROOT)/../lib/socket.io-clientpp/src"
"$(SRCROOT)/../lib/websocketpp/src"
"$(SRCROOT)/../lib/rapidjson/include"
</code>
如下图所示:
{%img /upload/2013-01/chat-of-pomelo-cocos2d-x-001.png %}</p>

<p>给<code>Library Search Paths</code>添加路径<code>/usr/local/lib</code>. 如下图:
{%img /upload/2013-01/chat-of-pomelo-cocos2d-x-002.png %}</p>

<p>其中<code>/usr/local/include</code>和<code>/usr/local/lib</code>是boost的所在位置(HomeBrew的默认安装位置).
如果你的boost不在上述位置, 请自行更改.</p>

<p>接下来将<code>websocketpp</code>的工程文件添加进来.参见下图:    <br/>
{%img /upload/2013-01/chat-of-pomelo-cocos2d-x-003.png %}</p>

<p>然后打开工程的设置, 在Targets的Build Phases页面,找到<code>Link Binary With Libraries</code>,
添加<code>libwebsocketpp.a</code>, 以及boost的库文件(在/usr/local/lib中找到).     <br/>
<code>sh boost 需要添加的库文件列表
libboost_date_time-mt.a
libboost_graph-mt.a
libboost_random-mt.a
libboost_regex-mt.a
libboost_system-mt.a
libboost_thread-mt.a
libboost_timer-mt.a
</code>
添加的方法参见下图:  <br/>
{%img /upload/2013-01/chat-of-pomelo-cocos2d-x-004.png %}</p>

<h2>文件Hack</h2>

<p>我们在<code>HelloWorldScene.cpp</code>中添加一句<code>#include &lt;socket_io_client.hpp&gt;</code>. <br/>
然后试图运行项目的话, 会看到几处报错(有可能你看到这篇文章的时候相关库文件已经更新了, 没有报错的话, 直接跳过这段即可.) <br/>
报错的是<code>socket_io_client.hpp</code>中的<code>std::function</code>以及<code>std::unique_ptr</code>等.</p>

<p>这是因为这些语句是C++11的新语法. 而如果在Xcode中启用C++11的支持,则Cocos2d-x无法通过编译.
原因有人说是Cocos2d-x不支持C++11, 有人说是OS X自带的libc++库太旧的原因, Xcode4.6中会更新该库.
我是小菜鸟一只, 也分不清谁说的对.</p>

<p>但我们可以通过修改这些代码, 采用boost的API来完成相应的工作.
而websocketpp这个项目又大量采用了boost, 所以修改为boost的API还是挺划算的.</p>

<p>找到<code>socket_io_client.hpp</code>:<br/>
``` cpp socket_io_client.hpp
//typedef std::function<void (socketio_events&, const Value&)> eventFunc;
//修改为
typedef boost::function<void (socketio_events&, const Value&)> eventFunc;</p>

<p>//std::unique_ptr&lt;boost::asio::deadline_timer> m_heartbeatTimer;
//修改为
boost::shared_ptr&lt;boost::asio::deadline_timer> m_heartbeatTimer;
```</p>

<p>找到<code>socket_io_client.cpp</code>:
<code>cpp socket_io_client.cpp
//m_heartbeatTimer = std::unique_ptr&lt;boost::asio::deadline_timer&gt;(new boost::asio::deadline_timer(con-&gt;get_io_service(), boost::posix_time::seconds(0)));
//修改为
m_heartbeatTimer = boost::shared_ptr&lt;boost::asio::deadline_timer&gt;(new boost::asio::deadline_timer(con-&gt;get_io_service(), boost::posix_time::seconds(0)));
</code>
打开<code>lib/rapidjson/include/rapidjson/document.h</code>:
<code>cp document.h
//if (reader.Parse&lt;parseFlags&gt;(is, *this)) {
修改为
if (reader.template Parse&lt;parseFlags&gt;(is, *this)) {"
//这个是jsoncpp的一个bug, 新版本里面已经修复, 但socket_io_client绑定了旧版本, 暂未升级.
</code></p>

<p>这是整个项目应该就可以正常编译运行了. 如果没能正常运行, 你可能在某一步出错了,
可以在下面评论分享下你的问题, 如果已经找到解决办法, 也要把解决方法也贴出来, 分享给大家哦, 亲!</p>

<p>//将socket_io_client, websocketpp的cpp文件引入到项目.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2d-x深读4:CCAutoReleasePool]]></title>
    <link href="http://young40.github.io/blog/2013/01/03/cocos2d-x-source-code-research-4-ccautoreleasepool/"/>
    <updated>2013-01-03T15:09:00+08:00</updated>
    <id>http://young40.github.io/blog/2013/01/03/cocos2d-x-source-code-research-4-ccautoreleasepool</id>
    <content type="html"><![CDATA[<p><code>CCAutoReleasePool.h</code>主要定义了两个类<code>CCAutoReleasePool</code>和<code>CCPoolManager</code>.</p>

<p>其实因为cocos2d-x自动管理内存的原因, 所以, 我们平时很少需要直接使用这两个类.  <br/>
为了探究其中的自动管理内存的机制, 我们直接分析其代码.</p>

<p>总体上来讲, 内存管理这块的机制难度或许比较大. 我研究了一天, 还是有诸多疑问.  <br/>
暂时先放一放, 待我功力进化后再来继续研究这块.</p>

<!--more-->


<ul>
<li>版本:<code>cocos2d-2.1beta3-x-2.1.0</code></li>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/cocoa/CCAutoReleasePool.h</code></li>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/cocoa/CCAutoReleasePool.cpp</code></li>
</ul>


<p>{% include_code CCAutoReleasePool.h lang:cpp  cocos2d-x-research/2.1.1/cocos2dx/cocoa/CCAutoReleasePool.h %}
{% include_code CCAutoReleasePool.cpp lang:cpp  cocos2d-x-research/2.1.1/cocos2dx/cocoa/CCAutoReleasePool.cpp %}</p>

<ul>
<li>参考1: <a href="http://4137613.blog.51cto.com/4127613/784134">http://4137613.blog.51cto.com/4127613/784134</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2d-x深读3:CCObject]]></title>
    <link href="http://young40.github.io/blog/2012/12/31/cocos2d-x-source-code-research-3-ccobject/"/>
    <updated>2012-12-31T17:21:00+08:00</updated>
    <id>http://young40.github.io/blog/2012/12/31/cocos2d-x-source-code-research-3-ccobject</id>
    <content type="html"><![CDATA[<p>CCObject是绝大部分cocos2d-x类的基类, 我们就从这里一步一步揭开cocos2d-x的奥秘.</p>

<p>CCObject承担了两个重要的功能, 拷贝机制和内存管理.</p>

<h2>拷贝机制</h2>

<p>打开<code>CCObject.h</code> 首先看到的是类CCCopying, 而CCObject是从该类派生. 从这个意义上来讲CCCopying才是大部分类的基类. <br/>
但CCCopying其实非常简单, 再加上没有其他类从CCCopying派生, 所以说CCObject才是大部分类的基类也是不错的. 我认为CCCopying仅仅是一个接口性质.</p>

<p>CCCopying这个类非常简单, 只有一个成员函数copyWithZone(CCZone *pZone); 简单到其实现只是为了报错. 尽管如此, 但其却承担了拷贝机制这一重要的功能.</p>

<p>cocos2d-x和cocos2d-iphone是近亲, 所以cocos2d-x在API上会和cocos2d-iphone保持一致, 代码上也多有借鉴. CCObject明显就有很多NSObject的痕迹.
当然我对Objective-c并不熟悉, 这里都是些猜测罢了. copyWithZone或许就是借鉴了Obj-c.</p>

<p>我们先来看下拷贝机制, 至于CCObject的代码倒不忙着看.</p>

<!--more-->


<p>这两段代码来至于类CCArray, 我们可以看到调用了原对象的copy()来拷贝一份新的CCArray.<br/>
而copy()则定义于CCObject中, 其工作就是调用copyWithZone.</p>

<p>``` cpp CCArray
CCArray<em> CCArray::createWithArray(CCArray</em> otherArray)
{</p>

<pre><code>CCArray* pRet = (CCArray*)otherArray-&gt;copy();
pRet-&gt;autorelease();
return pRet;
</code></pre>

<p>}
/////&mdash;&mdash;&mdash;&mdash;&mdash;////
CCObject<em> CCArray::copyWithZone(CCZone</em> pZone)
{</p>

<pre><code>CCAssert(pZone == NULL, "CCArray should not be inherited.");
CCArray* pArray = new CCArray();
pArray-&gt;initWithCapacity(this-&gt;data-&gt;num &gt; 0 ? this-&gt;data-&gt;num : 1);

CCObject* pObj = NULL;
CCObject* pTmpObj = NULL;
CCARRAY_FOREACH(this, pObj)
{
    pTmpObj = pObj-&gt;copy();
    pArray-&gt;addObject(pTmpObj);
    pTmpObj-&gt;release();
}
return pArray;
</code></pre>

<p>}
```
这里面牵涉到两个概念, 深拷贝和浅拷贝. 不清楚的大家可以搜索下, 简而言之, 深拷贝才真正的完全拷贝. cocos2d-x实现的是深拷贝. <br/>
我们在上面CCArray::copyWithZone中可以看到拷贝时对array的各个成员也执行了copy()的动作. <br/>
这样才能防止如果obj2是obj1的浅拷贝, 很容易出现array的元素有可能被过早释放的情况.</p>

<p>这里我们还可以一并说下CCZone这个类, 这个类也很简单, 只有一个构造函数和成员变量. <br/>
``` cpp CCZone
class CC_DLL CCZone
{
public:</p>

<pre><code>CCZone(CCObject *pObject = NULL);
</code></pre>

<p>public:</p>

<pre><code>CCObject *m_pCopyObject;
</code></pre>

<p>};
<code>
我想CCZone存在的目的就是为了调用copyWithZone的时候对象传递方便.比如我们还可以看下CCSpeed的copyWithZone函数.   
</code> cpp CCSpeed
CCObject <em>CCSpeed::copyWithZone(CCZone </em>pZone)
{</p>

<pre><code>CCZone* pNewZone = NULL;
CCSpeed* pRet = NULL;
if(pZone &amp;&amp; pZone-&gt;m_pCopyObject) //in case of being called at sub class
{
    pRet = (CCSpeed*)(pZone-&gt;m_pCopyObject);
}
else
{
    pRet = new CCSpeed();
    pZone = pNewZone = new CCZone(pRet);
}
CCAction::copyWithZone(pZone);

pRet-&gt;initWithAction( (CCActionInterval*)(m_pInnerAction-&gt;copy()-&gt;autorelease()) , m_fSpeed );

CC_SAFE_DELETE(pNewZone);
return pRet;
</code></pre>

<p>}
<code>``
我们可以看到构建了一个pZone, 然后调用父类的</code>CCAction::copyWithZone(pZone);`. <br/>
完全是为了copyWithZone方便传递变量而创建的.</p>

<p>拷贝机制看起来有点复杂, 但其实用起来很简单. 我觉得就两点, 1,使用copy()调用 2.各个类对自己的copyWithZone负责.</p>

<h2>内存管理</h2>

<p>cocos2d-x的内存管理采用了引用计数的方法. 曾经看到过有人吐槽其内存管理在多线程下不好用.</p>

<p>CCObject及其子类的对象在创建时, 引用计数默认为1, 每次retain后引用计数加1. 每次release后引用计数减1.
被自动管理的对象引用计数为0时, 会被自动释放.</p>

<p>老G总结的内存管理使用的几点原则(见参考1): <br/>
&ndash; 原则1: 谁生成(new, copy)谁负责release. <br/>
&ndash; 原则2: 谁retain, 谁负责release.  <br/>
&ndash; 原则3: 对于使用了autorelease的对象则不必管他.</p>

<h2>几个常用的函数指针</h2>

<p>当我看到下面这两句的时候, 我完全懵了. <br/>
``` cpp
typedef void (CCObject::*SEL_SCHEDULE)(float);</p>

<h1>define schedule_selector(<em>SELECTOR) (SEL_SCHEDULE)(&amp;</em>SELECTOR)</h1>

<p>```
如果你也对函数指针不熟悉的话, 请翻下相关内容吧.
在这两句里面, 第一句其实是定义了一个返回类型为void的, 名字为SEL_SCHEDULE的, 参数为float的函数指针. <br/>
第二句其实是一个函数类型转换, 将(&amp;_SELECTOR)强制转换成SEL_SCHEDULE类型的函数指针.</p>

<p>通常需要回调函数的时候, 就需要用到这些函数指针. 这里就不再赘述, 以后应该会提及相关知识.</p>

<p>好, 我们接下来直接翻代码吧.</p>

<ul>
<li>版本:<code>cocos2d-2.1beta3-x-2.1.0</code></li>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/cocoa/CCObject.h</code></li>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/cocoa/CCObject.cpp</code></li>
</ul>


<p>{% include_code CCobject.h lang:cpp  cocos2d-x-research/2.1.1/cocos2dx/cocoa/CCObject.h %}
{% include_code CCobject.cpp lang:cpp  cocos2d-x-research/2.1.1/cocos2dx/cocoa/CCObject.cpp %}</p>

<ul>
<li>参考1: <a href="http://4137613.blog.51cto.com/4127613/784134">http://4137613.blog.51cto.com/4127613/784134</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一步一步CocosBuilder(4)[完结]]]></title>
    <link href="http://young40.github.io/blog/2012/12/29/cocosbuilder-step-by-step-part-four/"/>
    <updated>2012-12-29T10:54:00+08:00</updated>
    <id>http://young40.github.io/blog/2012/12/29/cocosbuilder-step-by-step-part-four</id>
    <content type="html"><![CDATA[<p>这一节也是很轻松, 主要是牵涉到Timeline的切换. 其他的都是简单的界面制作. <br/>
所以CocosBuilder的威力也体现在这里, 很少的代码就能驱动界面了.</p>

<p>我们这次先做<code>Particle System</code>, <code>Scroll View</code>, 最后以<code>Animations</code>收官.</p>

<h5>1</h5>

<p>制作<code>Particle System</code>和<code>Scroll View</code>的界面很简单,我们也是以程序为重点, 所以不再赘述. <br/>
只需要一句<code>this-&gt;openTest("ccb/Scroll.ccbi");</code>就可以调用新的界面了. <br/>
其他诸如绑定之类相信大家已经是轻车熟路啦.</p>

<!--more-->


<p>{% img /upload/2012-12/ccb-sbs-4-001.png %}
{% img /upload/2012-12/ccb-sbs-4-002.png %}</p>

<h5>2</h5>

<p>好吧, 我承认一点, 制作<code>Animations</code>的界面的时候, 我直接复制了例子中的节点. <br/>
5个Timeline, 还是很复杂的, 应该是一个非常精细的工作. 向美术们致敬. <br/>
``` cpp AnimationsLayer.h
class AnimationsLayer
: public cocos2d::CCLayer
, public cocos2d::extension::CCBSelectorResolver
{
public:</p>

<pre><code>AnimationsLayer();
~AnimationsLayer();

CCB_STATIC_NEW_AUTORELEASE_OBJECT_WITH_INIT_METHOD(AnimationsLayer, create);

virtual cocos2d::SEL_MenuHandler onResolveCCBCCMenuItemSelector(CCObject * pTarget, const char* pSelectorName);
virtual cocos2d::extension::SEL_CCControlHandler onResolveCCBCCControlSelector(CCObject * pTarget, const char* pSelectorName);    
void setAnimationManager(cocos2d::extension::CCBAnimationManager *pAnimationManager);

void onIdle(cocos2d::CCObject * pSender, cocos2d::extension::CCControlEvent pCCControlEvent);
void onWave(cocos2d::CCObject * pSender, cocos2d::extension::CCControlEvent pCCControlEvent);
void onJump(cocos2d::CCObject * pSender, cocos2d::extension::CCControlEvent pCCControlEvent);
void onFunky(cocos2d::CCObject * pSender, cocos2d::extension::CCControlEvent pCCControlEvent);
</code></pre>

<p>private:</p>

<pre><code>cocos2d::extension::CCBAnimationManager *mAnimationManager;
</code></pre>

<p>};</p>

<p>class AnimationsLayerLoader : public cocos2d::extension::CCNodeLoader
{
public:</p>

<pre><code>CCB_STATIC_NEW_AUTORELEASE_OBJECT_METHOD(AnimationsLayerLoader, loader);
</code></pre>

<p>protected:</p>

<pre><code>CCB_VIRTUAL_NEW_AUTORELEASE_CREATECCNODE_METHOD(AnimationsLayer);
</code></pre>

<p>};
<code>
</code> cpp AnimationsLayer.cpp
AnimationsLayer::AnimationsLayer()
: mAnimationManager(NULL)
{}</p>

<p>AnimationsLayer::~AnimationsLayer()
{</p>

<pre><code>CC_SAFE_RELEASE_NULL(mAnimationManager);
</code></pre>

<p>}</p>

<p>SEL_MenuHandler AnimationsLayer::onResolveCCBCCMenuItemSelector(cocos2d::CCObject <em>pTarget, const char </em>pSelectorName)
{</p>

<pre><code>return NULL;
</code></pre>

<p>}</p>

<p>SEL_CCControlHandler AnimationsLayer::onResolveCCBCCControlSelector(cocos2d::CCObject <em>pTarget, const char </em>pSelectorName)
{</p>

<pre><code>CCB_SELECTORRESOLVER_CCCONTROL_GLUE(this, "onIdle", AnimationsLayer::onIdle);
CCB_SELECTORRESOLVER_CCCONTROL_GLUE(this, "onJump", AnimationsLayer::onJump);
CCB_SELECTORRESOLVER_CCCONTROL_GLUE(this, "onWave", AnimationsLayer::onWave);
CCB_SELECTORRESOLVER_CCCONTROL_GLUE(this, "onFunky", AnimationsLayer::onFunky);

return NULL;
</code></pre>

<p>}</p>

<p>void AnimationsLayer::setAnimationManager(cocos2d::extension::CCBAnimationManager *pAnimationManager)
{</p>

<pre><code>CC_SAFE_RELEASE_NULL(mAnimationManager);
mAnimationManager = pAnimationManager;
CC_SAFE_RETAIN(mAnimationManager);
</code></pre>

<p>}</p>

<p>void AnimationsLayer::onIdle(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)
{</p>

<pre><code>this-&gt;mAnimationManager-&gt;runAnimationsForSequenceNamedTweenDuration("Idle", 0.3f);
</code></pre>

<p>}</p>

<p>void AnimationsLayer::onJump(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)
{</p>

<pre><code>this-&gt;mAnimationManager-&gt;runAnimationsForSequenceNamedTweenDuration("Jump", 0.3f);
</code></pre>

<p>}</p>

<p>void AnimationsLayer::onWave(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)
{</p>

<pre><code>this-&gt;mAnimationManager-&gt;runAnimationsForSequenceNamedTweenDuration("Wave", 0.3f);
</code></pre>

<p>}</p>

<p>void AnimationsLayer::onFunky(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)
{</p>

<pre><code>this-&gt;mAnimationManager-&gt;runAnimationsForSequenceNamedTweenDuration("Funky", 0.3f);
</code></pre>

<p>}
<code>
整个代码还是很简单. 和以前的几个例子稍微有点不同的是在调用的时候, 需要把`CCBReader`里面的`AnimationManger`传入.   
好, 还是看下调用的代码吧.   
</code> cpp MainScene.cpp
void MainScene::onAnimations(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)
{</p>

<pre><code>const char * pCCBFileName = "ccb/Animations.ccbi";
const char * pCCNodeName = "AnimationsLayer";
cocos2d::extension::CCNodeLoader * pCCNodeLoader = AnimationsLayerLoader::loader();

CCScene *scene = CCScene::create();

CCNodeLoaderLibrary *lib = CCNodeLoaderLibrary::newDefaultCCNodeLoaderLibrary();

lib-&gt;registerCCNodeLoader("HeaderLayer", HeaderLayerLoader::loader());

if (pCCNodeName!=NULL &amp;&amp; pCCNodeLoader!=NULL)
{
    lib-&gt;registerCCNodeLoader(pCCNodeName, pCCNodeLoader);
}

CCBReader *reader = new CCBReader(lib);
CCNode *node = reader-&gt;readNodeGraphFromFile(pCCBFileName, this);
reader-&gt;autorelease();

if (node != NULL)
{
    //获取AnimationManger 并传给AnimationsLayer
    ((AnimationsLayer*)node) -&gt;setAnimationManager(reader-&gt;getAnimationManager());

    scene-&gt;addChild(node);
}

this-&gt;mTitleLabelTTF-&gt;setString(pCCBFileName);

CCDirector::sharedDirector()-&gt;pushScene(scene);
</code></pre>

<p>}
```</p>

<p>{% img /upload/2012-12/ccb-sbs-4-003.png %}</p>

<h3>后记</h3>

<p>看到微博上@做游戏的老G 吐槽说CocosBuilder如何不好用, 学习难度比较大. 我也是很认可这一点. <br/>
但是只要是坚持把TestCpp例子完全读完了, 相信掌握CocosBuilder也是很快能够做到的. <br/>
既然你看完了这个教程. 相信你也已经能够很好地驾驭CocosBuilder. 关键还在实践呦!</p>

<p>微博上@Ghost_233 说了一个很好的思路, 直接从ccb文件中生成对应的C++类, 而且他还做了一些实践. <br/>
我暂时还没有研究他的代码, 不过肯定是可行. 这是一个很赞的思路. <br/>
希望大家能动手, 最好合作出来一个较好的工具来, 我想, 是不是集成到CocosBuilder会更好?</p>

<p>谢谢大家耐心看完我的文章.</p>

<p>{% render_partial _posts/cocosbuilder-step-by-step-footer.markdown %}</p>
]]></content>
  </entry>
  
</feed>
