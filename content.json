{"meta":{"title":"杨世玲的游戏开发修行笔记","subtitle":"和平行世界的自己握手","description":"一个游戏开发修行者的博客","author":"杨世玲","url":"http://www.young40.com"},"pages":[{"title":"博客记","date":"2015-07-25T00:00:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"blog/2015-07-25-blogging-updated.html","permalink":"http://www.young40.com/blog/2015-07-25-blogging-updated.html","excerpt":"很羡慕那些高产的博主，看下自己的上一篇文章还停留在1月份, 甚是惭愧. 最近，博客有一些好的变化， 希望能激励自己，多学习， 多写文章。 域名 在网络上一直使用young40这个网名，所以十年前还在学校的时候注册过www.young40.com这个域名, 但每年近百大洋的注册费用也是不小的负担，于是一两年后就停止续费了。上班了之后，想重新注册 ，发现已经被人注册，也联系不上注册者, 于是每年都会看下是否可以注册。 上个月再次查看是否可以注册，我几乎不能相信自己的眼睛， 居然可以注册了，欣喜若狂，马上 注册，相隔十年之后，再次拥有了这个域名。","text":"很羡慕那些高产的博主，看下自己的上一篇文章还停留在1月份, 甚是惭愧. 最近，博客有一些好的变化， 希望能激励自己，多学习， 多写文章。 域名 在网络上一直使用young40这个网名，所以十年前还在学校的时候注册过www.young40.com这个域名, 但每年近百大洋的注册费用也是不小的负担，于是一两年后就停止续费了。上班了之后，想重新注册 ，发现已经被人注册，也联系不上注册者, 于是每年都会看下是否可以注册。 上个月再次查看是否可以注册，我几乎不能相信自己的眼睛， 居然可以注册了，欣喜若狂，马上 注册，相隔十年之后，再次拥有了这个域名。 Octopress 之前也在博客园等地方写过博客，一方面因为懒癌产出甚少，另一方面没有归属感。Github Pages流行之 后，我也尝试在Github Pages上写博客了。 比较了几个Github Pages的博客工具之后，迅速被Octopress 的强大，美观吸引了。是的，即使是默认主题，也是十分优美漂亮。 Hexo 作为一个程序员，对各种语言本不该有偏见，但对于Ruby这种语言始终提不起兴趣，甚至到现在还没有看过他 的语法。Octopress基于Ruby, 速度上也一直被诟病。 我对Node.js虽然没有花费太多的力气学习，但 内心深处还是很狂热地热爱着Node.js。Hexo是Node.js开发的, 所以很快就迁移到了Hexo上。 Org-mode 和 Hexo3 自从被子龙山人带入了Emacs邪教，Emacs就侵噬着我心灵的方方面面，到现在已经恨不得所有的事情都在Emacs 里面完成。Org-mode作为Emacs特有的特性，也是必须学习和使用的，自然写博客这种事情， 也必须在Org-mode 下完成。经过几天对比之后，终于选定了org-octopress作为博客写作的框架。尽管org-octopress 是为 Octopress开发的，实际上Hexo和Octopress高度兼容，org-octopress也是可以直接用在Hexo上。在研究 org-octopress的过程中， 也随便将Hexo更新为了3.1.1版本. 迁移 Octopress迁移到Hexo，以及Hexo 2.x迁移到3.x，都是非常简单的. 基本上就是保存好自己的_config.yml 配置文件和source目录， 用新的(比如Hexo3)初始化一个新目录，然后将source目录放入新的目录, 将配置转移到新的_config.yml中即可. 小结 最近为了使用Emacs，耗费了大量的精力来学习Emacs, Spacemacs, Org-mode, GTD等知识，这次对博客 进行了一次升级, 希望能激励自己多些文章， 将最近学习Emacs等心得都分享出来. 本文使用Emacs 24.5, Org-mode 8.2以及org-octopress 完成. Date: 2015-07-25 Validate"},{"title":"Spacemacs 一问一答(一)","date":"2015-07-26T00:00:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"blog/2015-07-26-master-spacemacs-answer-by-answer-1.html","permalink":"http://www.young40.com/blog/2015-07-26-master-spacemacs-answer-by-answer-1.html","excerpt":"你为什么会选择Spacemacs? 在选择编辑器这件事上, 我一直在追随子龙山人的脚步. 在他的带领下, 我成为了光荣的Vim党员, 继而又蜕变成了Emacs邪教徒. 在最初使用Emacs的日子里，过的很艰难，一向崇尚从零开始的我，迷失在了配置的迷雾中。再加上被人忽悠去做了Cocos IDE的小白鼠， 看起来就要和Emacs无缘了，然而&#x2026; 然而有一天，我看到的子龙酷拽Spacemacs的视频，+再加上Cocos IDE项目被其Cocos官方放弃，我面临着无编辑器可用的囧境+。 说实在话， 我被震撼了。熟悉的Vim的操作方式，简易而强大的配置功能， 还有强过Markdown百倍的Org-mode, 美味的番茄工作法&#x2026; 这就是我想要的编辑器, 征服神的编辑器，做一个编辑器的神!!!","text":"你为什么会选择Spacemacs? 在选择编辑器这件事上, 我一直在追随子龙山人的脚步. 在他的带领下, 我成为了光荣的Vim党员, 继而又蜕变成了Emacs邪教徒. 在最初使用Emacs的日子里，过的很艰难，一向崇尚从零开始的我，迷失在了配置的迷雾中。再加上被人忽悠去做了Cocos IDE的小白鼠， 看起来就要和Emacs无缘了，然而&#x2026; 然而有一天，我看到的子龙酷拽Spacemacs的视频，+再加上Cocos IDE项目被其Cocos官方放弃，我面临着无编辑器可用的囧境+。 说实在话， 我被震撼了。熟悉的Vim的操作方式，简易而强大的配置功能， 还有强过Markdown百倍的Org-mode, 美味的番茄工作法&#x2026; 这就是我想要的编辑器, 征服神的编辑器，做一个编辑器的神!!! 简单介绍下Spacemacs? Spacemacs是Emacs的一个配置框架, 帮助你快速地打造自己的专属Emacs. 借助于evil-mode, Spacemacs致力于将Model Editing带到Emacs平台. 所以，我觉得Spacemacs给了Vim党一个非常好的机会迁移到Emcas平台。+ Spacemacs使用了melpa.org的第三方package包管理系统, 这基本上可以涵盖你的所有需求，你所做的只是对需要用到的package进行配置。+ Spacemacs有非常棒的第三方包管理系统， melpa.org上2500+ 个包，可以直接被安装调用， 你所做的只是对需要用到的package进行配置。 我该如何入门? 首先，你应该知道Spacemacs的官网即其托管在Github上的源码. 我想你此刻应该打开了Spacemacs的Github页面，顺手Star 一下总是没错的。 接着, 你应该阅读下面几篇文档. README.md DOCUMENTATION.org CONVENTIONS.org HOWTOs.org VIMUSERS.org CONTRIBUTE.org 读完这些文档，你就可以按照 README.md 中 安装这一段进行安装了。赶快去试试吧。 应该如何选择Emacs的版本? 在上面提到的 README.md 中， 你可以找到Spacemacs官方推荐的OS X的GUI版本，相信官方推荐的总是没错的。在终端中也可以使用， 但某些功能可能需要GUI才行。另外，建议尽可能升级到最新的stable版本。什么？你问Windows版本？ 对不起，您可以关闭这个页面了， 请您赶紧打开苹果官网，订购一台Mac，在Mac上打开本页面了. 我是否应该学习Elisp? 因为Spacemacs的配置都是Elisp语法， 所以，掌握基本的Elisp语法，是必须的。推荐您阅读 叶文彬 大神的 &lt;Elisp 入门&gt;, 很容易找到. Spacemacs 是怎么工作的? 作为一个刚入门的菜鸟，我只能告诉你，我简单的理解。~/.emacs.d 目录保存了Spacemacs的核心框架和预先配置好的各种layer. 你可以在~/.emacs.d/contrib目录里找到官方配置好的各种layer. ~/.emacs.d/elpa 目录保存了下载到的package。 ~/.emacs.d/private/ 目录可以保存你自己layer， 但强烈不建议你放在这里。 关于 .spacemacs 文件，你能说点什么吗？ 首先，.spacemacs 位于你的用户目录(~/)下，如果你不小心弄丢，弄乱了，弄错了. 可以从~/.emacs.d/core/templates/.spacemacs.template 复制一份到~/.spacemacs. 其次，上手之后，你应该会有自己的layer，如果你配置自己的layer目录，可以找到下面这个变量。需要注意的是，目录需要以 \"/\" 结尾，别问我为什么要特别强调这个. 例如我的，dotspacemacs-configuration-layer-path '(\"~/dot/spacemacs-private/\") 再次，推荐你在dotspacemacs-configuration-layers变量里配置需要加载的layer时，按字母顺序来排放这些layer 能不能看下你的Spacemacs的配置？ 我是用Spacemacs仅仅只是入门，还有很多东西需要学习研究。我的配置大部分都是从子龙山人的配置里面摘录出来的, 我也 推荐你研究下子龙山人的配置，链接1 链接2。但鉴于我是一个菜鸟，我的配置可能也比较适合刚入门的童鞋研究，我的配置链接. 同时我也在不断更新着我的配置，如果你已经打开了Github的页面，那么不如顺手Star一下我的配置吧。 如何创建一个layer? http://melpa.org/#/ https://github.com/syl20bnr/spacemacs/blob/master/doc/DOCUMENTATION.org https://github.com/syl20bnr/spacemacs/blob/master/doc/VIMUSERS.org https://github.com/syl20bnr/spacemacs/blob/master/doc/CONTRIBUTE.org https://github.com/syl20bnr/spacemacs/blob/master/doc/CONVENTIONS.org https://github.com/syl20bnr/spacemacs/blob/master/doc/HOWTOs.org Date: 2015-07-26 Validate"},{"title":"简简单单 OpenGL 00","date":"2015-09-11T00:00:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"blog/2015-09-11-easy-opengl-00.html","permalink":"http://www.young40.com/blog/2015-09-11-easy-opengl-00.html","excerpt":"前言 作为一个屌丝级的 Cocos 2D 程序员, 一直对 Unreal 等 3D 引擎垂涎三尺, 但苦于各种因 素限制(主要是懒), 屡屡想征服 3D, 屡屡败下阵来. 版本 OpenGL 4.1 GLFW 3.1.1 OS X El Capitan 10.11(GM) Xcode 7.0(GM) ssss 为什么选择 OS X Win? iOS? 为什么是现代 OpenGL","text":"前言 作为一个屌丝级的 Cocos 2D 程序员, 一直对 Unreal 等 3D 引擎垂涎三尺, 但苦于各种因 素限制(主要是懒), 屡屡想征服 3D, 屡屡败下阵来. 版本 OpenGL 4.1 GLFW 3.1.1 OS X El Capitan 10.11(GM) Xcode 7.0(GM) ssss 为什么选择 OS X Win? iOS? 为什么是现代 OpenGL Date: 2015-09-11 Validate"},{"title":"简简单单 OpenGL 01","date":"2015-09-12T00:00:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"blog/2015-09-12-easy-opengl-01.html","permalink":"http://www.young40.com/blog/2015-09-12-easy-opengl-01.html","excerpt":"目标 &#x2013; 构建 OpenGL 上下文 在开始学习 OpenGL 时, 创建 OpenGL 上下文是比较困难的一件事情. 幸好又了 GLFW 这个开源的 OpenGL 库, 可以让我们轻松地创建 OpenGL 上下文, 并且也可以处理键盘和鼠标等输入事件. 我们在 本节内将通过 GLFW 来创建一个 OpenGL(4.1)的窗口.","text":"目标 &#x2013; 构建 OpenGL 上下文 在开始学习 OpenGL 时, 创建 OpenGL 上下文是比较困难的一件事情. 幸好又了 GLFW 这个开源的 OpenGL 库, 可以让我们轻松地创建 OpenGL 上下文, 并且也可以处理键盘和鼠标等输入事件. 我们在 本节内将通过 GLFW 来创建一个 OpenGL(4.1)的窗口. 编译 GLFW 我们可以在 GLFW 网站 找到下载链接, 注意我们选用的为当前最新版本 3.1.1. 下载并解压. 这 里需要指出的是, 建议大家可以浏览下 GLFW 的文档, 这对我们后续使用 GLFW 非常有帮助, 当然, 我在本 文内也会解释重要的知识. 编译 GLFW 是需要 Xcode 的, 我这里使用的是 Xcode7. 同时我们需要使用 cmake, 如果你没有, 可以使用 强大的 OS X 包管理系统Homebrew 来安装. 这里 可以找到 GLFW 的编译指南, 也很简单： cd &amp;lt;glfw-root-dir&amp;gt;mkdir glfw-buildcd glfw-buildcmake ..make 编译完成后, 可以在 glfw-build/src 下面找到 libglfw3.a 静态库文件, 以及&lt;glfw-root-dir&gt;/include 下的头文件. 稍后会用到这些文件. 设置 Xcode 工程 使用 Xcode 建立一个新的 Command Line Tool 工程, 语言我们这里选择的是 C++. 将上面提到的 include 目录加入到项目的搜索路径, 将 libglfw3.a 以及 Cocoa, OpenGL, IOKit, CoreVideo 等 Framework 加入 到项目 Link Binary With Libraries 里面. Xcode 的使用已经超出本文的讨论范围, 如果对 Xcode 不熟悉 可以参阅其文档. 黑色的 OpenGL 窗口 根据 GLFW 官网给出简单的示例代码, 很容易创建出我们的第一个 OpenGL 窗口. int main(int argc, const char * argv[]) { GLFWwindow *window; if(!glfwInit()) { return -1; } window = glfwCreateWindow(960, 640, \"Tutorial 01\", nullptr, nullptr); if(!window) { glfwTerminate(); return -1; } glfwMakeContextCurrent(window); while (!glfwWindowShouldClose(window)) { //glfwSwapBuffers(window); glfwPollEvents(); } glfwTerminate(); return 0;} 我们使用到了 GLFW 提供的 GLFWindow 类和 6 个函数. glfwInit 初始化 glfw glfwCreateWindow 创建窗口 glfwMakeContextCurrent 给当前窗口设置 OpenGL 上下文 glfwPollEvents 处理系统消息, 键盘鼠标等事件 glfwWindowShouldClose 检查窗口是否需要关闭 glfwTerminate 结束退出 大家可能注意到了我注释掉了 glfwSwapBuffers 函数的调用, 原因是未进行进一步设置前这个函数的 调用, 会导致我屏幕狂闪, 是的, 闪瞎了我的钛合金狗眼. 设置 OpenGL 版本 在程序主循环之前我们调用下面代码获取当前 OpenGL 版本. cout &amp;lt;&amp;lt; glGetString(GL_VERSION) &amp;lt;&amp;lt; endl; 我的输出是: 2.1 NVIDIA-10.6.42 310.42.05f01，其中 2.1 表明了我们将要使用的 OpenGL 版本是 2.1. 如果你了解 OpenGL 的历史, 就会知道 2.1 是一个非常老的版本. 而我们所希望研究的是更为现代的 OpenGL, 比如, 我电脑上支持的最高版本 OpenGL 4.1. 我们在创建窗口之前, 调用下面代码: glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); 然后我们再观察 glGetString(GL_VERSION)的输出. 我的输出为 4.1 NVIDIA-10.6.42 310.42.05f01, 其中 4.1 表明了我们将要使用的 OpenGL 版本是 4.1. 太棒了, 可以使用最现代的 OpenGL 了. 大家可以在 Mac App Store 免费下载到 OpenGL Extensions Viewer, 利用这个软件可以方便地查看 自己电脑所能支持的 OpenGL 版本. glfwSetErrorCallback 设置错误回调 调用 glfwSetErrorCallback 可以给 glfw 添加一个回调函数, 当有错误发生时, 我们可以得到通知. 我们在 main 函数前添加一个 glfw_error_callback 函数: extern \"C\"{ static void glfw_error_callback(int error, const char *desc) { fprintf(stderr, \"Running got error: %d,\\t %s\\n\", error, desc); }} 在 glfwInit 初始化之后就可以设置错误发生时的回调. glfwSetErrorCallback(glfw_error_callback) 为了能看到效果, 大家可以临时注释掉下面两行, 看下效果. glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); TODO 代码 [http://localhost:4000/2015/09/12/2015-09-12-masteringopengl01/] Tip OpenGL 的函数都是以 gl 开头 其他 本文是系列文章的一部分, 您可以在下面链接找到本系列索引. [http://young40.com] ssssss Date: 2015-09-12 Validate"},{"title":"简简单单 OpenGL 02","date":"2015-09-15T00:00:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"blog/2015-09-15-easy-opengl-02.html","permalink":"http://www.young40.com/blog/2015-09-15-easy-opengl-02.html","excerpt":"目标 &#x2013; 一个黄色的三角形 大家肯定尝试过很多的编程语言, 刚接触到一门新的编程语言, 写上一个 Hello World 是必 然的. 在学习 OpenGL 时, 那么第一件事就应该是画一个三角形. 三角形就是 OpenGL 的 Hello World 了. 现代的 OpenGL 做复杂的事情, 特别简单, 而做一件简单的事情, 却看起来特别复杂, 比如, 我们接下来画三角形的这个例子, 是有点复杂的. 我猜想或许有很多有志青年也要学习现代 OpenGL, 还没有上阵就败在了三角形上. 别问我是怎么知道的, 我才不能告诉你我因为一个 三角形退缩的次数捏!","text":"目标 &#x2013; 一个黄色的三角形 大家肯定尝试过很多的编程语言, 刚接触到一门新的编程语言, 写上一个 Hello World 是必 然的. 在学习 OpenGL 时, 那么第一件事就应该是画一个三角形. 三角形就是 OpenGL 的 Hello World 了. 现代的 OpenGL 做复杂的事情, 特别简单, 而做一件简单的事情, 却看起来特别复杂, 比如, 我们接下来画三角形的这个例子, 是有点复杂的. 我猜想或许有很多有志青年也要学习现代 OpenGL, 还没有上阵就败在了三角形上. 别问我是怎么知道的, 我才不能告诉你我因为一个 三角形退缩的次数捏! 屏幕坐标系和右手定则 本系列教程立足于实践, 但 OpenGL 是一门理论和实践并重的学问. 如果不在这里提及一些 OpenGL 的理论, 会感觉没有讲清楚. Date: 2015-09-15 Validate"},{"title":"简简单单 OpenGL 附录","date":"2016-01-01T00:00:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"blog/2016-01-11-easy-opengl-100.html","permalink":"http://www.young40.com/blog/2016-01-11-easy-opengl-100.html","excerpt":"参考资料 书籍 博客 视频 文章","text":"参考资料 书籍 博客 视频 文章 Date: 2016-01-01 Validate"},{"title":"最近这几天","date":"2015-12-09T00:00:00.000Z","updated":"2017-03-15T01:46:29.000Z","comments":true,"path":"blog/2015-12-09-these-days.html","permalink":"http://www.young40.com/blog/2015-12-09-these-days.html","excerpt":"郁结 最近这几天，心中觉得郁结难解。想买一套房子，可惜囊中羞涩，选来选去都要还上几十年的贷款。仅仅是囊中羞涩也就罢了，连任性地回郑州看上两天房子的时间都没有。 更何况买房子要这证明,那证明，少不了到处衙门跑，想到就是心烦。老母亲大人，身体每况愈下，连日失眠以致类月。姐姐帮着找了几地医生看， 也没有什么效果，真恨不得 当初学了医。 优化","text":"郁结 最近这几天，心中觉得郁结难解。想买一套房子，可惜囊中羞涩，选来选去都要还上几十年的贷款。仅仅是囊中羞涩也就罢了，连任性地回郑州看上两天房子的时间都没有。 更何况买房子要这证明,那证明，少不了到处衙门跑，想到就是心烦。老母亲大人，身体每况愈下，连日失眠以致类月。姐姐帮着找了几地医生看， 也没有什么效果，真恨不得 当初学了医。 优化 去年十一月到现在公司，已经整整在这个游戏上花费了一年多的时间，回想起来，这一年都做了些什么，真是惭愧。幸好最近把精力都放在游戏优化和工作流程优化上。 虽然游戏的优化各种指标还没有达到我理想的境地，但工作流程优化显得更加困难一些。身边的同事，有些感觉整体浑浑噩噩，有些做事没有担当，推诿，转眼即忘，着实 令人头疼。游戏的优化，显得要更简单些，优化内存占用，缓存对象，优化逻辑。优化时，最好是有一个 Profile 作为依据，C++层面都是引擎，也没有能力去修改太多， Lua 层面，我十分想做到一个和当年做 php 时用的一个 Profile，一个函数被调用了多少次， 一个函数在一段时间内最长执行时间。 Lua C API 用 Lua，但对 Lua 内的很多机制其实并不了解，这次正好深入了解下。今天，用 Lua C API 实现了 lua 调用 C 函数， 也算是一大收获。但在看的过程中也能看出自己 C/C++ 基础薄弱, 还需要针对性地继续加强 C/C++学习，多写多看. 上面提到的 Profile，看了部分 LuaProfiler，luatrace 的代码，还没有完全跑起来。 接下来实现一个 很好的 Profiler 来当作 Lua 学习的阶段性成果. 方向 接下来要聚焦这些方向，看起来还是满满堂堂的。兴趣太多是我的一大缺点，这已经是收敛过后的列表了。 3D 游戏 OpenGL Unreal 数学 Cocos2d-x 2D 部分 Lua C++ Spacemacs 阅读 最近买了几本书: 编程之法 游戏设计的 263 个技巧 要扩大阅读量了。 新年 2016 转眼就要到新的一年了, 希望 2016 年成为努力的一年，成长的一年，收获的一年。加油！ Date: 2015-12-09 Validate"},{"title":"CocoStudio 节点自动绑定","date":"2017-03-19T00:00:00.000Z","updated":"2017-08-07T10:14:37.000Z","comments":true,"path":"blog/2017-03-19-CocoStudio-auto-binding.html","permalink":"http://www.young40.com/blog/2017-03-19-CocoStudio-auto-binding.html","excerpt":"懒是美德 换了一份工作, 第一步就是需要熟悉现有的代码。作为一个优化狂人，很容易就能从中看出值得优化的地方来。随手打开一个约2600多行的lua文件，发现满屏的seekNodeByName，简单统计一下约260行，10%。 我们在使用CocoStudio的时候，在代码中确实需要使用节点的Name来寻找节点，但不要忘记lua语言的动态性，恰当利用则事半功倍。更何况，懒是一种美德，我们努力思考，就能少写不少代码。","text":"懒是美德 换了一份工作, 第一步就是需要熟悉现有的代码。作为一个优化狂人，很容易就能从中看出值得优化的地方来。随手打开一个约2600多行的lua文件，发现满屏的seekNodeByName，简单统计一下约260行，10%。 我们在使用CocoStudio的时候，在代码中确实需要使用节点的Name来寻找节点，但不要忘记lua语言的动态性，恰当利用则事半功倍。更何况，懒是一种美德，我们努力思考，就能少写不少代码。 自动绑定 假设我们有一个demo.csd文件，结构如下: |--Root |--spr_Background |--lbl_Title |--Node_DefaultName 代码加载的时候，如果能自动绑定到代码改多好啊! DemoLayer = class(\"DemoLayer\", function() return cc.Layer:create() endfunction DemoLayer:init() loadCSB(\"demo.csb\", self) self.lbl_Title:setString(\"自动绑定太爽了\") -- 如何能爽这一下???end 来个实现 下面是一份简单的实现。`attachedTo[nodeName] = child` 中，利用lua的动态性，直接给`attachedTo`这个对象增加新的属性， 这样就能在`loadCSB(\"demo.csb\", self)`后，直接用`self.lbl_Title`来访问节点了。 function loadCSB(csbName) local csbNode = cc.CSLoader:createNode(csbName) gt.bindNodeByName(csbNode, attachedTo) return csbNodeendfunction bindNodeByName(node, attachedTo) local matchTable = {spr_=true, nod_=true, btn_=true, lbl_=true} for _, child in ipairs(node:getChildren()) do local nodeName = child:getName() local nodeNameSub = string.sub(nodeName, 0, 4) if matchTable[nodeNameSub] then attachedTo[nodeName] = child end bindNodeByName(child, attachedTo) endend 一个规则 CocoStudio在编辑csd文件的时候，会给节点加上默认的名字，通常这些名字都是乱七八糟，在代码里再使用这些名字，代码也会变得丑陋不堪。 所以，有必要在CocoStudio中给节点一个有意义的名字，同时如果加上一个规则，还能减少节点绑定的数量。 local matchTable = {spr_=true, nod_=true, btn_=true, lbl_=true}if matchTable[nodeNameSub] then -- 是感兴趣的节点，匹配到了end 我在示例中的规则是以spr_, nod_等为前缀的节点。这里的matchTable有点意思，spr_这些并不是它的值，而是键(key), 所以拿到前缀之后， 可以快速匹配，并不需要再跑一个循环了^_-. 有个技巧 可能会有有序的节点，比如lbl_name1, lbl_name2, lbl_name3&#x2026;, 我们固然可以通过类似于self.lbl_name1等来访问，但有时我们在比如for循环中 如何访问这些节点呢？答案是我们可以利用下标的形式来访问这些节点. local name = self[\"lbl_name\" .. i] 还有没有 这只是一个简单的版本，简单的工程也够用了。复杂一些的话，比如可以加上重名检测，对于列表型的节点加以更多的处理，等等。。。 如果你遇到问题，不妨通过微博联系我。 结束感悟 年复一年，终究是一事无成。能真切地感受到与日俱增的压力, 翻翻上一篇博客已经是一年多年前了，2016年竟是一字未写。想想前面两年的计划，多半是未完成，还有最可惜的Unreal的梦想。 我的新年来的比较晚，Late better than Never, 希望今年能再多些思考，多写文字，多读点书，多点收入。 再来回看正题，从懒这个美德出发，我们在写代码时，处处都可能有值得优化的地方，留心观察，能提出问题，找到解决方案只是时间问题。提出好的问题，才是最宝贵的。 Date: 2017-03-19 Validate"},{"title":"一次 git 花样实战","date":"2015-12-22T00:00:00.000Z","updated":"2017-03-15T01:46:29.000Z","comments":true,"path":"blog/2015-12-22-using-git-as-magics.html","permalink":"http://www.young40.com/blog/2015-12-22-using-git-as-magics.html","excerpt":"情况 周五在家工作了一天，向公司一个提交不频繁的库加了几个提交，但没有推送。其中一个提交，包含了一个 110M 的 cocos2d-x 静态库(是的， 我知道不推荐提交这个，但我还是提交了^_-). 这个库托管在 Oschina 开源中国的 git 站, 周一的时候，我尝试推送这几个提交，发现 Oschina 有 100M 文件大小的限制，纳尼？ 于是开始了 git 的花样实战. 再说一遍, 情况大概是这样, master 分支，我的提交按时间顺序是 C1, C4, C5, 中间有 pull 下来的其他同事的提交以及 merge. C1 包含 110M 文件 110M.a.","text":"情况 周五在家工作了一天，向公司一个提交不频繁的库加了几个提交，但没有推送。其中一个提交，包含了一个 110M 的 cocos2d-x 静态库(是的， 我知道不推荐提交这个，但我还是提交了^_-). 这个库托管在 Oschina 开源中国的 git 站, 周一的时候，我尝试推送这几个提交，发现 Oschina 有 100M 文件大小的限制，纳尼？ 于是开始了 git 的花样实战. 再说一遍, 情况大概是这样, master 分支，我的提交按时间顺序是 C1, C4, C5, 中间有 pull 下来的其他同事的提交以及 merge. C1 包含 110M 文件 110M.a. 备份 万事先备份. git checkout -b masterbackup 获取服务器最新提交 git fetch 这样可以将本地的 origin/master 获取到服务器最新的提交. 重建 master 分支 重建方式是, 删除本地 master, 并重新从 origin/master 创建 master git branch -D master 注意此时在 masterbackup 分支 git checkout -b master origin/master 重做 C1, 并修改提交 git cherry-pick C1 注意此处得到的并不是 C1，应为 C1' git rm 110M.a 删除了无法提交的文件 我这里采用了 split 的方法将其分割为几个小文件, 其他人只需要简单合并这几个文件即可 git add 110M.a_PART1 110M.a_PART2 110M.a_PART3 git commit &#x2013;amend 这个命令可以修改上次提交, 将已经加入到 stage 区的修改合并到上次提交(即 C1') 注意这个命令，万万不可再 push 后使用. (其实是不推荐 push 后使用) 这样我们就修复了这个无法提交的文件了. 同样重做 C4, C5 git cherry-pick C4 git cherry-pick C5 没有什么好说的 推送, 清理战场 git push origin master git branch -D masterbackup 搞定! Date: 2015-12-22 Validate"},{"title":"about","date":"2015-07-24T05:07:58.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"about/index.html","permalink":"http://www.young40.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2015-07-24T05:08:28.000Z","updated":"2017-03-14T07:53:34.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.young40.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"CocoStudio 节点自动绑定","slug":"2017-03-19-CocoStudio-auto-binding","date":"2017-03-19T00:00:00.000Z","updated":"2017-08-07T10:14:37.000Z","comments":true,"path":"2017/03/19/2017-03-19-CocoStudio-auto-binding/","link":"","permalink":"http://www.young40.com/2017/03/19/2017-03-19-CocoStudio-auto-binding/","excerpt":"懒是美德 换了一份工作, 第一步就是需要熟悉现有的代码。作为一个优化狂人，很容易就能从中看出值得优化的地方来。随手打开一个约2600多行的lua文件，发现满屏的seekNodeByName，简单统计一下约260行，10%。 我们在使用CocoStudio的时候，在代码中确实需要使用节点的Name来寻找节点，但不要忘记lua语言的动态性，恰当利用则事半功倍。更何况，懒是一种美德，我们努力思考，就能少写不少代码。","text":"懒是美德 换了一份工作, 第一步就是需要熟悉现有的代码。作为一个优化狂人，很容易就能从中看出值得优化的地方来。随手打开一个约2600多行的lua文件，发现满屏的seekNodeByName，简单统计一下约260行，10%。 我们在使用CocoStudio的时候，在代码中确实需要使用节点的Name来寻找节点，但不要忘记lua语言的动态性，恰当利用则事半功倍。更何况，懒是一种美德，我们努力思考，就能少写不少代码。 自动绑定 假设我们有一个demo.csd文件，结构如下: |--Root |--spr_Background |--lbl_Title |--Node_DefaultName 代码加载的时候，如果能自动绑定到代码改多好啊! DemoLayer = class(\"DemoLayer\", function() return cc.Layer:create() endfunction DemoLayer:init() loadCSB(\"demo.csb\", self) self.lbl_Title:setString(\"自动绑定太爽了\") -- 如何能爽这一下???end 来个实现 下面是一份简单的实现。`attachedTo[nodeName] = child` 中，利用lua的动态性，直接给`attachedTo`这个对象增加新的属性， 这样就能在`loadCSB(\"demo.csb\", self)`后，直接用`self.lbl_Title`来访问节点了。 function loadCSB(csbName) local csbNode = cc.CSLoader:createNode(csbName) gt.bindNodeByName(csbNode, attachedTo) return csbNodeendfunction bindNodeByName(node, attachedTo) local matchTable = {spr_=true, nod_=true, btn_=true, lbl_=true} for _, child in ipairs(node:getChildren()) do local nodeName = child:getName() local nodeNameSub = string.sub(nodeName, 0, 4) if matchTable[nodeNameSub] then attachedTo[nodeName] = child end bindNodeByName(child, attachedTo) endend 一个规则 CocoStudio在编辑csd文件的时候，会给节点加上默认的名字，通常这些名字都是乱七八糟，在代码里再使用这些名字，代码也会变得丑陋不堪。 所以，有必要在CocoStudio中给节点一个有意义的名字，同时如果加上一个规则，还能减少节点绑定的数量。 local matchTable = {spr_=true, nod_=true, btn_=true, lbl_=true}if matchTable[nodeNameSub] then -- 是感兴趣的节点，匹配到了end 我在示例中的规则是以spr_, nod_等为前缀的节点。这里的matchTable有点意思，spr_这些并不是它的值，而是键(key), 所以拿到前缀之后， 可以快速匹配，并不需要再跑一个循环了^_-. 有个技巧 可能会有有序的节点，比如lbl_name1, lbl_name2, lbl_name3&#x2026;, 我们固然可以通过类似于self.lbl_name1等来访问，但有时我们在比如for循环中 如何访问这些节点呢？答案是我们可以利用下标的形式来访问这些节点. local name = self[\"lbl_name\" .. i] 还有没有 这只是一个简单的版本，简单的工程也够用了。复杂一些的话，比如可以加上重名检测，对于列表型的节点加以更多的处理，等等。。。 如果你遇到问题，不妨通过微博联系我。 结束感悟 年复一年，终究是一事无成。能真切地感受到与日俱增的压力, 翻翻上一篇博客已经是一年多年前了，2016年竟是一字未写。想想前面两年的计划，多半是未完成，还有最可惜的Unreal的梦想。 我的新年来的比较晚，Late better than Never, 希望今年能再多些思考，多写文字，多读点书，多点收入。 再来回看正题，从懒这个美德出发，我们在写代码时，处处都可能有值得优化的地方，留心观察，能提出问题，找到解决方案只是时间问题。提出好的问题，才是最宝贵的。 Update bilt兄 看了这篇博客以后，告诉我可以将有序列的节点以数组的方式访问更有效率，我马上更新了下代码，使用起来果然更加方便了. 下面是带序列的节点组合成数组的一个小函数。 function groupNode(group, name, child) -- 聚合序列节点为数组 local _pre, _num = string.match(name, \"(.+)(%d+)$\") if not _pre then return end if string.sub(_pre, -1) == \"_\" then _pre = string.sub(_pre, 1, #_pre-1) end if not group[_pre] then group[_pre] = {} end group[_pre][_num] = childend 如果节点名字是`nod_text1`, `nod_text2`&#x2026; 或者`img_press_1`, `img_press_2`&#x2026;的节点则可以用self.nod_text, self.nod_text来访问了 感谢bilt兄! Date: 2017-03-19 Validate","categories":[],"tags":[]},{"title":"一次 git 花样实战","slug":"2015-12-22-using-git-as-magics","date":"2015-12-22T00:00:00.000Z","updated":"2017-08-07T10:14:37.000Z","comments":true,"path":"2015/12/22/2015-12-22-using-git-as-magics/","link":"","permalink":"http://www.young40.com/2015/12/22/2015-12-22-using-git-as-magics/","excerpt":"情况 周五在家工作了一天，向公司一个提交不频繁的库加了几个提交，但没有推送。其中一个提交，包含了一个 110M 的 cocos2d-x 静态库(是的， 我知道不推荐提交这个，但我还是提交了^_-). 这个库托管在 Oschina 开源中国的 git 站, 周一的时候，我尝试推送这几个提交，发现 Oschina 有 100M 文件大小的限制，纳尼？ 于是开始了 git 的花样实战. 再说一遍, 情况大概是这样, master 分支，我的提交按时间顺序是 C1, C4, C5, 中间有 pull 下来的其他同事的提交以及 merge. C1 包含 110M 文件 110M.a.","text":"情况 周五在家工作了一天，向公司一个提交不频繁的库加了几个提交，但没有推送。其中一个提交，包含了一个 110M 的 cocos2d-x 静态库(是的， 我知道不推荐提交这个，但我还是提交了^_-). 这个库托管在 Oschina 开源中国的 git 站, 周一的时候，我尝试推送这几个提交，发现 Oschina 有 100M 文件大小的限制，纳尼？ 于是开始了 git 的花样实战. 再说一遍, 情况大概是这样, master 分支，我的提交按时间顺序是 C1, C4, C5, 中间有 pull 下来的其他同事的提交以及 merge. C1 包含 110M 文件 110M.a. 备份 万事先备份. git checkout -b masterbackup 获取服务器最新提交 git fetch 这样可以将本地的 origin/master 获取到服务器最新的提交. 重建 master 分支 重建方式是, 删除本地 master, 并重新从 origin/master 创建 master git branch -D master 注意此时在 masterbackup 分支 git checkout -b master origin/master 重做 C1, 并修改提交 git cherry-pick C1 注意此处得到的并不是 C1，应为 C1' git rm 110M.a 删除了无法提交的文件 我这里采用了 split 的方法将其分割为几个小文件, 其他人只需要简单合并这几个文件即可 git add 110M.a_PART1 110M.a_PART2 110M.a_PART3 git commit &#x2013;amend 这个命令可以修改上次提交, 将已经加入到 stage 区的修改合并到上次提交(即 C1') 注意这个命令，万万不可再 push 后使用. (其实是不推荐 push 后使用) 这样我们就修复了这个无法提交的文件了. 同样重做 C4, C5 git cherry-pick C4 git cherry-pick C5 没有什么好说的 推送, 清理战场 git push origin master git branch -D masterbackup 搞定! Date: 2015-12-22 Validate","categories":[],"tags":[]},{"title":"Spacemacs 一问一答(一)","slug":"2015-07-26-master-spacemacs-answer-by-answer-1","date":"2015-07-26T00:00:00.000Z","updated":"2017-08-07T10:14:37.000Z","comments":true,"path":"2015/07/26/2015-07-26-master-spacemacs-answer-by-answer-1/","link":"","permalink":"http://www.young40.com/2015/07/26/2015-07-26-master-spacemacs-answer-by-answer-1/","excerpt":"你为什么会选择Spacemacs? 在选择编辑器这件事上, 我一直在追随子龙山人的脚步. 在他的带领下, 我成为了光荣的Vim党员, 继而又蜕变成了Emacs邪教徒. 在最初使用Emacs的日子里，过的很艰难，一向崇尚从零开始的我，迷失在了配置的迷雾中。再加上被人忽悠去做了Cocos IDE的小白鼠， 看起来就要和Emacs无缘了，然而&#x2026; 然而有一天，我看到的子龙酷拽Spacemacs的视频，+再加上Cocos IDE项目被其Cocos官方放弃，我面临着无编辑器可用的囧境+。 说实在话， 我被震撼了。熟悉的Vim的操作方式，简易而强大的配置功能， 还有强过Markdown百倍的Org-mode, 美味的番茄工作法&#x2026; 这就是我想要的编辑器, 征服神的编辑器，做一个编辑器的神!!!","text":"你为什么会选择Spacemacs? 在选择编辑器这件事上, 我一直在追随子龙山人的脚步. 在他的带领下, 我成为了光荣的Vim党员, 继而又蜕变成了Emacs邪教徒. 在最初使用Emacs的日子里，过的很艰难，一向崇尚从零开始的我，迷失在了配置的迷雾中。再加上被人忽悠去做了Cocos IDE的小白鼠， 看起来就要和Emacs无缘了，然而&#x2026; 然而有一天，我看到的子龙酷拽Spacemacs的视频，+再加上Cocos IDE项目被其Cocos官方放弃，我面临着无编辑器可用的囧境+。 说实在话， 我被震撼了。熟悉的Vim的操作方式，简易而强大的配置功能， 还有强过Markdown百倍的Org-mode, 美味的番茄工作法&#x2026; 这就是我想要的编辑器, 征服神的编辑器，做一个编辑器的神!!! 简单介绍下Spacemacs? Spacemacs是Emacs的一个配置框架, 帮助你快速地打造自己的专属Emacs. 借助于evil-mode, Spacemacs致力于将Model Editing带到Emacs平台. 所以，我觉得Spacemacs给了Vim党一个非常好的机会迁移到Emcas平台。+ Spacemacs使用了melpa.org的第三方package包管理系统, 这基本上可以涵盖你的所有需求，你所做的只是对需要用到的package进行配置。+ Spacemacs有非常棒的第三方包管理系统， melpa.org上2500+ 个包，可以直接被安装调用， 你所做的只是对需要用到的package进行配置。 我该如何入门? 首先，你应该知道Spacemacs的官网即其托管在Github上的源码. 我想你此刻应该打开了Spacemacs的Github页面，顺手Star 一下总是没错的。 接着, 你应该阅读下面几篇文档. README.md DOCUMENTATION.org CONVENTIONS.org HOWTOs.org VIMUSERS.org CONTRIBUTE.org 读完这些文档，你就可以按照 README.md 中 安装这一段进行安装了。赶快去试试吧。 应该如何选择Emacs的版本? 在上面提到的 README.md 中， 你可以找到Spacemacs官方推荐的OS X的GUI版本，相信官方推荐的总是没错的。在终端中也可以使用， 但某些功能可能需要GUI才行。另外，建议尽可能升级到最新的stable版本。什么？你问Windows版本？ 对不起，您可以关闭这个页面了， 请您赶紧打开苹果官网，订购一台Mac，在Mac上打开本页面了. 我是否应该学习Elisp? 因为Spacemacs的配置都是Elisp语法， 所以，掌握基本的Elisp语法，是必须的。推荐您阅读 叶文彬 大神的 &lt;Elisp 入门&gt;, 很容易找到. Spacemacs 是怎么工作的? 作为一个刚入门的菜鸟，我只能告诉你，我简单的理解。~/.emacs.d 目录保存了Spacemacs的核心框架和预先配置好的各种layer. 你可以在~/.emacs.d/contrib目录里找到官方配置好的各种layer. ~/.emacs.d/elpa 目录保存了下载到的package。 ~/.emacs.d/private/ 目录可以保存你自己layer， 但强烈不建议你放在这里。 关于 .spacemacs 文件，你能说点什么吗？ 首先，.spacemacs 位于你的用户目录(~/)下，如果你不小心弄丢，弄乱了，弄错了. 可以从~/.emacs.d/core/templates/.spacemacs.template 复制一份到~/.spacemacs. 其次，上手之后，你应该会有自己的layer，如果你配置自己的layer目录，可以找到下面这个变量。需要注意的是，目录需要以 \"/\" 结尾，别问我为什么要特别强调这个. 例如我的，dotspacemacs-configuration-layer-path '(\"~/dot/spacemacs-private/\") 再次，推荐你在dotspacemacs-configuration-layers变量里配置需要加载的layer时，按字母顺序来排放这些layer 能不能看下你的Spacemacs的配置？ 我是用Spacemacs仅仅只是入门，还有很多东西需要学习研究。我的配置大部分都是从子龙山人的配置里面摘录出来的, 我也 推荐你研究下子龙山人的配置，链接1 链接2。但鉴于我是一个菜鸟，我的配置可能也比较适合刚入门的童鞋研究，我的配置链接. 同时我也在不断更新着我的配置，如果你已经打开了Github的页面，那么不如顺手Star一下我的配置吧。 如何创建一个layer? http://melpa.org/#/ https://github.com/syl20bnr/spacemacs/blob/master/doc/DOCUMENTATION.org https://github.com/syl20bnr/spacemacs/blob/master/doc/VIMUSERS.org https://github.com/syl20bnr/spacemacs/blob/master/doc/CONTRIBUTE.org https://github.com/syl20bnr/spacemacs/blob/master/doc/CONVENTIONS.org https://github.com/syl20bnr/spacemacs/blob/master/doc/HOWTOs.org Date: 2015-07-26 Validate","categories":[],"tags":[]},{"title":"博客记","slug":"2015-07-25-blogging-updated","date":"2015-07-25T00:00:00.000Z","updated":"2017-08-07T10:14:37.000Z","comments":true,"path":"2015/07/25/2015-07-25-blogging-updated/","link":"","permalink":"http://www.young40.com/2015/07/25/2015-07-25-blogging-updated/","excerpt":"很羡慕那些高产的博主，看下自己的上一篇文章还停留在1月份, 甚是惭愧. 最近，博客有一些好的变化， 希望能激励自己，多学习， 多写文章。 域名 在网络上一直使用young40这个网名，所以十年前还在学校的时候注册过www.young40.com这个域名, 但每年近百大洋的注册费用也是不小的负担，于是一两年后就停止续费了。上班了之后，想重新注册 ，发现已经被人注册，也联系不上注册者, 于是每年都会看下是否可以注册。 上个月再次查看是否可以注册，我几乎不能相信自己的眼睛， 居然可以注册了，欣喜若狂，马上 注册，相隔十年之后，再次拥有了这个域名。","text":"很羡慕那些高产的博主，看下自己的上一篇文章还停留在1月份, 甚是惭愧. 最近，博客有一些好的变化， 希望能激励自己，多学习， 多写文章。 域名 在网络上一直使用young40这个网名，所以十年前还在学校的时候注册过www.young40.com这个域名, 但每年近百大洋的注册费用也是不小的负担，于是一两年后就停止续费了。上班了之后，想重新注册 ，发现已经被人注册，也联系不上注册者, 于是每年都会看下是否可以注册。 上个月再次查看是否可以注册，我几乎不能相信自己的眼睛， 居然可以注册了，欣喜若狂，马上 注册，相隔十年之后，再次拥有了这个域名。 Octopress 之前也在博客园等地方写过博客，一方面因为懒癌产出甚少，另一方面没有归属感。Github Pages流行之 后，我也尝试在Github Pages上写博客了。 比较了几个Github Pages的博客工具之后，迅速被Octopress 的强大，美观吸引了。是的，即使是默认主题，也是十分优美漂亮。 Hexo 作为一个程序员，对各种语言本不该有偏见，但对于Ruby这种语言始终提不起兴趣，甚至到现在还没有看过他 的语法。Octopress基于Ruby, 速度上也一直被诟病。 我对Node.js虽然没有花费太多的力气学习，但 内心深处还是很狂热地热爱着Node.js。Hexo是Node.js开发的, 所以很快就迁移到了Hexo上。 Org-mode 和 Hexo3 自从被子龙山人带入了Emacs邪教，Emacs就侵噬着我心灵的方方面面，到现在已经恨不得所有的事情都在Emacs 里面完成。Org-mode作为Emacs特有的特性，也是必须学习和使用的，自然写博客这种事情， 也必须在Org-mode 下完成。经过几天对比之后，终于选定了org-octopress作为博客写作的框架。尽管org-octopress 是为 Octopress开发的，实际上Hexo和Octopress高度兼容，org-octopress也是可以直接用在Hexo上。在研究 org-octopress的过程中， 也随便将Hexo更新为了3.1.1版本. 迁移 Octopress迁移到Hexo，以及Hexo 2.x迁移到3.x，都是非常简单的. 基本上就是保存好自己的_config.yml 配置文件和source目录， 用新的(比如Hexo3)初始化一个新目录，然后将source目录放入新的目录, 将配置转移到新的_config.yml中即可. 小结 最近为了使用Emacs，耗费了大量的精力来学习Emacs, Spacemacs, Org-mode, GTD等知识，这次对博客 进行了一次升级, 希望能激励自己多些文章， 将最近学习Emacs等心得都分享出来. 本文使用Emacs 24.5, Org-mode 8.2以及org-octopress 完成. Date: 2015-07-25 Validate","categories":[],"tags":[]},{"title":"初识Emacs(一)","slug":"2015-01-11-meet-emacs-01","date":"2015-01-11T04:54:46.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2015/01/11/2015-01-11-meet-emacs-01/","link":"","permalink":"http://www.young40.com/2015/01/11/2015-01-11-meet-emacs-01/","excerpt":"#版本Mac OS X 10.10 中自带的Emacs 版本是22.+, 对于什么版本都求新的我来说, 自然需要祭出Homebrew, 安装最新的版本brew install emacs安装后版本为24.4, ^_^如果你不知掉Homebrew是什么, 参见这里: http://brew.sh/index_zh-cn.html另外, 还有Emacs for OS X可选:http://emacsformacosx.com/","text":"#版本Mac OS X 10.10 中自带的Emacs 版本是22.+, 对于什么版本都求新的我来说, 自然需要祭出Homebrew, 安装最新的版本brew install emacs安装后版本为24.4, ^_^如果你不知掉Homebrew是什么, 参见这里: http://brew.sh/index_zh-cn.html另外, 还有Emacs for OS X可选:http://emacsformacosx.com/ #Meta 键马上就遇到了麻烦.Emacs中比较重要的两个键为Control 和 Meta. 默认Control 键为Ctrl键, 可是我找不到我的Meta键了. 大部分人说Meta 键为Alt键, 试了几遍也不行. 放狗来搜, 原来是要对终端进行设置.设置方法参见:For iTerm2: http://xor.lonnen.com/2013/01/04/emacs-on-osx.html (英文)For Terminal: http://blog.sina.com.cn/s/blog_62b58cd00100z9p0.htmlEmacs for OS X无此问题. 组合键Emacs的教程, 用C-代表了Control的组合键, M- 代表了Meta的组合键 #指南C-h t 可以打开指南, 虽然是英文的, 但是都非常简单. 可以跟着练习. 基础移动f 和 b分别代表forward向前, backward向后 C-f 光标向前移动一个字符C-b 光标向后移动一个字符 M-f 光标向前移动一个单词M-b 光标向后移动一个单词 n 和p分别代表了next line和previous lineC-n 光标下移一行C-p 光标上移一行 e代表了end, a 可能是应为位于字母表的首位, 所以代表了开头C-a 光标移动到行首C-e 光标移动到行末 注意是句子, 不是段落. 支持中文全角标点M-a 光标移动到句子首位M-e 光标移动到句子末尾 小于号, 大于号M-&lt; 光标移动到文件头部M-&gt; 光标移动的文件尾部 当然, 方向键也可以移动光标, 不过强烈不推荐 #打开保存退出C-x C-f 打开文件C-x C-s 保存文件C-x C-c 退出Emacs #小结据说成为Emacs高手需要一年的时间http://blog.csdn.net/redguardtoo/article/details/7222501,但掌握这么多基本上可以在Emacs下面生存下来吧.上面这些都是从Emacs自带的指南摘录下来的, 看看也好, 还是推荐自己跟着指南学一遍.","categories":[{"name":"Emacs","slug":"Emacs","permalink":"http://www.young40.com/categories/Emacs/"}],"tags":[]},{"title":"博客切换到Hexo","slug":"2015-01-11-from-octopress-to-hexo","date":"2015-01-10T20:59:39.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2015/01/11/2015-01-11-from-octopress-to-hexo/","link":"","permalink":"http://www.young40.com/2015/01/11/2015-01-11-from-octopress-to-hexo/","excerpt":"太惭愧了, 过去的一年时间里, 居然没有怎么写博客. 回想起来, 除了恋爱, 结婚, 生子什么事情也没有办成. 谢谢亲爱的陪伴, 上帝赐予我们小生命. 没有你们, 我实在是难以向自己交差. OctoPress 是一个基于Github的伟大的博客系统, 但我在使用的过程中一直觉得不顺手.正巧, 看到了Hexo 这个新兴的博客系统. 尝试了之后, 决定转向Hexo.Hexo以下几点特别吸引我:","text":"太惭愧了, 过去的一年时间里, 居然没有怎么写博客. 回想起来, 除了恋爱, 结婚, 生子什么事情也没有办成. 谢谢亲爱的陪伴, 上帝赐予我们小生命. 没有你们, 我实在是难以向自己交差. OctoPress 是一个基于Github的伟大的博客系统, 但我在使用的过程中一直觉得不顺手.正巧, 看到了Hexo 这个新兴的博客系统. 尝试了之后, 决定转向Hexo.Hexo以下几点特别吸引我: 基于Node.js 我一直是Node.js的脑残粉丝, 再加上OctoPress是基于我所不熟悉的Ruby的 轻量化 兼容OctoPress 等等… 迁移的过程也很简单: 创建空分支git checkout --orphan hexo用上面的命令创建一个空的分支hexo删除目录下的文件, 仅保留git相关文件 创建Hexo环境参见Hexo的文档, 不再赘述http://hexo.io/docs/setup.html可以用hexo server, 在本地看下是否正常正常后将hexo分支推送到你的github pages仓库 迁移依旧是参见Hexo的文档http://hexo.io/docs/migration.html我还迁移了保存图片的目录 发布OctoPress发布在了Github上的master分支, 所以要清除其原有内容. 切换github pages仓库的默认分支为hexo git push origin :master 删除远程master分支 git branch -D master 删除本地master分支 设置发布信息, 发布的branch 为master 测试一下吧hexo deploy","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.young40.com/categories/杂谈/"}],"tags":[]},{"title":"pkgbuild 安装提示成功但找不到App的问题","slug":"2014-06-18-An-Issue-About-pkgbuild-install-location-Changed","date":"2014-06-18T09:53:52.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2014/06/18/2014-06-18-An-Issue-About-pkgbuild-install-location-Changed/","link":"","permalink":"http://www.young40.com/2014/06/18/2014-06-18-An-Issue-About-pkgbuild-install-location-Changed/","excerpt":"这几天用 pkgbuild 来打包 CocoStudio for Mac, 遇到了一个极其诡异的问题. 安装打包好的 CocoStudio.pkg, 有时在/Applications 里面居然找不到 CocoStudio. -_-!!! 打包的参数如下:","text":"这几天用 pkgbuild 来打包 CocoStudio for Mac, 遇到了一个极其诡异的问题. 安装打包好的 CocoStudio.pkg, 有时在/Applications 里面居然找不到 CocoStudio. -_-!!! 打包的参数如下: 12345pkgbuild --root App\\ --component-plist pkgCocoStudio.plist\\ --install-location /Applications\\ --identifier com.ccs.pkg\\ pkgCocoStudio.pkg 其中在 App 目录下有 CocoStudio.app . 在图形界面下安装显示成功, 无奈只有在终端里面调用 installer 安装, 同样显示成功, 有时依然在 /Applications 中找不到 CocoStudio. 没有任何报错, 放狗来搜也没有看到什么有用的信息. 而且pkg打包相关的资料本来就很少. -_-!! 郁闷了几天之后, 测试一直催促我修复这个问题, 可惜总是一筹莫展. 终于要下定决心要解决这个问题. 既然安装成功, 又找不到安装后的App, 那么就来找找到底安装到了什么地方吧.在终端中祭出find / | grep CocoStudio.app 全盘搜索, 好吧, 我知道我这样干很暴力.经过漫长的等待之后, 发现除了上面提到的App 目录下, 并无CocoStudio.app. 这是为什么捏??? ???? 苦思冥想, 不得其解. 突然又想到另外一件莫名其妙的诡异事件.App 目录经常无故被修改成 root 权限, 而安装CocoStudio 确实又调用了 root 权限.难道安装时没有用指定的--install-location /Applications, 而是覆盖到了 App 目录下?????? 既然猜测是覆盖到了 App 下面, 那么马上删除 App, 再次安装, 果真好了. 重新在App 下生成CocoStudio.app, 并且运行一遍, 再次安装. 果真看到 App 下的 CocoStudio.app 被覆盖了. 好吧, 真心给跪了!!!!-_^ PS: 找了一圈也没有发现强制指定路径的方法.","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.young40.com/categories/杂谈/"}],"tags":[{"name":"Mac OS X","slug":"Mac-OS-X","permalink":"http://www.young40.com/tags/Mac-OS-X/"},{"name":"pkgbuild","slug":"pkgbuild","permalink":"http://www.young40.com/tags/pkgbuild/"}]},{"title":"CocosBuilder 多分辨率","slug":"2013-08-01-cocosbuilder-multi-resolution","date":"2013-08-01T14:10:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2013/08/01/2013-08-01-cocosbuilder-multi-resolution/","link":"","permalink":"http://www.young40.com/2013/08/01/2013-08-01-cocosbuilder-multi-resolution/","excerpt":"最近两个项目大量使用了CocosBuilder, 对于开发效率提高是巨大的. 一直计划写一篇博客谈谈CocosBuilder的多分辨率问题, 懒病加上一些疙疙瘩瘩的小事情, 拖延了一个多月, 才终于下定决心要尽快完成这篇博客. 在这篇文章中, 假定你比较熟悉CocosBuilder, 如果您还不是很熟悉CocosBuilder, 推荐您看下我的另外一篇文章. 从零开始学习CocosBuilder 我还是小菜鸟一个, 难免会有很多错误, 还望各位看客不吝赐教. 版本: Cocos2d-x 2.1.4 http://cocos2d-x.googlecode.com/files/cocos2d-x-2.1.4.zip CocosBuilder 3.0alpha5 http://cocosbuilder.googlecode.com/files/CocosBuilder-3.0-alpha5.zip 最近几次Cocos2d-x和CocosBuilder(以下简写为2dx和ccb)都是联合发布的, 使用联合发布的版本会减少不兼容的可能.","text":"最近两个项目大量使用了CocosBuilder, 对于开发效率提高是巨大的. 一直计划写一篇博客谈谈CocosBuilder的多分辨率问题, 懒病加上一些疙疙瘩瘩的小事情, 拖延了一个多月, 才终于下定决心要尽快完成这篇博客. 在这篇文章中, 假定你比较熟悉CocosBuilder, 如果您还不是很熟悉CocosBuilder, 推荐您看下我的另外一篇文章. 从零开始学习CocosBuilder 我还是小菜鸟一个, 难免会有很多错误, 还望各位看客不吝赐教. 版本: Cocos2d-x 2.1.4 http://cocos2d-x.googlecode.com/files/cocos2d-x-2.1.4.zip CocosBuilder 3.0alpha5 http://cocosbuilder.googlecode.com/files/CocosBuilder-3.0-alpha5.zip 最近几次Cocos2d-x和CocosBuilder(以下简写为2dx和ccb)都是联合发布的, 使用联合发布的版本会减少不兼容的可能. ##基本概念 我觉得在多分辨率中重要的概念就是位置, 大小, 节点关系, 可以通过位置, 大小, 节点关系, 锚点等的合理组合, 最终达到理想的界面. 当然, 这需要ccb的使用者更多的思考. ^_- ###位置 我们可以看到ccb中位置共有6种设置. 其中前四种设置方式代表了当前节点相对于其父节点的一个顶点的绝对位置. 如上图所示, 我们把Click me 按钮, 放在了距离其父节点右上角各50px.这种位置的设置方式, 一般在节点需要放在父节点一个角上时很有用. 第5种设置方式表示当前节点的坐标由其父节点大小(宽width, 高height)的百分比组成, 其中父节点的左下角为原点.如上图所示一个节点的父节点大小为200px*100px, 当前节点设置为(70%, 50%),那么当前节点距离其父节点左下角就应该是(140, 50).百分比设置是位置设置中最常用的方式, 只有当百分比设置不适合时才去考虑其他设置方式. 第6种设置方式其实就是第1种设置方式的x,y值分别乘以一个全局缩放系数. 我们接下来就讲这个全局缩放系数, 这里先假设iphone下为1, iphone retina下为2.如上图所示, 当前节点在iphone下距离其父节点左下角(50*1, 50*1), 在iphone retina下则就是(50*2, 50*2). ###全局缩放系数如果我们需要在屏幕上放一个CCLabelTTF, 字体大小设置为48, 分别放在480*320分辨率的iphone上和960*640分辨率的iphone retina上, 那么在iphone retina上显示会显得特别小.这个时候我们就需要为游戏设置一个全局缩放系数, iphone下为1, iphone retina下为2, 那么ccb中设置字体大小为48, 在游戏中iphone上字体大小为48*1=48, iphone retina中字体大小为48*2=96. 你可以在设置位置, 内容大小, 缩放, 字体大小的时候, 找到这个选项. 都是一样的道理, 对应的数据都需要乘以全局缩放系数. 默认iphone(480*320)的全局缩放系数是1, iPad/iphone HD是2, iPad HD就是4了.当然你可以自己设置一套全局缩放系数. ###内容大小 只有如CCLayer, CCNode等几个节点可以设置内容大小. 可以有6个选项. 绝对大小 百分比相对大小, 相对于父节点的大小 相对父节点大小, 宽高设置为(100, 100), 那么该节点比其父节点宽高各小100px. 如果设置为(0, 0), 那么该节点就和父节点一样大小. 宽度百分比, 高度绝对大小. 宽度绝对大小, 高度百分比. 绝对大小, 会被乘以全局缩放系数. ##基本操作 ###多分辨率的文档 从菜单中选择Edit Resolutions..., 打开编辑多分辨率对话框. 我们可以看到当前为iphone设置了(480*320)的分辨率, Scale这个选项就是我们上面提到的全局缩放系数, 值为1.为iPad设置了(1024*768)的分辨率, 全局缩放系数为2. 我们可以点击Add Predefined Resolution, 来添加ccb预定义的分辨率. 比如添加一个iphone5的分辨率.哦, 什么, 分辨率是568*320???? 需要注意的是，CocosBuilder的工作是基于点（Point）的，而不是像素的。. ####Resolution Extension和resources-auto(插播)ccb中有一个resources-auto的重要概念, 你可以只提供一套资源, ccb通过全局缩放系数, 来为你自动生成不同分辨率的图片.假设你为iPad retina(全局缩放系数为4)设计了一张100*100的图片.那么iphone会得到一张25*25的图片. iPad/iphone HD会得到一张50*50的图片. 说到资源解决方案, 首先要决定你想要支持的最大分辨率. 假设需要完美支持iPad HD, 就按2048*1536来做资源, 此时全局缩放系数为4.把图片资源放置到resources-auto目录下, 那么ccb会帮我们自动缩放出其他需要的分辨率.嗯, 还需要像下图一样设置, 告诉ccb需要从4x来设置. 从菜单的Publish Settings...打开. 如果是和背景无关的图片, 一般来讲自动缩放就可以胜任了. 如果需要在不同的分辨率下使用不同的图片, 比如一张背景图, iphone上使用960*640的图片, iPad上使用一张1024*768的图片.那么可以在资源目录创建resources-iphone, resources-ipad目录, 然后在resources-iphone放置一张960*640分辨率的图片demo.png, 在resources-ipad目录下放置一张1024*768分辨率的图片demo.png. 要注意需要保持其文件名相同. 我们在ccb的工程目录下仍然只看到了一份demo.png, 不要着急, ccb会根据我们选用的不同的分辨率来给我们呈现不同的图片. ok, 插播结束. 继续说我们的多分辨率文档. 其实, 我们可以给文档添加一个iphone hd, 以及正常iphone5尺寸的文档. 比较遗憾的是ccb不支持编辑Resolution Extension的列表.而ipad和iphonehd的设置是在一起的, 并且也没有iphone5的Resolution可以设置.所以我希望你没有需要必须要区分iphonehd/iphone5的需求, 在ccb里面是无法区分的. 令人欣慰的是, 我们还是可以在游戏里面区分他们.-_= 给文档添加的分辨率是可以自定义的, 名字, 宽, 高, 全局缩放系数. 所以我们还是可以创建全尺寸的iphonehd/iphone5的分辨率. 然后, 我们可以在ccb的菜单中找到切换多分辨率的选项, 这样就可以很方便的预览在各个分辨率下的效果.注意他们的快捷键哦, 很有用哦.推荐在使用的时候, 经常在几个分辨率下切换查看效果是否正确理想. ##做一个ccb工程是时候做一个ccb的工程了, 不过我有点羞涩要给你展示我做的工程. 因为它实在太丑了, 还是来一张截图吧, 希望没有吓到你.-_= ##代码一下由于上面提到的一些限制, 只能基本上做到在ccb中做的, 就是我们在游戏中看到的. ccb自带的帮助中Setting scale and design size, 需要做一些改进. 下面是我的代码. AppDelegate.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//set the correct resource for CocosBuilder &#123; CCSize sizeIphone = CCSizeMake(480, 320); CCSize sizeIphoneHD = CCSizeMake(960, 640); CCSize sizeIphone5 = CCSizeMake(1136, 640); CCSize sizeIpad = CCSizeMake(1024, 768); CCSize sizeIpadHD = CCSizeMake(2048, 1536); CCSize designSize = sizeIphoneHD; CCSize resourceSize = sizeIphoneHD; CCSize screenSize = CCEGLView::sharedOpenGLView()-&gt;getFrameSize(); std::vector&lt;std::string&gt; searchPaths; std::vector&lt;std::string&gt; resDirOrders; TargetPlatform platform = CCApplication::sharedApplication()-&gt;getTargetPlatform(); if (platform == kTargetIphone || platform == kTargetIpad) &#123; CCFileUtils::sharedFileUtils()-&gt;setSearchPaths(searchPaths); if (screenSize.width &gt; 768) &#123; resourceSize = sizeIpadHD; designSize = sizeIpadHD; resDirOrders.push_back(\"resources-ipadhd\"); CCBReader::setResolutionScale(4.0f); &#125; else if (screenSize.width &gt; 640) &#123; resourceSize = sizeIpad; designSize = resourceSize; resDirOrders.push_back(\"resources-ipad\"); resDirOrders.push_back(\"resources-iphonehd\"); CCBReader::setResolutionScale(2.0f); &#125; else if (screenSize.width &gt; 480) &#123; if (screenSize.height &gt; 960) &#123; designSize = sizeIphone5; &#125; else &#123; designSize = sizeIphoneHD; &#125; resourceSize = sizeIphoneHD; CCBReader::setResolutionScale(2.0f); resDirOrders.push_back(\"resources-iphonehd\"); &#125; else &#123; CCBReader::setResolutionScale(1.0f); designSize = sizeIphone; resourceSize = sizeIphone; resDirOrders.push_back(\"resources-iphone\"); &#125; CCFileUtils::sharedFileUtils()-&gt;setSearchResolutionsOrder(resDirOrders); &#125; pDirector-&gt;setContentScaleFactor(resourceSize.width / designSize.width); CCEGLView::sharedOpenGLView()-&gt;setDesignResolutionSize( designSize.width, designSize.height, kResolutionExactFit); &#125; CCNodeLoaderLibrary *lib = CCNodeLoaderLibrary::newDefaultCCNodeLoaderLibrary(); CCBReader *reader = new CCBReader(lib); CCScene *scene = reader-&gt;createSceneWithNodeGraphFromFile(\"MainScene.ccbi\"); pDirector-&gt;runWithScene(scene); 这里只支持了iOS, 如果需要支持Android的话, 可以挑选几个需要的分辨率, 邻近的分辨率坐下拉伸等策略. 运行下代码, 可以看下效果. 收工. 工程下载: http://pan.baidu.com/share/link?shareid=3612867199&amp;uk=2281999082 推荐看下bilt的两篇博客: http://blog.justbilt.com/569/ http://blog.justbilt.com/579/ 里面还罗列了数片前辈们关于多分辨率的文章, 我学习的过程中也受益匪浅.一并致谢.","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"http://www.young40.com/categories/Cocos2d-x/"},{"name":"CocosBuilder","slug":"Cocos2d-x/CocosBuilder","permalink":"http://www.young40.com/categories/Cocos2d-x/CocosBuilder/"}],"tags":[]},{"title":"搭建Mac OS X下cocos2d-x的Android开发环境","slug":"2013-02-23-setting-up-android-development-envirment-on-mac-os-x","date":"2013-02-23T13:14:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2013/02/23/2013-02-23-setting-up-android-development-envirment-on-mac-os-x/","link":"","permalink":"http://www.young40.com/2013/02/23/2013-02-23-setting-up-android-development-envirment-on-mac-os-x/","excerpt":"##版本 Cocos2d-x: cocos2d-2.1beta3-x-2.1.1 OS X: 10.8 Android ADT Bundle: v21.1.0 Android NDK: android-ndk-r8d Device: Android 4.2.1这次我们测试的设备安装的是Android4.2.1, Cocos2d-x能支持Android2.2以上版本. ####文件路径:","text":"##版本 Cocos2d-x: cocos2d-2.1beta3-x-2.1.1 OS X: 10.8 Android ADT Bundle: v21.1.0 Android NDK: android-ndk-r8d Device: Android 4.2.1这次我们测试的设备安装的是Android4.2.1, Cocos2d-x能支持Android2.2以上版本. ####文件路径: Cocos2d-x: /opt/cocos2d-2.1beta3-x-2.1.1 Android ADT Bundle: /opt/adt-bundle-mac-x86_64 Android NDK: /opt/android-ndk下文中提及的这些路径, 请替换成您自己的路径 ##下载最新版本Cocos2d-x您可以在Cocos2d-x官网找到下载页面解压后到您需要的位置, 本文假设解压到以下位置1/opt/cocos2d-2.1beta3-x-2.1.1 ##检查JDK在终端中输入1java -version 如果您没有安装JDK, 系统会帮您自动安装JDK.安装过后您会看到如下输出123java version \"1.6.0_37\"Java(TM) SE Runtime Environment (build 1.6.0_37-b06-434-11M3909)Java HotSpot(TM) 64-Bit Server VM (build 20.12-b01-434, mixed mode) ##下载最新版本Android ADT BundleGoogle将Android SDK, Eclipse, ADT(Android Developer Tools)打包在一起,称作Android ADT Bundle, 简化了Android开发环境的搭建.您可以在Android官网找到下载页面解压到您需要的位置, 本文假设解压到以下位置1/opt/adt-bundle-mac-x86_64 在终端中运行下面命令, 将ADT中的Eclipse放入您的程序文件夹, 方便启动1ln -s /opt/adt-bundle-mac-x86_64/eclipse/Eclipse.app/ /Applications/Eclipse-ADT.app 在/Applications中或者Launchpad中找到并打开Eclipse-ADT ##Eclipse的Retina支持如果您在使用带Retina的Mackbook Pro, Eclipse暂时还不支持Retina. 但有一个简单的解决方案 在 /opt/adt-bundle-mac-x86_64/eclipse 找到 Eclipse.app 编辑Contents/Info.plist 找到12&lt;/dict&gt;&lt;/plist&gt; 在其上面添加12&lt;key&gt;NSHighResolutionCapable&lt;/key&gt;&lt;true/&gt; 将Eclipse.app移动到新的文件夹, 然后再移动回来. (防止系统缓存了上面提及的Info.plist) OK啦. ##Android SDK ManagerAndroid ADT Bundle中是包含了Android SDK Manager的. 启动您的Eclipse-ADT. 可以在工具栏中或者菜单中找到Android SDK Manager. ##Android NDK您可以在Android官网找到Android的下载页面下载后解压到您需要的位置, 本文假设解压到以下位置1/opt/android-ndk ##设置环境变量我们需要将SDK, NDK以及Cocos2d-x的路径中添加到环境变量中. 将以下内容添加到~/.bash_profile文件123456export COCOS2DX_ROOT=/opt/cocos2d-2.1beta3-x-2.1.1export ANDROID_SDK_ROOT=/opt/adt-bundle-mac-x86_64/sdkexport ANDROID_NDK_ROOT=/opt/android-ndkexport NDK_ROOT=/opt/android-ndkexport PATH=$PATH:$ANDROID_NDK_ROOTexport PATH=$PATH:$ANDROID_SDK_ROOT ##HelloWorld万事俱备, 我们现在就可以开始激动人心的Cocos2d-x之旅了.打开终端, 进入cocos2d-x所在目录并执行 /opt/cocos2d-2.1beta3-x-2.1.1/create-android-project.sh文件根据提示输入对应信息.1234567891011121314151617181920212223242526272829Youngs-MacBook-Air:~ young40$ cd /opt/cocos2d-2.1beta3-x-2.1.1/Youngs-MacBook-Air:cocos2d-2.1beta3-x-2.1.1 young40$ ./create-android-project.sh use global definition of NDK_ROOT: /opt/android-ndkuse global definition of ANDROID_SDK_ROOT: /opt/adt-bundle-mac-x86_64/sdkInput package path. For example: org.cocos2dx.examplecom.young40.test //这里输入了包名Now cocos2d-x supports Android 2.2 or upper versionAvailable Android targets:----------id: 1 or \"android-17\" Name: Android 4.2 Type: Platform API level: 17 Revision: 1 Skins: HVGA, QVGA, WQVGA400, WQVGA432, WSVGA, WVGA800 (default), WVGA854, WXGA720, WXGA800, WXGA800-7in ABIs : armeabi-v7ainput target id:1 //选择您需要的平台idinput your project name:HelloWorld //输入项目名称Created project directory: /opt/cocos2d-2.1beta3-x-2.1.1/HelloWorld/proj.android.....Updated project.propertiesUpdated local.propertiesUpdated file /opt/cocos2d-2.1beta3-x-2.1.1/HelloWorld/proj.android/proguard-project.txtYoungs-MacBook-Air:cocos2d-2.1beta3-x-2.1.1 young40$ 从以上输出我们可以看到create-android-project.sh这个脚本帮我们在 /opt/cocos2d-2.1beta3-x-2.1.1/HelloWorld 下建立了新项目. 然后我们可以先在终端中调用”build_native.sh”脚本编译该项目的C++部分.1234567891011121314151617Youngs-MacBook-Air:~ young40$ cd /opt/cocos2d-2.1beta3-x-2.1.1/HelloWorld/proj.android/Youngs-MacBook-Air:proj.android young40$ ./build_native.sh NDK_ROOT = /opt/android-ndkCOCOS2DX_ROOT = /opt/cocos2d-2.1beta3-x-2.1.1/HelloWorld/proj.android/../..APP_ROOT = /opt/cocos2d-2.1beta3-x-2.1.1/HelloWorld/proj.android/..APP_ANDROID_ROOT = /opt/cocos2d-2.1beta3-x-2.1.1/HelloWorld/proj.androidUsing prebuilt externalsmake: Entering directory `/opt/cocos2d-2.1beta3-x-2.1.1/HelloWorld/proj.android'.....StaticLibrary : libchipmunk.aStaticLibrary : libextension.aSharedLibrary : libgame.soInstall : libgame.so =&gt; libs/armeabi/libgame.somake: Leaving directory `/opt/cocos2d-2.1beta3-x-2.1.1/HelloWorld/proj.android'Youngs-MacBook-Air:proj.android young40$ ##导入Eclipse-ADT打开Eclipse-ADT, 点击快捷键command+N打开新建项目窗口并选择Android Project from Existing Code这时您可能会在eclipse的Problems窗口看到如下错误123The import org.cocos2dx.lib cannot be resolved HelloWorld.java /HelloWorld/src/com/young40/test line 26 Java ProblemCocos2dxActivity cannot be resolved to a type HelloWorld.java /HelloWorld/src/com/young40/test line 30 Java ProblemCocos2dxActivity cannot be resolved to a type HelloWorld.java /HelloWorld/src/com/young40/test line 33 Java Problem 您需要将/opt/cocos2d-2.1beta3-x-2.1.1/cocos2dx/platform/android/java如上面处理一样也作为一个项目导入eclipse中然后在HelloWorld项目上点击右键选择刷新, 可以看到错误就消失了. 将您的手机设置成调试模式并用USB线连接到电脑, 在Eclipse中运行HelloWorld, 然后就能在手机上看到已经运行的HelloWorld了 好了, 享受您的奇妙的Cocos2d-x之旅吧!","categories":[],"tags":[]},{"title":"基于Pomelo和Cocos2d-x的聊天室","slug":"2013-01-08-chat-of-pomelo-for-cocos2d-x","date":"2013-01-07T16:39:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2013/01/08/2013-01-08-chat-of-pomelo-for-cocos2d-x/","link":"","permalink":"http://www.young40.com/2013/01/08/2013-01-08-chat-of-pomelo-for-cocos2d-x/","excerpt":"据说聊天室和游戏系统有很多相似之处, 并且很多游戏本身就带着多人聊天系统. 所以Pomelo将聊天室作为了一个例子. 开源是非常棒的思想和运动, 我简单提两点体会,1.发现了问题可以不用等官方响应,自己有能力就可以马上修复. 2.你可以贡献自己的代码,很多人都可以贡献代码,可以让项目快速发展.当然一旦你的代码被接受并被很多人使用, 心中的成就感是不言而喻的. 之所以要提到开源, 是因为今天我们要用到的东西基本上全部是开源的, 并且我们还要对其中的代码做一些修改才能正常工作. 再一次为开源鼓掌! 这并不是一篇Pomelo,或者Cocos2d-x的入门说明, 需要你对这两者都有一定的了解.同时, 无论是Pomelo还是Cocos2d-x, 我都是新手, 如果文章中有错误的地方, 希望您能不吝指出.您可以在文章下面留言, 或者在新浪微博上发微薄 @杨世玲(需要说明的一点是, 请勿私信提问非隐私性技术问题, 我是希望您的问题, 我的或者其他朋友的回复,能被更多朋友搜索到,我希望我们的交流, 能让更多朋友受到启发, 受益. 这也是对社区和世界和平的一点贡献吧.)","text":"据说聊天室和游戏系统有很多相似之处, 并且很多游戏本身就带着多人聊天系统. 所以Pomelo将聊天室作为了一个例子. 开源是非常棒的思想和运动, 我简单提两点体会,1.发现了问题可以不用等官方响应,自己有能力就可以马上修复. 2.你可以贡献自己的代码,很多人都可以贡献代码,可以让项目快速发展.当然一旦你的代码被接受并被很多人使用, 心中的成就感是不言而喻的. 之所以要提到开源, 是因为今天我们要用到的东西基本上全部是开源的, 并且我们还要对其中的代码做一些修改才能正常工作. 再一次为开源鼓掌! 这并不是一篇Pomelo,或者Cocos2d-x的入门说明, 需要你对这两者都有一定的了解.同时, 无论是Pomelo还是Cocos2d-x, 我都是新手, 如果文章中有错误的地方, 希望您能不吝指出.您可以在文章下面留言, 或者在新浪微博上发微薄 @杨世玲(需要说明的一点是, 请勿私信提问非隐私性技术问题, 我是希望您的问题, 我的或者其他朋友的回复,能被更多朋友搜索到,我希望我们的交流, 能让更多朋友受到启发, 受益. 这也是对社区和世界和平的一点贡献吧.) 下面是我们需要使用到的工具及其版本: 平台:OS X(10.8.2) Xcode(4.5.2) Cocos2d-2.1beta3-x-2.1.0 Pomelo https://github.com/NetEase/pomelo socket.io-clientpp https://github.com/ebshimizu/socket.io-clientpp websocketpp https://github.com/zaphoyd/websocketpp Rapidjson https://code.google.com/p/rapidjson/ chatofpomelo https://github.com/NetEase/chatofpomelo 查阅本文时请注意版本差异. 环境配置我们的目标是实现OS X, IOS, Android三个平台下的chatofpomelo的Cocos2d-x版本.所以需要安装各自平台的开发工具如Xcode,Eclipse,NDK等, 不是本文需要关心的内容. 相信大家也已经轻车熟路了.Pomelo的安装 npm install pomelo -g, 如有疑问请查看Pomelo的Wiki.websocketpp需要著名的C++库, boost. 我是使用了HomeBrew来安装.其他安装方式请自省查阅相关文档, 有一点需要指出的是, 必须编译为带有x86(i386)支持lib文件.因为Cocos2d-x在OS X下是32位的.HomeBrew安装boost库1brew install boost --universal 上面这条命令中--universal即代表编译出来的boost的lib文件同时支持x86和x64. 项目配置Cocos2d-x跨平台无疑做的很好, 但是如果手动创建一个结构良好的跨平台项目,还是一件非常棘手的事.幸好我们可以偷懒, 打开Cocos2d-x的源代码, samples目录下面都是已经配置好的跨平台的项目文件.合理利用, 将事半功倍. 我们将samples目录下HelloCpp复制为ChatOfPomelo,打开找到proj.mac目录下面的HelloCpp.xcodeproj,可以将其重命名为ChatOfPomelo-Mac.xcodeproj, 以便于和接下来的ios项目有所区分. 在ChatOfPomelo下创建lib目录, 下载socket.io-clientpp和websocketpp并解压到lib目录下面.并将socket.io-clientpp/lib/rapidjson 复制到lib目录下面.目录结构应该是这样的.目录1234567891011121314ChatOfPomelo/├── Classes├── Resources├── lib│ ├── rapidjson│ ├── socket.io-clientpp│ └── websocketpp├── proj.android├── proj.blackberry├── proj.ios├── proj.linux├── proj.mac├── proj.marmalade└── proj.win32 我们打开proj.mac下的项目文件, 在Xcode中打开项目设置页, 点开Targets的设置.在Build Settings下面找到Search Paths, 将Always Search User Paths设置为Yes.给Header Search Paths 依次添加下面路径:1234/usr/local/include_code\"$(SRCROOT)/../lib/socket.io-clientpp/src\"\"$(SRCROOT)/../lib/websocketpp/src\"\"$(SRCROOT)/../lib/rapidjson/include\" 如下图所示: 给Library Search Paths添加路径/usr/local/lib. 如下图: 其中/usr/local/include和/usr/local/lib是boost的所在位置(HomeBrew的默认安装位置).如果你的boost不在上述位置, 请自行更改. 接下来将websocketpp的工程文件添加进来.参见下图: 然后打开工程的设置, 在Targets的Build Phases页面,找到Link Binary With Libraries,添加libwebsocketpp.a, 以及boost的库文件(在/usr/local/lib中找到).boost 需要添加的库文件列表1234567libboost_date_time-mt.alibboost_graph-mt.alibboost_random-mt.alibboost_regex-mt.alibboost_system-mt.alibboost_thread-mt.alibboost_timer-mt.a 添加的方法参见下图: ##文件Hack我们在HelloWorldScene.cpp中添加一句#include &lt;socket_io_client.hpp&gt;.然后试图运行项目的话, 会看到几处报错(有可能你看到这篇文章的时候相关库文件已经更新了, 没有报错的话, 直接跳过这段即可.)报错的是socket_io_client.hpp中的std::function以及std::unique_ptr等. 这是因为这些语句是C++11的新语法. 而如果在Xcode中启用C++11的支持,则Cocos2d-x无法通过编译.原因有人说是Cocos2d-x不支持C++11, 有人说是OS X自带的libc++库太旧的原因, Xcode4.6中会更新该库.我是小菜鸟一只, 也分不清谁说的对. 但我们可以通过修改这些代码, 采用boost的API来完成相应的工作.而websocketpp这个项目又大量采用了boost, 所以修改为boost的API还是挺划算的. 找到socket_io_client.hpp:socket_io_client.hpp1234567//typedef std::function&lt;void (socketio_events&amp;, const Value&amp;)&gt; eventFunc;//修改为typedef boost::function&lt;void (socketio_events&amp;, const Value&amp;)&gt; eventFunc;//std::unique_ptr&lt;boost::asio::deadline_timer&gt; m_heartbeatTimer;//修改为boost::shared_ptr&lt;boost::asio::deadline_timer&gt; m_heartbeatTimer; 找到socket_io_client.cpp:socket_io_client.cpp123//m_heartbeatTimer = std::unique_ptr&lt;boost::asio::deadline_timer&gt;(new boost::asio::deadline_timer(con-&gt;get_io_service(), boost::posix_time::seconds(0)));//修改为m_heartbeatTimer = boost::shared_ptr&lt;boost::asio::deadline_timer&gt;(new boost::asio::deadline_timer(con-&gt;get_io_service(), boost::posix_time::seconds(0))); 打开lib/rapidjson/include/rapidjson/document.h:document.h1234//if (reader.Parse&lt;parseFlags&gt;(is, *this)) &#123;修改为if (reader.template Parse&lt;parseFlags&gt;(is, *this)) &#123;\"//这个是jsoncpp的一个bug, 新版本里面已经修复, 但socket_io_client绑定了旧版本, 暂未升级. 这是整个项目应该就可以正常编译运行了. 如果没能正常运行, 你可能在某一步出错了,可以在下面评论分享下你的问题, 如果已经找到解决办法, 也要把解决方法也贴出来, 分享给大家哦, 亲! //将socket_io_client, websocketpp的cpp文件引入到项目.","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"http://www.young40.com/categories/Cocos2d-x/"}],"tags":[]},{"title":"2d-x深读4:CCAutoReleasePool","slug":"2013-01-03-cocos2d-x-source-code-research-4-ccautoreleasepool","date":"2013-01-03T07:09:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2013/01/03/2013-01-03-cocos2d-x-source-code-research-4-ccautoreleasepool/","link":"","permalink":"http://www.young40.com/2013/01/03/2013-01-03-cocos2d-x-source-code-research-4-ccautoreleasepool/","excerpt":"CCAutoReleasePool.h主要定义了两个类CCAutoReleasePool和CCPoolManager. 其实因为cocos2d-x自动管理内存的原因, 所以, 我们平时很少需要直接使用这两个类.为了探究其中的自动管理内存的机制, 我们直接分析其代码. 总体上来讲, 内存管理这块的机制难度或许比较大. 我研究了一天, 还是有诸多疑问.暂时先放一放, 待我功力进化后再来继续研究这块.","text":"CCAutoReleasePool.h主要定义了两个类CCAutoReleasePool和CCPoolManager. 其实因为cocos2d-x自动管理内存的原因, 所以, 我们平时很少需要直接使用这两个类.为了探究其中的自动管理内存的机制, 我们直接分析其代码. 总体上来讲, 内存管理这块的机制难度或许比较大. 我研究了一天, 还是有诸多疑问.暂时先放一放, 待我功力进化后再来继续研究这块. 版本:cocos2d-2.1beta3-x-2.1.0 路径:cocos2d-2.1beta3-x-2.1.0/cocos2dx/cocoa/CCAutoReleasePool.h 路径:cocos2d-2.1beta3-x-2.1.0/cocos2dx/cocoa/CCAutoReleasePool.cpp CCAutoReleasePool\\.hview raw1234567891011121314151617181920212223242526272829303132333435// 声明CCAutoreleasePool类class CC_DLL CCAutoreleasePool : public CCObject{//注意这个m_pCurReleasePool是一个私有成员. 居然没有加标号. CCArray* m_pManagedObjectArray; public: CCAutoreleasePool(void); ~CCAutoreleasePool(void); void addObject(CCObject *pObject); void removeObject(CCObject *pObject); void clear();};class CC_DLL CCPoolManager{//下面这三个成员变量依然是私有的. CCArray* m_pReleasePoolStack; CCAutoreleasePool* m_pCurReleasePool; CCAutoreleasePool* getCurReleasePool();public: CCPoolManager(); ~CCPoolManager(); void finalize(); void push(); void pop(); void removeObject(CCObject* pObject); void addObject(CCObject* pObject); static CCPoolManager* sharedPoolManager(); static void purgePoolManager(); //友元 friend class CCAutoreleasePool;}; CCAutoReleasePool\\.cppview raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171static CCPoolManager* s_pPoolManager = NULL;// 用作单例模式的静态变量.CCAutoreleasePool::CCAutoreleasePool(void){ m_pManagedObjectArray = new CCArray(); m_pManagedObjectArray-&gt;init();}CCAutoreleasePool::~CCAutoreleasePool(void){ CC_SAFE_DELETE(m_pManagedObjectArray);}void CCAutoreleasePool::addObject(CCObject* pObject){ m_pManagedObjectArray-&gt;addObject(pObject); // CCAutoreleasePool是CCObject的友元类, 可以直接访问CCObject的protect成员变量. CCAssert(pObject-&gt;m_uReference &gt; 1, \"reference count should be greater than 1\"); ++(pObject-&gt;m_uAutoReleaseCount); pObject-&gt;release(); // no ref count, in this case autorelease pool added.}// 下面这个遍历似乎是为了应对被多次加入poolvoid CCAutoreleasePool::removeObject(CCObject* pObject){ for (unsigned int i = 0; i &lt; pObject-&gt;m_uAutoReleaseCount; ++i) { m_pManagedObjectArray-&gt;removeObject(pObject, false); }}// 清空池void CCAutoreleasePool::clear(){ if(m_pManagedObjectArray-&gt;count() &gt; 0) { //CCAutoreleasePool* pReleasePool;#ifdef _DEBUG int nIndex = m_pManagedObjectArray-&gt;count() - 1;#endif CCObject* pObj = NULL; CCARRAY_FOREACH_REVERSE(m_pManagedObjectArray, pObj)//反序遍历 { // 这里还是令人费解, 为何会使用break, 而不是使用continue完成遍历???? if(!pObj) break; --(pObj-&gt;m_uAutoReleaseCount); //(*it)-&gt;release(); //delete (*it);#ifdef _DEBUG nIndex--;#endif } m_pManagedObjectArray-&gt;removeAllObjects(); }}// CCPoolManager的单例CCPoolManager* CCPoolManager::sharedPoolManager(){ if (s_pPoolManager == NULL) { s_pPoolManager = new CCPoolManager(); } return s_pPoolManager;}// 销毁当前managervoid CCPoolManager::purgePoolManager(){ CC_SAFE_DELETE(s_pPoolManager);}//构造函数CCPoolManager::CCPoolManager(){ m_pReleasePoolStack = new CCArray(); m_pReleasePoolStack-&gt;init(); m_pCurReleasePool = 0;}// 析构函数CCPoolManager::~CCPoolManager(){ finalize(); // 这个注释也让人费解. 为什么只移除第一个, 而不是遍历???? // we only release the last autorelease pool here m_pCurReleasePool = 0; m_pReleasePoolStack-&gt;removeObjectAtIndex(0); CC_SAFE_DELETE(m_pReleasePoolStack);}void CCPoolManager::finalize(){ if(m_pReleasePoolStack-&gt;count() &gt; 0) { //CCAutoreleasePool* pReleasePool; CCObject* pObj = NULL; CCARRAY_FOREACH(m_pReleasePoolStack, pObj) { // 这里有点令人不解, 为什么遍历还没有完成就break了??? // 或许是因为pop push的方式不会在中间产生为NULL的池. if(!pObj) break; CCAutoreleasePool* pPool = (CCAutoreleasePool*)pObj; pPool-&gt;clear(); } }}//创建一个新池, 注意其中pPool的引用计数的变化.void CCPoolManager::push(){ CCAutoreleasePool* pPool = new CCAutoreleasePool(); //ref = 1 m_pCurReleasePool = pPool; m_pReleasePoolStack-&gt;addObject(pPool); //ref = 2 pPool-&gt;release(); //ref = 1}//销毁当前池void CCPoolManager::pop(){ if (! m_pCurReleasePool) { return; } int nCount = m_pReleasePoolStack-&gt;count(); m_pCurReleasePool-&gt;clear(); if(nCount &gt; 1) {//注意这里removeObjectAtIndex会将当前池的引用技术减1, 从而销毁当前池. m_pReleasePoolStack-&gt;removeObjectAtIndex(nCount-1);// if(nCount &gt; 1)// {// m_pCurReleasePool = m_pReleasePoolStack-&gt;objectAtIndex(nCount - 2);// return;// } m_pCurReleasePool = (CCAutoreleasePool*)m_pReleasePoolStack-&gt;objectAtIndex(nCount - 2); }//如果没有意外, 这里会最少保留一个池不会被销毁. 但最后一个池还是会被清空.. /*m_pCurReleasePool = NULL;*/}// 从当前池中移除对象.void CCPoolManager::removeObject(CCObject* pObject){ CCAssert(m_pCurReleasePool, \"current auto release pool should not be null\"); m_pCurReleasePool-&gt;removeObject(pObject);}//添加一个对象到当前池void CCPoolManager::addObject(CCObject* pObject){ getCurReleasePool()-&gt;addObject(pObject);}//形成单例模式CCAutoreleasePool* CCPoolManager::getCurReleasePool(){ if(!m_pCurReleasePool) { push(); } CCAssert(m_pCurReleasePool, \"current auto release pool should not be null\"); return m_pCurReleasePool;} 参考1: http://4137613.blog.51cto.com/4127613/784134","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"http://www.young40.com/categories/Cocos2d-x/"},{"name":"Cocos2d-x 源代码研究","slug":"Cocos2d-x/Cocos2d-x-源代码研究","permalink":"http://www.young40.com/categories/Cocos2d-x/Cocos2d-x-源代码研究/"}],"tags":[]},{"title":"2d-x深读3:CCObject","slug":"2012-12-31-cocos2d-x-source-code-research-3-ccobject","date":"2012-12-31T09:21:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2012/12/31/2012-12-31-cocos2d-x-source-code-research-3-ccobject/","link":"","permalink":"http://www.young40.com/2012/12/31/2012-12-31-cocos2d-x-source-code-research-3-ccobject/","excerpt":"CCObject是绝大部分cocos2d-x类的基类, 我们就从这里一步一步揭开cocos2d-x的奥秘. CCObject承担了两个重要的功能, 拷贝机制和内存管理. ##拷贝机制打开CCObject.h 首先看到的是类CCCopying, 而CCObject是从该类派生. 从这个意义上来讲CCCopying才是大部分类的基类.但CCCopying其实非常简单, 再加上没有其他类从CCCopying派生, 所以说CCObject才是大部分类的基类也是不错的. 我认为CCCopying仅仅是一个接口性质. CCCopying这个类非常简单, 只有一个成员函数copyWithZone(CCZone *pZone); 简单到其实现只是为了报错. 尽管如此, 但其却承担了拷贝机制这一重要的功能. cocos2d-x和cocos2d-iphone是近亲, 所以cocos2d-x在API上会和cocos2d-iphone保持一致, 代码上也多有借鉴. CCObject明显就有很多NSObject的痕迹.当然我对Objective-c并不熟悉, 这里都是些猜测罢了. copyWithZone或许就是借鉴了Obj-c. 我们先来看下拷贝机制, 至于CCObject的代码倒不忙着看.","text":"CCObject是绝大部分cocos2d-x类的基类, 我们就从这里一步一步揭开cocos2d-x的奥秘. CCObject承担了两个重要的功能, 拷贝机制和内存管理. ##拷贝机制打开CCObject.h 首先看到的是类CCCopying, 而CCObject是从该类派生. 从这个意义上来讲CCCopying才是大部分类的基类.但CCCopying其实非常简单, 再加上没有其他类从CCCopying派生, 所以说CCObject才是大部分类的基类也是不错的. 我认为CCCopying仅仅是一个接口性质. CCCopying这个类非常简单, 只有一个成员函数copyWithZone(CCZone *pZone); 简单到其实现只是为了报错. 尽管如此, 但其却承担了拷贝机制这一重要的功能. cocos2d-x和cocos2d-iphone是近亲, 所以cocos2d-x在API上会和cocos2d-iphone保持一致, 代码上也多有借鉴. CCObject明显就有很多NSObject的痕迹.当然我对Objective-c并不熟悉, 这里都是些猜测罢了. copyWithZone或许就是借鉴了Obj-c. 我们先来看下拷贝机制, 至于CCObject的代码倒不忙着看. 这两段代码来至于类CCArray, 我们可以看到调用了原对象的copy()来拷贝一份新的CCArray.而copy()则定义于CCObject中, 其工作就是调用copyWithZone. CCArray1234567891011121314151617181920212223CCArray* CCArray::createWithArray(CCArray* otherArray)&#123; CCArray* pRet = (CCArray*)otherArray-&gt;copy(); pRet-&gt;autorelease(); return pRet;&#125;/////----------////CCObject* CCArray::copyWithZone(CCZone* pZone)&#123; CCAssert(pZone == NULL, \"CCArray should not be inherited.\"); CCArray* pArray = new CCArray(); pArray-&gt;initWithCapacity(this-&gt;data-&gt;num &gt; 0 ? this-&gt;data-&gt;num : 1); CCObject* pObj = NULL; CCObject* pTmpObj = NULL; CCARRAY_FOREACH(this, pObj) &#123; pTmpObj = pObj-&gt;copy(); pArray-&gt;addObject(pTmpObj); pTmpObj-&gt;release(); &#125; return pArray;&#125; 这里面牵涉到两个概念, 深拷贝和浅拷贝. 不清楚的大家可以搜索下, 简而言之, 深拷贝才真正的完全拷贝. cocos2d-x实现的是深拷贝.我们在上面CCArray::copyWithZone中可以看到拷贝时对array的各个成员也执行了copy()的动作.这样才能防止如果obj2是obj1的浅拷贝, 很容易出现array的元素有可能被过早释放的情况. 这里我们还可以一并说下CCZone这个类, 这个类也很简单, 只有一个构造函数和成员变量.CCZone12345678class CC_DLL CCZone&#123;public: CCZone(CCObject *pObject = NULL);public: CCObject *m_pCopyObject;&#125;; 我想CCZone存在的目的就是为了调用copyWithZone的时候对象传递方便.比如我们还可以看下CCSpeed的copyWithZone函数.CCSpeed1234567891011121314151617181920CCObject *CCSpeed::copyWithZone(CCZone *pZone)&#123; CCZone* pNewZone = NULL; CCSpeed* pRet = NULL; if(pZone &amp;&amp; pZone-&gt;m_pCopyObject) //in case of being called at sub class &#123; pRet = (CCSpeed*)(pZone-&gt;m_pCopyObject); &#125; else &#123; pRet = new CCSpeed(); pZone = pNewZone = new CCZone(pRet); &#125; CCAction::copyWithZone(pZone); pRet-&gt;initWithAction( (CCActionInterval*)(m_pInnerAction-&gt;copy()-&gt;autorelease()) , m_fSpeed ); CC_SAFE_DELETE(pNewZone); return pRet;&#125; 我们可以看到构建了一个pZone, 然后调用父类的CCAction::copyWithZone(pZone);.完全是为了copyWithZone方便传递变量而创建的. 拷贝机制看起来有点复杂, 但其实用起来很简单. 我觉得就两点, 1,使用copy()调用 2.各个类对自己的copyWithZone负责. ##内存管理cocos2d-x的内存管理采用了引用计数的方法. 曾经看到过有人吐槽其内存管理在多线程下不好用. CCObject及其子类的对象在创建时, 引用计数默认为1, 每次retain后引用计数加1. 每次release后引用计数减1.被自动管理的对象引用计数为0时, 会被自动释放. 老G总结的内存管理使用的几点原则(见参考1): 原则1: 谁生成(new, copy)谁负责release. 原则2: 谁retain, 谁负责release. 原则3: 对于使用了autorelease的对象则不必管他. ##几个常用的函数指针当我看到下面这两句的时候, 我完全懵了. typedef void (CCObject::*SEL_SCHEDULE)(float); #define schedule_selector(_SELECTOR) (SEL_SCHEDULE)(&amp;_SELECTOR) 如果你也对函数指针不熟悉的话, 请翻下相关内容吧.在这两句里面, 第一句其实是定义了一个返回类型为void的, 名字为SEL_SCHEDULE的, 参数为float的函数指针.第二句其实是一个函数类型转换, 将(&amp;_SELECTOR)强制转换成SEL_SCHEDULE类型的函数指针. 通常需要回调函数的时候, 就需要用到这些函数指针. 这里就不再赘述, 以后应该会提及相关知识. 好, 我们接下来直接翻代码吧. 版本:cocos2d-2.1beta3-x-2.1.0 路径:cocos2d-2.1beta3-x-2.1.0/cocos2dx/cocoa/CCObject.h 路径:cocos2d-2.1beta3-x-2.1.0/cocos2dx/cocoa/CCObject.cpp CCobject\\.hview raw12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class CC_DLL CCCopying{public: virtual CCObject* copyWithZone(CCZone* pZone);};class CC_DLL CCObject : public CCCopying{public: unsigned int m_uID;//这两个是支持lua等脚本语言用的, 我们不去管他. int m_nLuaID;protected: unsigned int m_uReference;//引用计数 unsigned int m_uAutoReleaseCount;//autorelease计数public: CCObject(void); virtual ~CCObject(void); void release(void); void retain(void); CCObject* autorelease(void); CCObject* copy(void); bool isSingleReference(void); unsigned int retainCount(void); virtual bool isEqual(const CCObject* pObject); virtual void update(float dt) {CC_UNUSED_PARAM(dt);}; //CCAutoreleasePool作为友元类 friend class CCAutoreleasePool;};//几个常用的函数指针.typedef void (CCObject::*SEL_SCHEDULE)(float);typedef void (CCObject::*SEL_CallFunc)();typedef void (CCObject::*SEL_CallFuncN)(CCNode*);typedef void (CCObject::*SEL_CallFuncND)(CCNode*, void*);typedef void (CCObject::*SEL_CallFuncO)(CCObject*);typedef void (CCObject::*SEL_MenuHandler)(CCObject*);typedef void (CCObject::*SEL_EventHandler)(CCEvent*);typedef int (CCObject::*SEL_Compare)(CCObject*);#define schedule_selector(_SELECTOR) (SEL_SCHEDULE)(&amp;_SELECTOR)#define callfunc_selector(_SELECTOR) (SEL_CallFunc)(&amp;_SELECTOR)#define callfuncN_selector(_SELECTOR) (SEL_CallFuncN)(&amp;_SELECTOR)#define callfuncND_selector(_SELECTOR) (SEL_CallFuncND)(&amp;_SELECTOR)#define callfuncO_selector(_SELECTOR) (SEL_CallFuncO)(&amp;_SELECTOR)#define menu_selector(_SELECTOR) (SEL_MenuHandler)(&amp;_SELECTOR)#define event_selector(_SELECTOR) (SEL_EventHandler)(&amp;_SELECTOR)#define compare_selector(_SELECTOR) (SEL_Compare)(&amp;_SELECTOR) CCobject\\.cppview raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778CCObject* CCCopying::copyWithZone(CCZone *pZone){//CCObject的派生类需要调用copy()则必须重写该函数 CC_UNUSED_PARAM(pZone); CCAssert(0, \"not implement\");//不重写会报错. return 0;}CCObject::CCObject(void):m_uAutoReleaseCount(0),m_uReference(1) // 引用计数默认为1,m_nLuaID(0){ static unsigned int uObjectCount = 0; m_uID = ++uObjectCount;//脚本语言相关, 不去管他.}CCObject::~CCObject(void){//析构函数 if (m_uAutoReleaseCount &gt; 0) {//自动引用计数则从管理池中删除 CCPoolManager::sharedPoolManager()-&gt;removeObject(this); } if (m_nLuaID)//脚本语言相关. { CCScriptEngineManager::sharedManager()-&gt;getScriptEngine()-&gt;removeScriptObjectByCCObject(this); } else {//看起来脚本语言支持被深度嵌入, 如果能设置个宏直接去掉其支持多好. CCScriptEngineProtocol* pEngine = CCScriptEngineManager::sharedManager()-&gt;getScriptEngine(); if (pEngine != NULL &amp;&amp; pEngine-&gt;getScriptType() == kScriptTypeJavascript) { pEngine-&gt;removeScriptObjectByCCObject(this); } }}// copy实质上是对copyWithZone的调用.CCObject* CCObject::copy(){ return copyWithZone(0);}void CCObject::release(void){ CCAssert(m_uReference &gt; 0, \"reference count should greater than 0\"); --m_uReference;//引用计数自减 if (m_uReference == 0) {//如果引用计数为0, 调用release会立即释放内存. delete this; }}void CCObject::retain(void){ CCAssert(m_uReference &gt; 0, \"reference count should greater than 0\"); ++m_uReference;//引用计数自增.}CCObject* CCObject::autorelease(void){//autorelease将对象加入自动内存管理池. CCPoolManager::sharedPoolManager()-&gt;addObject(this); return this;}bool CCObject::isSingleReference(void){//判断对象是否仅被引用了一次 return m_uReference == 1;}unsigned int CCObject::retainCount(void){//返回引用次数 return m_uReference;}bool CCObject::isEqual(const CCObject *pObject){//判断对象是否为同一个对象. return this == pObject;} 参考1: http://4137613.blog.51cto.com/4127613/784134","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"http://www.young40.com/categories/Cocos2d-x/"},{"name":"Cocos2d-x 源代码研究","slug":"Cocos2d-x/Cocos2d-x-源代码研究","permalink":"http://www.young40.com/categories/Cocos2d-x/Cocos2d-x-源代码研究/"}],"tags":[]},{"title":"一步一步CocosBuilder(4)[完结]","slug":"2012-12-29-cocosbuilder-step-by-step-part-four","date":"2012-12-29T02:54:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2012/12/29/2012-12-29-cocosbuilder-step-by-step-part-four/","link":"","permalink":"http://www.young40.com/2012/12/29/2012-12-29-cocosbuilder-step-by-step-part-four/","excerpt":"这一节也是很轻松, 主要是牵涉到Timeline的切换. 其他的都是简单的界面制作.所以CocosBuilder的威力也体现在这里, 很少的代码就能驱动界面了. 我们这次先做Particle System, Scroll View, 最后以Animations收官. #####1制作Particle System和Scroll View的界面很简单,我们也是以程序为重点, 所以不再赘述.只需要一句this-&gt;openTest(&quot;ccb/Scroll.ccbi&quot;);就可以调用新的界面了.其他诸如绑定之类相信大家已经是轻车熟路啦.","text":"这一节也是很轻松, 主要是牵涉到Timeline的切换. 其他的都是简单的界面制作.所以CocosBuilder的威力也体现在这里, 很少的代码就能驱动界面了. 我们这次先做Particle System, Scroll View, 最后以Animations收官. #####1制作Particle System和Scroll View的界面很简单,我们也是以程序为重点, 所以不再赘述.只需要一句this-&gt;openTest(&quot;ccb/Scroll.ccbi&quot;);就可以调用新的界面了.其他诸如绑定之类相信大家已经是轻车熟路啦. #####2好吧, 我承认一点, 制作Animations的界面的时候, 我直接复制了例子中的节点.5个Timeline, 还是很复杂的, 应该是一个非常精细的工作. 向美术们致敬.AnimationsLayer.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class AnimationsLayer: public cocos2d::CCLayer, public cocos2d::extension::CCBSelectorResolver&#123;public: AnimationsLayer(); ~AnimationsLayer(); CCB_STATIC_NEW_AUTORELEASE_OBJECT_WITH_INIT_METHOD(AnimationsLayer, create); virtual cocos2d::SEL_MenuHandler onResolveCCBCCMenuItemSelector(CCObject * pTarget, const char* pSelectorName); virtual cocos2d::extension::SEL_CCControlHandler onResolveCCBCCControlSelector(CCObject * pTarget, const char* pSelectorName); void setAnimationManager(cocos2d::extension::CCBAnimationManager *pAnimationManager); void onIdle(cocos2d::CCObject * pSender, cocos2d::extension::CCControlEvent pCCControlEvent); void onWave(cocos2d::CCObject * pSender, cocos2d::extension::CCControlEvent pCCControlEvent); void onJump(cocos2d::CCObject * pSender, cocos2d::extension::CCControlEvent pCCControlEvent); void onFunky(cocos2d::CCObject * pSender, cocos2d::extension::CCControlEvent pCCControlEvent);private: cocos2d::extension::CCBAnimationManager *mAnimationManager;&#125;;class AnimationsLayerLoader : public cocos2d::extension::CCNodeLoader&#123;public: CCB_STATIC_NEW_AUTORELEASE_OBJECT_METHOD(AnimationsLayerLoader, loader);protected: CCB_VIRTUAL_NEW_AUTORELEASE_CREATECCNODE_METHOD(AnimationsLayer);&#125;;``` ``` cpp AnimationsLayer.cppAnimationsLayer::AnimationsLayer(): mAnimationManager(NULL)&#123;&#125;AnimationsLayer::~AnimationsLayer()&#123; CC_SAFE_RELEASE_NULL(mAnimationManager);&#125;SEL_MenuHandler AnimationsLayer::onResolveCCBCCMenuItemSelector(cocos2d::CCObject *pTarget, const char *pSelectorName)&#123; return NULL;&#125;SEL_CCControlHandler AnimationsLayer::onResolveCCBCCControlSelector(cocos2d::CCObject *pTarget, const char *pSelectorName)&#123; CCB_SELECTORRESOLVER_CCCONTROL_GLUE(this, \"onIdle\", AnimationsLayer::onIdle); CCB_SELECTORRESOLVER_CCCONTROL_GLUE(this, \"onJump\", AnimationsLayer::onJump); CCB_SELECTORRESOLVER_CCCONTROL_GLUE(this, \"onWave\", AnimationsLayer::onWave); CCB_SELECTORRESOLVER_CCCONTROL_GLUE(this, \"onFunky\", AnimationsLayer::onFunky); return NULL;&#125;void AnimationsLayer::setAnimationManager(cocos2d::extension::CCBAnimationManager *pAnimationManager)&#123; CC_SAFE_RELEASE_NULL(mAnimationManager); mAnimationManager = pAnimationManager; CC_SAFE_RETAIN(mAnimationManager);&#125;void AnimationsLayer::onIdle(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)&#123; this-&gt;mAnimationManager-&gt;runAnimationsForSequenceNamedTweenDuration(\"Idle\", 0.3f);&#125;void AnimationsLayer::onJump(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)&#123; this-&gt;mAnimationManager-&gt;runAnimationsForSequenceNamedTweenDuration(\"Jump\", 0.3f);&#125;void AnimationsLayer::onWave(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)&#123; this-&gt;mAnimationManager-&gt;runAnimationsForSequenceNamedTweenDuration(\"Wave\", 0.3f);&#125;void AnimationsLayer::onFunky(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)&#123; this-&gt;mAnimationManager-&gt;runAnimationsForSequenceNamedTweenDuration(\"Funky\", 0.3f);&#125; 整个代码还是很简单. 和以前的几个例子稍微有点不同的是在调用的时候, 需要把CCBReader里面的AnimationManger传入.好, 还是看下调用的代码吧.MainScene.cpp123456789101112131415161718192021222324252627282930313233void MainScene::onAnimations(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)&#123; const char * pCCBFileName = \"ccb/Animations.ccbi\"; const char * pCCNodeName = \"AnimationsLayer\"; cocos2d::extension::CCNodeLoader * pCCNodeLoader = AnimationsLayerLoader::loader(); CCScene *scene = CCScene::create(); CCNodeLoaderLibrary *lib = CCNodeLoaderLibrary::newDefaultCCNodeLoaderLibrary(); lib-&gt;registerCCNodeLoader(\"HeaderLayer\", HeaderLayerLoader::loader()); if (pCCNodeName!=NULL &amp;&amp; pCCNodeLoader!=NULL) &#123; lib-&gt;registerCCNodeLoader(pCCNodeName, pCCNodeLoader); &#125; CCBReader *reader = new CCBReader(lib); CCNode *node = reader-&gt;readNodeGraphFromFile(pCCBFileName, this); reader-&gt;autorelease(); if (node != NULL) &#123; //获取AnimationManger 并传给AnimationsLayer ((AnimationsLayer*)node) -&gt;setAnimationManager(reader-&gt;getAnimationManager()); scene-&gt;addChild(node); &#125; this-&gt;mTitleLabelTTF-&gt;setString(pCCBFileName); CCDirector::sharedDirector()-&gt;pushScene(scene);&#125; ###后记看到微博上@做游戏的老G 吐槽说CocosBuilder如何不好用, 学习难度比较大. 我也是很认可这一点.但是只要是坚持把TestCpp例子完全读完了, 相信掌握CocosBuilder也是很快能够做到的.既然你看完了这个教程. 相信你也已经能够很好地驾驭CocosBuilder. 关键还在实践呦! 微博上@Ghost_233 说了一个很好的思路, 直接从ccb文件中生成对应的C++类, 而且他还做了一些实践.我暂时还没有研究他的代码, 不过肯定是可行. 这是一个很赞的思路.希望大家能动手, 最好合作出来一个较好的工具来, 我想, 是不是集成到CocosBuilder会更好? 谢谢大家耐心看完我的文章. 代码打包下载:下载点 本文是系列文章, 请查看其他文章: 一步一步CocosBuilder(1) 一步一步CocosBuilder(2) 一步一步CocosBuilder(3) 一步一步CocosBuilder(4)完结 谢谢您耐心看完此文, 希望能对您有些帮助.如果有什么问题, 意见, 建议, 拍砖, 欢迎留言或者联系我. 新浪微博: @杨世玲 http://weibo.com/young40","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"http://www.young40.com/categories/Cocos2d-x/"},{"name":"CocosBuilder","slug":"Cocos2d-x/CocosBuilder","permalink":"http://www.young40.com/categories/Cocos2d-x/CocosBuilder/"}],"tags":[]},{"title":"一步一步CocosBuilder(3)","slug":"2012-12-28-cocosbuilder-step-by-step-part-three","date":"2012-12-27T16:54:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2012/12/28/2012-12-28-cocosbuilder-step-by-step-part-three/","link":"","permalink":"http://www.young40.com/2012/12/28/2012-12-28-cocosbuilder-step-by-step-part-three/","excerpt":"今天要说的内容比较轻松, 重要的知识点不多.目标是实现Menus &amp; Items, Sprites &amp; 9 Slice, Buttons &amp; Labels. #####1首先我们在CocosBuilder中建立一个新的Header.ccb.具体请参见CocosBuilder的项目.在创建的时候,勾选Full Sceen, 并且将分辨率的Height都修改为40.这个文件很简单, 根节点下只包含一个CCLayerColor,根节点的Custom class设置为HeaderLayer.CCLayerColor下面包含一个CCLabelTTF和CCMenu.CCLabelTTF的变量绑定为类型Owner var, 值为mTitleLabelTTF.CCMenu包含一个CCMenuItemImage. CCMenuItemImage的Selector属性设置为onBackClicked.这个ccb作为一个公用的元素被其他ccb文件所引用. 是属于模块化的一个例子.然后我们在Xcode中新建一个HeaderLayer类, 并同时声明一个HeaderLayerLoader类.","text":"今天要说的内容比较轻松, 重要的知识点不多.目标是实现Menus &amp; Items, Sprites &amp; 9 Slice, Buttons &amp; Labels. #####1首先我们在CocosBuilder中建立一个新的Header.ccb.具体请参见CocosBuilder的项目.在创建的时候,勾选Full Sceen, 并且将分辨率的Height都修改为40.这个文件很简单, 根节点下只包含一个CCLayerColor,根节点的Custom class设置为HeaderLayer.CCLayerColor下面包含一个CCLabelTTF和CCMenu.CCLabelTTF的变量绑定为类型Owner var, 值为mTitleLabelTTF.CCMenu包含一个CCMenuItemImage. CCMenuItemImage的Selector属性设置为onBackClicked.这个ccb作为一个公用的元素被其他ccb文件所引用. 是属于模块化的一个例子.然后我们在Xcode中新建一个HeaderLayer类, 并同时声明一个HeaderLayerLoader类. HeaderLayer.h123456789101112131415161718192021class HeaderLayer: public cocos2d::CCLayer, public cocos2d::extension::CCBSelectorResolver&#123;public: CCB_STATIC_NEW_AUTORELEASE_OBJECT_WITH_INIT_METHOD(HeaderLayer, create); virtual cocos2d::SEL_MenuHandler onResolveCCBCCMenuItemSelector(CCObject * pTarget, const char* pSelectorName); virtual cocos2d::extension::SEL_CCControlHandler onResolveCCBCCControlSelector(CCObject * pTarget, const char* pSelectorName); void onBackClicked(CCObject *pSender);&#125;;class HeaderLayerLoader : public cocos2d::extension::CCLayerLoader&#123;public: CCB_STATIC_NEW_AUTORELEASE_OBJECT_METHOD(HeaderLayerLoader, loader);protected: CCB_VIRTUAL_NEW_AUTORELEASE_CREATECCNODE_METHOD(HeaderLayer);&#125;; HeaderLayer.cpp12345678910111213141516SEL_MenuHandler HeaderLayer::onResolveCCBCCMenuItemSelector(cocos2d::CCObject *pTarget, const char *pSelectorName)&#123; CCB_SELECTORRESOLVER_CCMENUITEM_GLUE(this, \"onBackClicked\", HeaderLayer::onBackClicked); return NULL;&#125;SEL_CCControlHandler HeaderLayer::onResolveCCBCCControlSelector(cocos2d::CCObject *pTarget, const char *pSelectorName)&#123; return NULL;&#125;void HeaderLayer::onBackClicked(cocos2d::CCObject *pSender)&#123; CCDirector::sharedDirector()-&gt;popScene();&#125; #####2在CocosBuilder中新建一个Menus.ccb, 并将根节点Custom class设置为MenuLayer.再加入几个CCMenuItemImage, Selector分别设置为onPressA, onPressB, onPressC.再加入一个CCLabelBMFont, 绑定Doc root var, 值为mMessageLabelBMFont.在Xcode中新建一个类MenuLayer, 并且在MenuLayer.h中同时声明一个MenuLayerLoader类.MenuLayer.h123456789101112131415161718192021222324252627282930class MenuLayer: public cocos2d::CCLayer, public cocos2d::extension::CCBMemberVariableAssigner, public cocos2d::extension::CCBSelectorResolver&#123;public: MenuLayer(); ~MenuLayer(); CCB_STATIC_NEW_AUTORELEASE_OBJECT_WITH_INIT_METHOD(MenuLayer, create); virtual bool onAssignCCBMemberVariable(CCObject* pTarget, const char* pMemberVariableName, CCNode* pNode); virtual cocos2d::SEL_MenuHandler onResolveCCBCCMenuItemSelector(CCObject * pTarget, const char* pSelectorName); virtual cocos2d::extension::SEL_CCControlHandler onResolveCCBCCControlSelector(CCObject * pTarget, const char* pSelectorName); void onPressA(cocos2d::CCObject *pSender); void onPressB(cocos2d::CCObject *pSender); void onPressC(cocos2d::CCObject *pSender);private: cocos2d::CCLabelBMFont *mMessageLabelBMFont;&#125;;class MenuLayerLoader : public cocos2d::extension::CCNodeLoaderLibrary&#123;public: CCB_STATIC_NEW_AUTORELEASE_OBJECT_METHOD(MenuLayerLoader, loader);protected: CCB_VIRTUAL_NEW_AUTORELEASE_CREATECCNODE_METHOD(MenuLayer); &#125;; MenuLayer.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243MenuLayer::MenuLayer(): mMessageLabelBMFont(NULL)&#123;&#125;MenuLayer::~MenuLayer()&#123; CC_SAFE_DELETE(mMessageLabelBMFont);&#125;bool MenuLayer::onAssignCCBMemberVariable(cocos2d::CCObject *pTarget, const char *pMemberVariableName, cocos2d::CCNode *pNode)&#123; CCB_MEMBERVARIABLEASSIGNER_GLUE(this, \"mMessageLabelBMFont\", CCLabelBMFont*, this-&gt;mMessageLabelBMFont); return false;&#125;SEL_MenuHandler MenuLayer::onResolveCCBCCMenuItemSelector(cocos2d::CCObject *pTarget, const char *pSelectorName)&#123; CCB_SELECTORRESOLVER_CCMENUITEM_GLUE(this, \"onPressA\", MenuLayer::onPressA); CCB_SELECTORRESOLVER_CCMENUITEM_GLUE(this, \"onPressB\", MenuLayer::onPressB); CCB_SELECTORRESOLVER_CCMENUITEM_GLUE(this, \"onPressC_NO_Match\", MenuLayer::onPressC); //注意这里, 我们给第三个绑定了一个不存在的SelectorName. return NULL;&#125;SEL_CCControlHandler MenuLayer::onResolveCCBCCControlSelector(cocos2d::CCObject *pTarget, const char *pSelectorName)&#123; return NULL;&#125;void MenuLayer::onPressA(cocos2d::CCObject *pSender)&#123; this-&gt;mMessageLabelBMFont-&gt;setString(\"A pressed.\");&#125;void MenuLayer::onPressB(cocos2d::CCObject *pSender)&#123; this-&gt;mMessageLabelBMFont-&gt;setString(\"B pressed.\");&#125;void MenuLayer::onPressC(cocos2d::CCObject *pSender)&#123; this-&gt;mMessageLabelBMFont-&gt;setString(\"C pressed.\");&#125; #####3或许有点着急了吧, 我们如何让这个运行起来呢?首先给MainScene增加一个新函数的声明及定义, 还需要增加一个变量用于和Header.ccb中的mTitleLabelTTF绑定.MainScene.h1234public: void openTest(const char * pCCBFileName, const char * pCCNodeName = NULL, cocos2d::extension::CCNodeLoader * pCCNodeLoader = NULL);private: cocos2d::CCLabelTTF *mTitleLabelTTF; MainScene.cpp12345678910111213141516171819202122232425262728293031323334void MainScene::openTest(const char * pCCBFileName, const char * pCCNodeName, cocos2d::extension::CCNodeLoader * pCCNodeLoader)&#123; CCScene *scene = CCScene::create(); CCNodeLoaderLibrary *lib = CCNodeLoaderLibrary::newDefaultCCNodeLoaderLibrary(); lib-&gt;registerCCNodeLoader(\"HeaderLayer\", HeaderLayerLoader::loader()); lib-&gt;registerCCNodeLoader(pCCNodeName, pCCNodeLoader); CCBReader *reader = new CCBReader(lib); CCNode *node = reader-&gt;readNodeGraphFromFile(pCCBFileName, this); reader-&gt;autorelease(); if (node != NULL) &#123; scene-&gt;addChild(node); &#125; this-&gt;mTitleLabelTTF-&gt;setString(pCCBFileName); CCDirector::sharedDirector()-&gt;pushScene(scene);&#125;bool MainScene::onAssignCCBMemberVariable(cocos2d::CCObject *pTarget, const char *pMemberVariableName, cocos2d::CCNode *pNode)&#123; CCB_MEMBERVARIABLEASSIGNER_GLUE(this, \"mLabelText\", CCLabelBMFont*, this-&gt;mLabelText); CCB_MEMBERVARIABLEASSIGNER_GLUE(this, \"mTitleLabelTTF\", CCLabelTTF*, this-&gt;mTitleLabelTTF); return false;&#125;void MainScene::onButtonTest(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)&#123; this-&gt;openTest(\"ccb/Menus.ccbi\", \"MenuLayer\", MenuLayerLoader::loader());&#125; #####4Sprites &amp; 9 Slice 这个比较简单, 只是靠CocosBuilder就能完成任务了. 我拼的不太好, 嘿嘿. 主要是着重代码, 并非设计, 漂亮的事情交给美术妹纸吧. #####5Buttons这块主要是研究了CCControlEvent的各种情况. 我们只贴出核心代码.ButtonsLayer.cpp12345678910111213141516171819202122232425262728293031void ButtonsLayer::onBtnClicked(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)&#123; switch (pCCControlEvent) &#123; case CCControlEventTouchCancel: this-&gt;mEventLabelBMFont-&gt;setString(\"Cancel\"); break; case CCControlEventTouchDown: this-&gt;mEventLabelBMFont-&gt;setString(\"Touch Down\"); break; case CCControlEventTouchDragEnter: this-&gt;mEventLabelBMFont-&gt;setString(\"Drag Enter\"); break; case CCControlEventTouchDragExit: this-&gt;mEventLabelBMFont-&gt;setString(\"Drag Exit\"); break; case CCControlEventTouchDragInside: this-&gt;mEventLabelBMFont-&gt;setString(\"Drag Inside\"); break; case CCControlEventTouchDragOutside: this-&gt;mEventLabelBMFont-&gt;setString(\"Drag OutSide\"); break; case CCControlEventTouchUpInside: this-&gt;mEventLabelBMFont-&gt;setString(\"Up Inside\"); break; case CCControlEventTouchUpOutside: this-&gt;mEventLabelBMFont-&gt;setString(\"Up Outside\"); break; default://所有的定义都在上面了,TestCPP里面有句经典的点评, 想看的可以去翻一下. break; &#125;&#125; 代码打包下载:下载点 本文是系列文章, 请查看其他文章: 一步一步CocosBuilder(1) 一步一步CocosBuilder(2) 一步一步CocosBuilder(3) 一步一步CocosBuilder(4)完结 谢谢您耐心看完此文, 希望能对您有些帮助.如果有什么问题, 意见, 建议, 拍砖, 欢迎留言或者联系我. 新浪微博: @杨世玲 http://weibo.com/young40","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"http://www.young40.com/categories/Cocos2d-x/"},{"name":"CocosBuilder","slug":"Cocos2d-x/CocosBuilder","permalink":"http://www.young40.com/categories/Cocos2d-x/CocosBuilder/"}],"tags":[]},{"title":"一步一步CocosBuilder(2)","slug":"2012-12-25-cocosbuilder-step-by-step-part-two","date":"2012-12-25T13:15:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2012/12/25/2012-12-25-cocosbuilder-step-by-step-part-two/","link":"","permalink":"http://www.young40.com/2012/12/25/2012-12-25-cocosbuilder-step-by-step-part-two/","excerpt":"上一篇我们建立了基本的工作环境, 这一次我们将基本实现例子中的HelloCocosBuilder. ###注意这两天纠结了一个问题. 我发现按照上次的配置来实现例子, 图片的大小怎么都和例子中的搭配不上. 后来动用CCB的源代码才看出端倪.CCB v3.0加入了一个resources-auto的目录, 在发布的时候, 会自动缩放图片到对应的分辨率去. 因为图片的分辨率不合适(初步目测), 我们暂时不使用这功能. 请大家将上一篇文章中的resources-auto文件夹下图片移到父目录ccb-source下面. 这个也解释了为什么resources-auto有非图片文件会导致CCB崩溃的原因.","text":"上一篇我们建立了基本的工作环境, 这一次我们将基本实现例子中的HelloCocosBuilder. ###注意这两天纠结了一个问题. 我发现按照上次的配置来实现例子, 图片的大小怎么都和例子中的搭配不上. 后来动用CCB的源代码才看出端倪.CCB v3.0加入了一个resources-auto的目录, 在发布的时候, 会自动缩放图片到对应的分辨率去. 因为图片的分辨率不合适(初步目测), 我们暂时不使用这功能. 请大家将上一篇文章中的resources-auto文件夹下图片移到父目录ccb-source下面. 这个也解释了为什么resources-auto有非图片文件会导致CCB崩溃的原因. #####1在CCB中打开MainScene.ccb,按delete键删除已经存在的几个Sprite. #####2添加一个CCLayerGradient到屏幕, 如果有问题的话, 可以参见下文档. 选中该节点, 我们可以在右侧看到他的属性, 常规的属性有比如位置, 大小, 锚点, 缩放, 旋转, 标签.我们现在将其设置为大小为100%x100%的大小, 即满屏. #####3从左侧的文件中将burst.png拖入屏幕, 也可以使用工具栏添加然后再选择属性Sprite frame.可以在节点树上双击该节点给其重命名, 我们将该节点命名为CCSprite-burst, 便于识别.同样我们将其中心的设置到屏幕中心50%x50%, 缩放到2.5倍.然后将Blend src, Blend dst 都设置为One, 好吧, 我暂时还不知道这个Blend是什么东西. 有知道的朋友不妨在评论中告诉我下, 或者参考资料.大概是透明之类的东西吧. #####4然后我们再添加一个CCParticleSystemQuad粒子系统, 就是工具栏的那个Fx按钮.将其位置设为最下居中, 在最下边Particle Texture设置为ccbParticleSnow.png效果,粒子系统还是很复杂的,估计能单独讲很久了. 这里就不再展开了. #####5将logo-icon.png拖入屏幕, 放在左上角合适位置, 并将其缩放到0.5. 节点重命名为CCSprite-logo-icon.接下来就是动画的制作了.选中节点, 可以在菜单栏中Animation =&gt; Insert KeyFrame找到插入Framekey的各种快捷键.或许我们需要记熟他们.首先让我们给Timeline设置下时间.双击时间可以编辑, 我们输入00:03:00, 就是3秒钟. 后面最后一位是帧数, 每秒30帧.按下小三角可以展开当前节点的各种KeyFrame.拖动时间轴游标到1秒10帧,按下键盘S, 可以插入一个Scale类型的KeyFrame, 这时将当前节点Scale属性改为0.然后继续拖动时间轴游标到2秒10帧, 再插入一个Scale KeyFrame, 并将Scale属性改为0.5. 这时点击播放按钮, 可以看到logo会蹦出来.然后在紫色条上点击右键, 可以看到动作菜单, 我们选择Bounce Out, 这个时候再点击播放, 就可以看到logo蹦出的时候会有一个弹震的效果.再来说明两点, 紫色条设置不同的动作, 可以看到上面会有一点阴影变化, 可以帮助我们快速确认设置的是什么动作.如果不小心加多了KeyFrame, 那么可以点击选择KeyFrame, 然后点击delete键删除.还有需要注意的是, 如果游标不在KeyFrame的点上, 那么此时无法编辑该节点属性, 移动到相应的KeyFrame点即可. #####6然后依法炮制, 将logo.png加入, 你可以给其设置想要的动画效果. #####7我们再添加一个CCLabelBMFont, 字体设置为markerfelt24shadow.fnt.Label的内容设置为”Hello Cocos2d-x!!!”, 然后调整下位置, 换个喜欢的颜色. #####8我们再添加一个CCControlButton, Title设置为Menu &amp; Item.然后再分别设置State Normal, State Highlighted的Sprite frame为btn-test-0.png &nbsp; btn-test-1.png.然后再设置下弹出效果.将这个节点再复制5份, 对齐. 再分别设置下Title和弹出效果.设置对齐的时候可能会比较麻烦. 可以从标尺那里拉出几条线, 用于对齐.将该对齐线拉出显示区域即可删除. #####9最后将左右的两片叶子加入屏幕, 设置个动画即可.然后将CCB项目发布一下, 在Xcode里面将项目运行一下. 就可以看到效果了. #####10我们接下来研究文件和类的绑定, 控件和变量的绑定, 以及事件和函数的绑定.我们在CCB中将根节点的Custom class设置为MainScene.我们在Xcode中打开MainScene.h, 给MainScene增加一个新的函数CCB_STATIC_NEW_AUTORELEASE_OBJECT_WITH_INIT_METHOD(MainScene, create);.最后的代码应该如下:MainScene12345678class MainScene: public cocos2d::CCLayer&#123;public: static cocos2d::CCScene* scene(); CCB_STATIC_NEW_AUTORELEASE_OBJECT_WITH_INIT_METHOD(MainScene, create);&#125;; 然后在MainScene.h中添加一个新类MainSceneLayerLoader代码如下:MainSceneLayerLoader1234567class MainSceneLayerLoader : public cocos2d::extension::CCLayerLoader&#123;public: CCB_STATIC_NEW_AUTORELEASE_OBJECT_METHOD(MainSceneLayerLoader, loader);protected: CCB_VIRTUAL_NEW_AUTORELEASE_CREATECCNODE_METHOD(MainScene);&#125;; 如果需要探究的话, 可以点开相应的函数定义. 也都是些简单的工作.吐槽下, 这些名字真的是太难记. 可能需要多熟悉下, 搞清楚其原理了才好. 然后我们在MainScene.cpp中添加一行注册将ccb文件和类绑定起来.MainScene::scene()12CCNodeLoaderLibrary *lib = CCNodeLoaderLibrary::newDefaultCCNodeLoaderLibrary();lib-&gt;registerCCNodeLoader(\"MainScene\", MainSceneLayerLoader::loader()); 然后运行下, 确保没有错误.这几行代码, 就是ccb文件和类绑定的最简模式了. #####11接着我们研究下控件和变量的绑定.我们先在CCB中给CCLabelBMFont添加一个Doc root var类型的绑定mLabelText.一个需要注意的地方就是CCB v3.0alpha似乎无法将jsControlled设置为false, 所以可能需要手工打开MainScene.ccb将其改为false.MainScene.ccb12&lt;key&gt;jsControlled&lt;/key&gt;&lt;false/&gt; 然后在Xcode中给MainScene增加一个从CCBMemberVariableAssigner的继承并实现其虚函数. 并且添加相应的变量.MainScene1234567891011121314151617class MainScene: public cocos2d::CCLayer, public cocos2d::extension::CCBMemberVariableAssigner&#123;public: MainScene(); ~MainScene(); static cocos2d::CCScene* scene(); CCB_STATIC_NEW_AUTORELEASE_OBJECT_WITH_INIT_METHOD(MainScene, create); virtual bool onAssignCCBMemberVariable(cocos2d::CCObject* pTarget, const char* pMemberVariableName, cocos2d::CCNode* pNode); private: cocos2d::CCLabelBMFont *mLabelText;&#125;; 在MainScene.cpp中需要添加的是:MainScene.cpp123456789101112131415MainScene::MainScene()//构造函数: mLabelText(NULL)&#123;&#125;MainScene::~MainScene()//析构函数中释放内存不能忘&#123; CC_SAFE_DELETE(mLabelText);&#125;bool MainScene::onAssignCCBMemberVariable(cocos2d::CCObject *pTarget, const char *pMemberVariableName, cocos2d::CCNode *pNode)&#123; CCB_MEMBERVARIABLEASSIGNER_GLUE(this, \"mLabelText\", CCLabelBMFont*, this-&gt;mLabelText); return true;&#125; 需要注意的是, 由于绑定较晚, 所以无法在init函数中使用变量mLabelText. #####12接下来我们研究事件和函数的绑定.在CCB中找到Menu &amp; Item这个CCControlButton, 并设置其Selector为onButtonTest.Target设置为Document root.这里需要注意的是, 设置值的时候,cocos2d-iphone似乎比较喜欢设置成onButtonTest:即多个:的形式. 我们在cocos2d-x中保持一致即可.不必加:.然后打开MainScene.h给MainScene再增加一个继承.MainScene1234class MainScene: public cocos2d::CCLayer, public cocos2d::extension::CCBMemberVariableAssigner, public cocos2d::extension::CCBSelectorResolver 还有需要实现的函数MainScene1234virtual cocos2d::SEL_MenuHandler onResolveCCBCCMenuItemSelector(cocos2d::CCObject * pTarget, const char* pSelectorName);virtual cocos2d::extension::SEL_CCControlHandler onResolveCCBCCControlSelector(cocos2d::CCObject * pTarget, const char* pSelectorName); void onButtonTest(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent); 接下来是增加的函数的实现MainScene.cpp12345678910111213141516SEL_MenuHandler MainScene::onResolveCCBCCMenuItemSelector(cocos2d::CCObject *pTarget, const char *pSelectorName)&#123; return NULL;&#125;SEL_CCControlHandler MainScene::onResolveCCBCCControlSelector(cocos2d::CCObject *pTarget, const char *pSelectorName)&#123; CCB_SELECTORRESOLVER_CCCONTROL_GLUE(this, \"onButtonTest\", MainScene::onButtonTest); return NULL;&#125;void MainScene::onButtonTest(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)&#123; this-&gt;mLabelText-&gt;setString(\"Hello CocosBuilder!!!\");&#125; 好了, 现在运行一下, 点击按钮, 就会看到Hello Cocos2d-x!!!变成了Hello CocosBuilder!!!了. #####13刚才我们提到变量绑定较init函数(更别提运行更早的构造函数了)更晚. 那么如何运行后就控制这些控件呢?方法当然是有, 我们需要增加一个CCNodeLoaderListener, 并实现其接口.新增代码如下:MainScene1234567, public cocos2d::extension::CCBSelectorResolver, public cocos2d::extension::CCNodeLoaderListener&#123; ///......代码省略鸟 virtual void onNodeLoaded(cocos2d::CCNode * pNode, cocos2d::extension::CCNodeLoader * pNodeLoader); ///......代码省略鸟&#125; MainScene.cpp1234void MainScene::onNodeLoaded(cocos2d::CCNode *pNode, cocos2d::extension::CCNodeLoader *pNodeLoader)&#123; this-&gt;mLabelText-&gt;setString(\"All Loaded\");&#125; 好啦, 运行就能看到All Loaded啦. 代码打包下载:下载点 本文是系列文章, 请查看其他文章: 一步一步CocosBuilder(1) 一步一步CocosBuilder(2) 一步一步CocosBuilder(3) 一步一步CocosBuilder(4)完结 谢谢您耐心看完此文, 希望能对您有些帮助.如果有什么问题, 意见, 建议, 拍砖, 欢迎留言或者联系我. 新浪微博: @杨世玲 http://weibo.com/young40","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"http://www.young40.com/categories/Cocos2d-x/"},{"name":"CocosBuilder","slug":"Cocos2d-x/CocosBuilder","permalink":"http://www.young40.com/categories/Cocos2d-x/CocosBuilder/"}],"tags":[]},{"title":"一步一步CocosBuilder(1)","slug":"2012-12-21-cocosbuilder-step-by-step-part-one","date":"2012-12-20T18:46:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2012/12/21/2012-12-21-cocosbuilder-step-by-step-part-one/","link":"","permalink":"http://www.young40.com/2012/12/21/2012-12-21-cocosbuilder-step-by-step-part-one/","excerpt":"CocosBuilder是Cocos2d系列的配套开源工具,最新的版本是3.0a, 也是我们这个系列文章所采用的版本.CCB(CocosBuilder简称)目前只有OS X版本, 没有Windows的版本, 而且源代码也是用Objective-c, 估计移植难度会比较大.我想这个也是其不够流行的原因吧. 如果你是CCB的熟客,那么你一定会记得CCB v2.x以前版本附带的例子. 而CCB v3.0采用了一个叫做CocosDragonJS的例子, 主要是展示CCB的Javascript的调用能力.我虽然很喜欢JS, 但是正在学习2d-x, 又很想学好, 所以还是打好基础, 学好原滋原味的2d-x才好, 以后换用无论是Html5, 还是JS, Lua, 心里才会觉得踏实.我无论C++,还是2d-x都是新手,又是第一次想正儿八经的写博客文章, 难免有很多错误, 还望各位看客踊跃拍砖. 这次的目的是基本实现原来v2.0中的例子.我采用的2d-x的版本是:cocos2d-2.1beta3-x-2.1.0, 以OS X版本为主, 以sample目录下的HelloCpp为基础改进. CCB的版本是v3.0alpha0.","text":"CocosBuilder是Cocos2d系列的配套开源工具,最新的版本是3.0a, 也是我们这个系列文章所采用的版本.CCB(CocosBuilder简称)目前只有OS X版本, 没有Windows的版本, 而且源代码也是用Objective-c, 估计移植难度会比较大.我想这个也是其不够流行的原因吧. 如果你是CCB的熟客,那么你一定会记得CCB v2.x以前版本附带的例子. 而CCB v3.0采用了一个叫做CocosDragonJS的例子, 主要是展示CCB的Javascript的调用能力.我虽然很喜欢JS, 但是正在学习2d-x, 又很想学好, 所以还是打好基础, 学好原滋原味的2d-x才好, 以后换用无论是Html5, 还是JS, Lua, 心里才会觉得踏实.我无论C++,还是2d-x都是新手,又是第一次想正儿八经的写博客文章, 难免有很多错误, 还望各位看客踊跃拍砖. 这次的目的是基本实现原来v2.0中的例子.我采用的2d-x的版本是:cocos2d-2.1beta3-x-2.1.0, 以OS X版本为主, 以sample目录下的HelloCpp为基础改进. CCB的版本是v3.0alpha0. 本文的目标是基本实现将CCB整合进Mac OS X版本的项目中. 首先将2d-x源代码中sample目录下的HelloCpp目录重命名为TestCocosBuilder.并使用CocosBuilder创建新项目文件在其Resources文件夹中.还需要将项目需要的图片资源放入Resources目录中. 具体可以参见我打包后的整体项目文件.还可以参见文末的目录树说明. 贴下Xcode项目的目录,如果添加extensions应该逐个添加,否则可能会遇到编译错误,有可能会把其他平台文件错误添加进来. 做完这些准备工作后, 我们接下来按步来讲解. 1.首先编辑下AppMacros.h, 修改以下代码AppMacros.h123static Resource smallResource = &#123; cocos2d::CCSizeMake(480, 320), \"resources-iphone\" &#125;;static Resource mediumResource = &#123; cocos2d::CCSizeMake(1024, 768), \"resources-ipad\" &#125;;static Resource largeResource = &#123; cocos2d::CCSizeMake(2048, 1536), \"resources-ipadhd\" &#125;; 这一段主要是修改HelloCpp默认的资源目录, 配合CCB的发布路径.同时可以将原来几个目录中文件分别移入对应目录.2.添加一个新类MainScene如下MainScene.h1234567891011121314#ifndef __HelloCpp__MainScene__#define __HelloCpp__MainScene__#include \"cocos2d.h\"#include \"cocos-ext.h\"class MainScene: public cocos2d::CCLayer //从CCLayer派生&#123;public: static cocos2d::CCScene* scene();&#125;;#endif /* defined(__HelloCpp__MainScene__) */ MainScene.cpp123456789101112131415161718192021222324#include \"MainScene.h\"USING_NS_CC;USING_NS_CC_EXT;CCScene* MainScene::scene()&#123; CCScene *scene = CCScene::create(); CCNodeLoaderLibrary *lib = CCNodeLoaderLibrary::newDefaultCCNodeLoaderLibrary(); //生成一个默认的Node Loader CCBReader *reader = new CCBReader(lib); //用node load lib 初始化一个ccb reader CCNode *node = reader-&gt;readNodeGraphFromFile(\"MainScene.ccbi\", scene); //从ccbi文件中加载node reader-&gt;release(); //注意手动释放内存 if (node!=NULL) &#123; scene-&gt;addChild(node); //将node 添加到scene中 &#125; return scene;&#125; 3.修改AppDelegate.cpp中默认的启动scene1CCScene *pScene = MainScene::scene(); //HelloWorld::scene(); 4.注意CCB中发布选项的设置, 并发布一次. 5.如果没有错误的话, 你应该可以看到运行的效果. Update:@王哲Walzer 说,CCB大部分是美术在用, 在美术圈讨论, 所以程序圈较少看到人在讨论, 其实用的公司挺多的.http://weibo.com/1702027805/zay18wLT5 目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748├── samples #目录结构和2d-x源代码保持一致,相信大家对2d-x源代码很熟悉了.│ └── CocosBuilderTest #项目所在目录│ ├── Classes #代码所在目录│ ├── Resources #资源目录│ │ ├── ccb #ccb发布后的目录│ │ │ ├── HelloCocosBuilder.ccbi│ │ │ ├── ...│ │ │ └── TestSprites.ccbi│ │ ├── ccbResources #发布后的默认ccb资源│ │ ├── fonts│ │ ├── resources-ipad #注意这几个目录, 稍后我们会提及│ │ ├── resources-ipadhd│ │ ├── resources-iphone│ │ ├── resources-iphonehd│ ├── ccb-source #ccb项目目录│ │ ├── ccb│ │ │ ├── HelloCocosBuilder.ccb #这几个是原CocosBuilder例子中的ccb, 直接复制过来了.│ │ │ ├── ...│ │ │ └── TestSprites.ccbi│ │ ├── ccbResources│ │ ├── resources-auto #CocosBuilderv3.0的资源目录, 似乎只能存放图片│ │ │ ├── btn-a-0.png #否则会引起发布是造成CocosBuilder崩溃│ │ │ ├── ...│ │ │ └── scale-9-demo.png│ │ ├── MainScene.ccb #默认生成的ccb, 我们这一次不对其更改│ │ ├── MainScene.js│ │ ├── animated-grossini.plist│ │ ├── animated-grossini.png│ │ ├── ccb-source.ccbproj│ │ ├── comic\\ andy.ttf│ │ ├── grossini-generic.plist│ │ ├── grossini-generic.png│ │ ├── markerfelt24shadow.fnt│ │ └── markerfelt24shadow.png│ └── proj.mac│ ├── HelloCpp.xcodeproj #项目文件, 暂时只支持mac os x├── cocos2dx #2d-x文件├── extensions #2d-x的扩展│ ├── CCBReader #这个是解析CocosBuilder的主要CCBReader│ │ ├── CCBAnimationManager.cpp│ │ ├── CCBAnimationManager.h│ │ ├── ...│ │ └── CCSpriteLoader.h│ ├── GUI│ ├── network│ ├── physics_nodes│ ├── ExtensionMacros.h│ └── cocos-ext.h 代码打包下载:下载点 本文是系列文章, 请查看其他文章: 一步一步CocosBuilder(1) 一步一步CocosBuilder(2) 一步一步CocosBuilder(3) 一步一步CocosBuilder(4)完结 谢谢您耐心看完此文, 希望能对您有些帮助.如果有什么问题, 意见, 建议, 拍砖, 欢迎留言或者联系我. 新浪微博: @杨世玲 http://weibo.com/young40","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"http://www.young40.com/categories/Cocos2d-x/"},{"name":"CocosBuilder","slug":"Cocos2d-x/CocosBuilder","permalink":"http://www.young40.com/categories/Cocos2d-x/CocosBuilder/"}],"tags":[]},{"title":"2d-x深读2:CCPlatformMacros.h","slug":"2012-12-17-cocos2d-x-source-code-research-2-ccplatformmacros-dot-h","date":"2012-12-16T17:49:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2012/12/17/2012-12-17-cocos2d-x-source-code-research-2-ccplatformmacros-dot-h/","link":"","permalink":"http://www.young40.com/2012/12/17/2012-12-17-cocos2d-x-source-code-research-2-ccplatformmacros-dot-h/","excerpt":"路径:cocos2d-2.1beta3-x-2.1.0/cocos2dx/include/ccConfig.h 路径:cocos2d-2.1beta3-x-2.1.0/cocos2dx/platform/mac/CCPlatformDefine.h //注意我是以mac平台研究的, 其他平台略有不同 路径:cocos2d-2.1beta3-x-2.1.0/cocos2dx/platform/CCPlatformMacros.h","text":"路径:cocos2d-2.1beta3-x-2.1.0/cocos2dx/include/ccConfig.h 路径:cocos2d-2.1beta3-x-2.1.0/cocos2dx/platform/mac/CCPlatformDefine.h //注意我是以mac平台研究的, 其他平台略有不同 路径:cocos2d-2.1beta3-x-2.1.0/cocos2dx/platform/CCPlatformMacros.h ccConfig.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include \"platform/CCPlatformConfig.h\"//设置为1后会include CCPhysicsScript 和 CCPhysicsDebugNode 添加到物理引擎支持//需要保证Chipmunk在搜索路径中#ifndef CC_ENABLE_CHIPMUNK_INTEGRATION#define CC_ENABLE_CHIPMUNK_INTEGRATION 0#endif//设置为1后会include CCPhysicsScript 添加到Box2D的支持//同样需要保证Box2D会在搜索路径中#ifndef CC_ENABLE_BOX2D_INTEGRATION#define CC_ENABLE_BOX2D_INTEGRATION 0#endif/** 设置为1后,2d学会维护一个OpenGL状态缓存来避免不必要的切换 为了使用这个功能,需要用下列函数来替换GL的对应函数 - ccGLUseProgram() instead of glUseProgram() - ccGLDeleteProgram() instead of glDeleteProgram() - ccGLBlendFunc() instead of glBlendFunc()如果这个功能被禁止, 那么这些函数会直接调用对应的GL函数, 当然就没有缓存了打开这个功能能提高速度如果你的代码是从GL ES 1.1升级过来的, 保持这个功能被禁用. 如果各种功能正常的话, 你可以启用这个功能#ifndef CC_ENABLE_GL_STATE_CACHE#define CC_ENABLE_GL_STATE_CACHE 1#endif/**启用后,纹理的坐标会用这个公式来计算- texCoord.left = (rect.origin.x*2+1) / (texture.wide*2);- texCoord.right = texCoord.left + (rect.size.width*2-2)/(texture.wide*2);The same for bottom and top.This formula prevents artifacts by using 99% of the texture.The \"correct\" way to prevent artifacts is by using the spritesheet-artifact-fixer.py or a similar tool.受影响的类:- CCSprite / CCSpriteBatchNode and subclasses: CCLabelBMFont, CCTMXTiledMap- CCLabelAtlas- CCQuadParticleSystem- CCTileMap*/#ifndef CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL#define CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL 0#endif//默认0.5秒, 更新下FPS的数据. 数字越大FPS数据越可靠.#ifndef CC_DIRECTOR_STATS_INTERVAL#define CC_DIRECTOR_STATS_INTERVAL (0.5f)#endif//FPS数据显示位置,默认左下#ifndef CC_DIRECTOR_FPS_POSITION#define CC_DIRECTOR_FPS_POSITION ccp(0,0)#endif/** @def CC_DIRECTOR_DISPATCH_FAST_EVENTS If enabled, and only when it is used with CCFastDirector, the main loop will wait 0.04 seconds to dispatch all the events, even if there are not events to dispatch. If your game uses lot's of events (eg: touches) it might be a good idea to enable this feature. Otherwise, it is safe to leave it disabled. To enable set it to 1. Disabled by default. @warning This feature is experimental */#ifndef CC_DIRECTOR_DISPATCH_FAST_EVENTS #define CC_DIRECTOR_DISPATCH_FAST_EVENTS 0#endif/** @def CC_DIRECTOR_MAC_USE_DISPLAY_LINK_THREADIf enabled, cocos2d-mac will run on the Display Link thread. If disabled cocos2d-mac will run in its own thread.If enabled, the images will be drawn at the \"correct\" time, but the events might not be very responsive.If disabled, some frames might be skipped, but the events will be dispatched as they arrived.To enable set it to a 1, to disable it set to 0. Enabled by default.Only valid for cocos2d-mac. Not supported on cocos2d-ios.*/#ifndef CC_DIRECTOR_MAC_USE_DISPLAY_LINK_THREAD#define CC_DIRECTOR_MAC_USE_DISPLAY_LINK_THREAD 1#endif/** @def CC_NODE_RENDER_SUBPIXEL If enabled, the CCNode objects (CCSprite, CCLabel,etc) will be able to render in subpixels. If disabled, integer pixels will be used. To enable set it to 1. Enabled by default. */#ifndef CC_NODE_RENDER_SUBPIXEL#define CC_NODE_RENDER_SUBPIXEL 1#endif/** @def CC_SPRITEBATCHNODE_RENDER_SUBPIXEL If enabled, the CCSprite objects rendered with CCSpriteBatchNode will be able to render in subpixels. If disabled, integer pixels will be used. To enable set it to 1. Enabled by default. */#ifndef CC_SPRITEBATCHNODE_RENDER_SUBPIXEL#define CC_SPRITEBATCHNODE_RENDER_SUBPIXEL 1#endif/** @def CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP Use GL_TRIANGLE_STRIP instead of GL_TRIANGLES when rendering the texture atlas. It seems it is the recommend way, but it is much slower, so, enable it at your own risk To enable set it to a value different than 0. Disabled by default. */#ifndef CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP#define CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP 0#endif//VAO定点数组对象/** @def CC_TEXTURE_ATLAS_USE_VAO By default, CCTextureAtlas (used by many cocos2d classes) will use VAO (Vertex Array Objects). Apple recommends its usage but they might consume a lot of memory, specially if you use many of them. So for certain cases, where you might need hundreds of VAO objects, it might be a good idea to disable it. To disable it set it to 0. Enabled by default. */#ifndef CC_TEXTURE_ATLAS_USE_VAO #if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS) || (CC_TARGET_PLATFORM == CC_PLATFORM_MAC) #define CC_TEXTURE_ATLAS_USE_VAO 1 #else /* Some Windows display adapter driver cannot support VAO. */ /* Some android devices cannot support VAO very well, so we disable it by default for android platform. */ /* Blackberry also doesn't support this feature. */ #define CC_TEXTURE_ATLAS_USE_VAO 0 #endif#endif/** @def CC_USE_LA88_LABELS If enabled, it will use LA88 (Luminance Alpha 16-bit textures) for CCLabelTTF objects. If it is disabled, it will use A8 (Alpha 8-bit textures). LA88 textures are 6% faster than A8 textures, but they will consume 2x memory. This feature is enabled by default. @since v0.99.5 */#ifndef CC_USE_LA88_LABELS#define CC_USE_LA88_LABELS 1#endif/** 启用后,所有CCSprite的子类都会花上一个边框,方便调试 0 -- disabled 1 -- draw bounding box 2 -- draw texture box*/#ifndef CC_SPRITE_DEBUG_DRAW#define CC_SPRITE_DEBUG_DRAW 0#endif//CCSpriteBatchNode的调试用加边框#ifndef CC_SPRITEBATCHNODE_DEBUG_DRAW#define CC_SPRITEBATCHNODE_DEBUG_DRAW 0#endif//CCLabelBMFont调试加边框#ifndef CC_LABELBMFONT_DEBUG_DRAW#define CC_LABELBMFONT_DEBUG_DRAW 0#endif//LabeltAtlas调试加边框#ifndef CC_LABELATLAS_DEBUG_DRAW#define CC_LABELATLAS_DEBUG_DRAW 0#endif/** @def CC_ENABLE_PROFILERS If enabled, will activate various profilers within cocos2d. This statistical data will be output to the console once per second showing average time (in milliseconds) required to execute the specific routine(s). Useful for debugging purposes only. It is recommended to leave it disabled. To enable set it to a value different than 0. Disabled by default. */#ifndef CC_ENABLE_PROFILERS#define CC_ENABLE_PROFILERS 0#endif/** Enable Lua engine debug log */#ifndef CC_LUA_ENGINE_DEBUG#define CC_LUA_ENGINE_DEBUG 0#endif mac/CCPlatformDefine.h1234567891011121314151617181920#include &lt;assert.h&gt; //引入assert#define CC_DLL //CC_DLL只在win32平台下有效#if CC_DISABLE_ASSERT &gt; 0#define CC_ASSERT(cond) //禁用了assert#else#define CC_ASSERT(cond) assert(cond) //启用了assert#endif#define CC_UNUSED_PARAM(unusedparam) (void)unusedparam//定义空指针#ifndef NULL#ifdef __cplusplus#define NULL 0#else#define NULL ((void *)0)#endif#endif 我们可以看到win32中不同的部分比如CC_DLLwin32/CCPlatformDefine.h12345#if defined(_USRDLL) #define CC_DLL __declspec(dllexport)#else /* use a DLL library */ #define CC_DLL __declspec(dllimport)#endif Linux部分也是CC_DLL不同linux/CCPlatformDefine.h12345#if defined(_USRDLL)#define CC_DLL __attribute__ ((visibility (\"default\")))#else /* use a DLL library */#define CC_DLL __attribute__ ((visibility (\"default\")))#endif Android中比较不同的部分是CC_ASSERTandroid/CCPlatformDefine.h1234567#define CC_ASSERT(cond) \\if (! (cond)) \\&#123; \\ char content[256]; \\ sprintf(content, \"%s function:%s line:%d\", __FILE__, __FUNCTION__, __LINE__); \\ CCMessageBox(content, \"Assert error\"); \\&#125; 我们最后再来看下CCPlatformMacros.hCCPlatformMacros.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include \"ccConfig.h\"#include \"CCPlatformConfig.h\"#include \"CCPlatformDefine.h\"//CREATE_FUNC是2d-x的一个核心功能,一般采用例如`MySpriter *my = MySpriter::create()`的形式调用.//这里的create()成员函数即是由CREATE_FUNC创建, 来达到让2d-x来管理内存分配的功能#define CREATE_FUNC(__TYPE__) \\static __TYPE__* create() \\&#123; \\ __TYPE__ *pRet = new __TYPE__(); \\ if (pRet &amp;&amp; pRet-&gt;init()) \\ &#123; \\ pRet-&gt;autorelease(); \\ return pRet; \\ &#125; \\ else \\ &#123; \\ delete pRet; \\ pRet = NULL; \\ return NULL; \\ &#125; \\&#125;//早期版本还有一个NODE_FUNC完成和CREATE_FUNC一样的功能,已经废弃,不再讨论//CC_ENABLE_CACHE_TEXTURE_DATA 只在Android上启用, 会缓存纹理#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID) #define CC_ENABLE_CACHE_TEXTURE_DATA 1#else #define CC_ENABLE_CACHE_TEXTURE_DATA 0#endif#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID) || (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)//重新绑定indices, 避免在android和win32下glDrawElements函数crash的bug #define CC_REBIND_INDICES_BUFFER 1#else #define CC_REBIND_INDICES_BUFFER 0#endif//常用宏定义#ifdef __cplusplus //namespace只在C++中起作用 #define NS_CC_BEGIN namespace cocos2d &#123; #define NS_CC_END &#125; #define USING_NS_CC using namespace cocos2d //应该尽量使用USING_NS_CC, 兼容性更好#else #define NS_CC_BEGIN #define NS_CC_END #define USING_NS_CC #endif //成员函数快捷声明/定义宏//多使用这些宏, 可以方便地定义出合乎面向对象原则的成员变量.//需要注意的是这些调用了这些宏之后, 应该养成重新写public, private等标号的习惯. 因为之后的都会变成public//定义的成员变量都是protected的//只读的成员变量#define CC_PROPERTY_READONLY(varType, varName, funName)\\protected: varType varName;\\public: virtual varType get##funName(void);//getter是为引用#define CC_PROPERTY_READONLY_PASS_BY_REF(varType, varName, funName)\\protected: varType varName;\\public: virtual const varType&amp; get##funName(void);//可读可写成员变量#define CC_PROPERTY(varType, varName, funName)\\protected: varType varName;\\public: virtual varType get##funName(void);\\public: virtual void set##funName(varType var);#define CC_PROPERTY_PASS_BY_REF(varType, varName, funName)\\protected: varType varName;\\public: virtual varType get##funName(void);\\public: virtual void set##funName(const varType&amp; var);//以上的getter,setter只有声明, 下面的这些带有定义#define CC_SYNTHESIZE_READONLY(varType, varName, funName)\\protected: varType varName;\\public: virtual varType get##funName(void) const &#123; return varName; &#125;#define CC_SYNTHESIZE_READONLY_PASS_BY_REF(varType, varName, funName)\\protected: varType varName;\\public: virtual const varType&amp; get##funName(void) const &#123; return varName; &#125;#define CC_SYNTHESIZE(varType, varName, funName)\\protected: varType varName;\\public: virtual varType get##funName(void) const &#123; return varName; &#125;\\public: virtual void set##funName(varType var)&#123; varName = var; &#125;#define CC_SYNTHESIZE_PASS_BY_REF(varType, varName, funName)\\protected: varType varName;\\public: virtual varType get##funName(void) const &#123; return varName; &#125;\\public: virtual void set##funName(const varType&amp; var)&#123; varName = var; &#125;//setter中会retain一次var, 防止被gc回收.#define CC_SYNTHESIZE_RETAIN(varType, varName, funName) \\private: varType varName; \\public: virtual varType get##funName(void) const &#123; return varName; &#125; \\public: virtual void set##funName(varType var) \\&#123; \\ if (varName != var) \\ &#123; \\ CC_SAFE_RETAIN(var); \\ CC_SAFE_RELEASE(varName); \\ varName = var; \\ &#125; \\&#125; #define CC_SAFE_DELETE(p) do &#123; if(p) &#123; delete (p); (p) = 0; &#125; &#125; while(0)#define CC_SAFE_DELETE_ARRAY(p) do &#123; if(p) &#123; delete[] (p); (p) = 0; &#125; &#125; while(0)#define CC_SAFE_FREE(p) do &#123; if(p) &#123; free(p); (p) = 0; &#125; &#125; while(0)#define CC_SAFE_RELEASE(p) do &#123; if(p) &#123; (p)-&gt;release(); &#125; &#125; while(0)#define CC_SAFE_RELEASE_NULL(p) do &#123; if(p) &#123; (p)-&gt;release(); (p) = 0; &#125; &#125; while(0)#define CC_SAFE_RETAIN(p) do &#123; if(p) &#123; (p)-&gt;retain(); &#125; &#125; while(0)#define CC_BREAK_IF(cond) if(cond) break#define __CCLOGWITHFUNCTION(s, ...) \\ CCLog(\"%s : %s\",__FUNCTION__, CCString::createWithFormat(s, ##__VA_ARGS__)-&gt;getCString())//这个宏定义要注意大小写, 会很容易和cocos2d::CCLog弄错, 因为代码提示的问题.// cocos2d debug#if !defined(COCOS2D_DEBUG) || COCOS2D_DEBUG == 0#define CCLOG(...) do &#123;&#125; while (0)#define CCLOGINFO(...) do &#123;&#125; while (0)#define CCLOGERROR(...) do &#123;&#125; while (0)#define CCLOGWARN(...) do &#123;&#125; while (0)#elif COCOS2D_DEBUG == 1#define CCLOG(format, ...) cocos2d::CCLog(format, ##__VA_ARGS__)#define CCLOGERROR(format,...) cocos2d::CCLog(format, ##__VA_ARGS__)#define CCLOGINFO(format,...) do &#123;&#125; while (0)#define CCLOGWARN(...) __CCLOGWITHFUNCTION(__VA_ARGS__)#elif COCOS2D_DEBUG &gt; 1#define CCLOG(format, ...) cocos2d::CCLog(format, ##__VA_ARGS__)#define CCLOGERROR(format,...) cocos2d::CCLog(format, ##__VA_ARGS__)#define CCLOGINFO(format,...) cocos2d::CCLog(format, ##__VA_ARGS__)#define CCLOGWARN(...) __CCLOGWITHFUNCTION(__VA_ARGS__)#endif // COCOS2D_DEBUG// Lua engine debug#if !defined(COCOS2D_DEBUG) || COCOS2D_DEBUG == 0 || CC_LUA_ENGINE_DEBUG == 0#define LUALOG(...)#else#define LUALOG(format, ...) cocos2d::CCLog(format, ##__VA_ARGS__)#endif // Lua engine debug//定义废弃(deprecated)属性#if defined(__GNUC__) &amp;&amp; ((__GNUC__ &gt;= 4) || ((__GNUC__ == 3) &amp;&amp; (__GNUC_MINOR__ &gt;= 1))) #define CC_DEPRECATED_ATTRIBUTE __attribute__((deprecated))#elif _MSC_VER &gt;= 1400 //vs 2005 or higher #define CC_DEPRECATED_ATTRIBUTE __declspec(deprecated) #else #define CC_DEPRECATED_ATTRIBUTE#endif","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"http://www.young40.com/categories/Cocos2d-x/"},{"name":"Cocos2d-x 源代码研究","slug":"Cocos2d-x/Cocos2d-x-源代码研究","permalink":"http://www.young40.com/categories/Cocos2d-x/Cocos2d-x-源代码研究/"}],"tags":[]},{"title":"2d-x深读1:CCPlatformConfig.h","slug":"2012-12-17-cocos2d-x-source-code-research-1-ccplatformconfig-dot-h","date":"2012-12-16T16:43:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2012/12/17/2012-12-17-cocos2d-x-source-code-research-1-ccplatformconfig-dot-h/","link":"","permalink":"http://www.young40.com/2012/12/17/2012-12-17-cocos2d-x-source-code-research-1-ccplatformconfig-dot-h/","excerpt":"准备好好学习下Cocos2d-x(以下简称2dx), 我正在很努力地学习C++. 作为新手的我, 只能从最基本的代码读起. 就从CCPlatformConfig.h开始研究起吧, 这个文件没有include其他文件, 是最基本的文件. 研究成果见代码.","text":"准备好好学习下Cocos2d-x(以下简称2dx), 我正在很努力地学习C++. 作为新手的我, 只能从最基本的代码读起. 就从CCPlatformConfig.h开始研究起吧, 这个文件没有include其他文件, 是最基本的文件. 研究成果见代码. 版本:cocos2d-2.1beta3-x-2.1.0 路径:cocos2d-2.1beta3-x-2.1.0/cocos2dx/platform CCPlatformConfig.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#ifndef __CC_PLATFORM_CONFIG_H__#define __CC_PLATFORM_CONFIG_H__/** Config of cocos2d-x project, per target platform. *///////////////////////////////////////////////////////////////////////////// pre configure//////////////////////////////////////////////////////////////////////////// define supported target platform macro which CC uses.#define CC_PLATFORM_UNKNOWN 0#define CC_PLATFORM_IOS 1#define CC_PLATFORM_ANDROID 2#define CC_PLATFORM_WIN32 3#define CC_PLATFORM_MARMALADE 4#define CC_PLATFORM_LINUX 5#define CC_PLATFORM_BADA 6#define CC_PLATFORM_BLACKBERRY 7#define CC_PLATFORM_MAC 8//默认是unknown的// Determine target platform by compile environment macro.#define CC_TARGET_PLATFORM CC_PLATFORM_UNKNOWN//CC_TARGET_OS_MAC等是从编译器的环境变量传入的. 参加各编译器或者IDE的预定义宏设置// mac#if defined(CC_TARGET_OS_MAC)#undef CC_TARGET_PLATFORM //先取消定义#define CC_TARGET_PLATFORM CC_PLATFORM_MAC //定义为MAC平台#endif// iphone#if defined(CC_TARGET_OS_IPHONE) #undef CC_TARGET_PLATFORM #define CC_TARGET_PLATFORM CC_PLATFORM_IOS #define CC_SUPPORT_PVRTC //支持prv压缩格式#endif// android#if defined(ANDROID) #undef CC_TARGET_PLATFORM #define CC_TARGET_PLATFORM CC_PLATFORM_ANDROID#endif// win32#if defined(WIN32) &amp;&amp; defined(_WINDOWS) #undef CC_TARGET_PLATFORM #define CC_TARGET_PLATFORM CC_PLATFORM_WIN32#endif// linux#if defined(LINUX) #undef CC_TARGET_PLATFORM #define CC_TARGET_PLATFORM CC_PLATFORM_LINUX#endif// marmalade#if defined(MARMALADE)#undef CC_TARGET_PLATFORM#define CC_TARGET_PLATFORM CC_PLATFORM_MARMALADE#endif// bada#if defined(SHP)#undef CC_TARGET_PLATFORM#define CC_TARGET_PLATFORM CC_PLATFORM_BADA#endif// qnx#if defined(__QNX__) #undef CC_TARGET_PLATFORM #define CC_TARGET_PLATFORM CC_PLATFORM_BLACKBERRY#endif//////////////////////////////////////////////////////////////////////////// post configure////////////////////////////////////////////////////////////////////////////不支持的平台,如果你在上面平台上遇到这个错误, 就可能是预定义变量, 或者编译器的环境变量设置错误// check user set platform#if ! CC_TARGET_PLATFORM #error \"Cannot recognize the target platform; are you targeting an unsupported platform?\"#endif #if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)#pragma warning (disable:4127) //在win32平台不显示4127的warning, 这个具体用法可以参见//http://blog.csdn.net/wowolook/article/details/8060334#endif // CC_PLATFORM_WIN32#endif // __CC_PLATFORM_CONFIG_H__","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"http://www.young40.com/categories/Cocos2d-x/"},{"name":"Cocos2d-x 源代码研究","slug":"Cocos2d-x/Cocos2d-x-源代码研究","permalink":"http://www.young40.com/categories/Cocos2d-x/Cocos2d-x-源代码研究/"}],"tags":[]},{"title":"Cocos2d-x 真是太棒了","slug":"2012-12-14-cocos2d-x-is-awesome","date":"2012-12-13T19:07:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2012/12/14/2012-12-14-cocos2d-x-is-awesome/","link":"","permalink":"http://www.young40.com/2012/12/14/2012-12-14-cocos2d-x-is-awesome/","excerpt":"大概从7月20号左右, 开始决定转向游戏, 首先接触了cocos2d-iphone, 学习了几天. 然后简单了解下就转向了cocos2d-x的学习. 2d-x最令人开心的就是跨平台特性, 经过这段时间的尝试, 感觉跨平台特性确实很强大. 我一般都是在Xcode写代码, 以os x平台做调试, 然后ios平台就不用提了, 直接编译即可.Win和Android下面一般都是直接编译即可. 当然, 因为我对C++也是刚刚开始学习, 所以代码写的不标准, 那么在VS下面会无法通过编译. 主要是体现在一些需要将函数作为参数传入的地方,比较会不容易弄清楚回调函数的参数. Xcode我通通将CCObject *sender作为参数, 而VS要求就非常严格了.","text":"大概从7月20号左右, 开始决定转向游戏, 首先接触了cocos2d-iphone, 学习了几天. 然后简单了解下就转向了cocos2d-x的学习. 2d-x最令人开心的就是跨平台特性, 经过这段时间的尝试, 感觉跨平台特性确实很强大. 我一般都是在Xcode写代码, 以os x平台做调试, 然后ios平台就不用提了, 直接编译即可.Win和Android下面一般都是直接编译即可. 当然, 因为我对C++也是刚刚开始学习, 所以代码写的不标准, 那么在VS下面会无法通过编译. 主要是体现在一些需要将函数作为参数传入的地方,比较会不容易弄清楚回调函数的参数. Xcode我通通将CCObject *sender作为参数, 而VS要求就非常严格了. 在Win上, 我使用VS2012编译, 能很好地支持我现在使用的C++11的一些特性, 比如类似于:1234vector&lt;int&gt; v(1);for (auto i : v)&#123;&#125; 而在Android上, 因为一直没有更新NDK, 版本是r8b, 一直没有办法很好地编译这段代码. 更新为r8c之后,可以编译了.太好了, 我还是很喜欢C++11的这些新的语法糖. 默认是没有启用C++11特性的, 可以在Android.mk中, 添加LOCAL_CPPFLAGS += -std=c++0x来启用这个特性. 作为练习, 我将潘潘的j2me的坦克游戏简单移植到ios上, 简单实现以后, 我转向山寨@胡铠鸥 的PopCube(原版下载)了. 山寨的很彻底, 直接将图片,声音等资源从原版的ipa里面提取出来, 或许游戏资源的保护也应该做的更好一点. 接下来要转向继续开发坦克了, 希望一切顺利.","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.young40.com/categories/杂谈/"}],"tags":[]},{"title":"C++随机数","slug":"2012-12-12-random-number-in-cpp","date":"2012-12-11T21:52:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2012/12/12/2012-12-12-random-number-in-cpp/","link":"","permalink":"http://www.young40.com/2012/12/12/2012-12-12-random-number-in-cpp/","excerpt":"这两天写一个方块消除游戏, 开局的时候就需要随机颜色方块布局. 在调试的时候, 发现似乎有些关卡总是相同的.终于发现了程序第一次打开的时候, 开局总是相同的.","text":"这两天写一个方块消除游戏, 开局的时候就需要随机颜色方块布局. 在调试的时候, 发现似乎有些关卡总是相同的.终于发现了程序第一次打开的时候, 开局总是相同的. rand()可以产生0到之间的伪随机数, 可以利用srand()指定一个无符号整数作为种子. 如果种子相同, 那么产生的伪随机数列相同.默认种子为1, 所以如果不改变种子的话, 获得的随机数列总是相同的. Random123456srand( time(0) );for (int i=0; i&lt;10; ++i)&#123; printf(\"%d\\n\", rand());&#125;","categories":[{"name":"CPP","slug":"CPP","permalink":"http://www.young40.com/categories/CPP/"}],"tags":[]},{"title":"声明和定义的研究","slug":"2012-12-10-declaration-and-definition-in-cpp","date":"2012-12-09T23:35:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2012/12/10/2012-12-10-declaration-and-definition-in-cpp/","link":"","permalink":"http://www.young40.com/2012/12/10/2012-12-10-declaration-and-definition-in-cpp/","excerpt":"最近一直在看C++, 基础的东西瞄了一遍就飘过了, 然后就记不得很清楚了.这两天觉得看书的时候, 对声明和定义的含义很含糊, 以至于都不是很明白书上在说什么地方了.看来有必要对声明和定义重新研究下, 既然架设了这个博客, 那么就写一篇博客吧.","text":"最近一直在看C++, 基础的东西瞄了一遍就飘过了, 然后就记不得很清楚了.这两天觉得看书的时候, 对声明和定义的含义很含糊, 以至于都不是很明白书上在说什么地方了.看来有必要对声明和定义重新研究下, 既然架设了这个博客, 那么就写一篇博客吧. 定义(Definiation)用于给变量分配存储空间, 还可以给变量指定初始值. 变量只能有一个定义. 声明(Declaration)表明变量的类型和名字. 定义也是声明.可以通过extern这种方式来仅声明而不定义变量. Declaration1extern int i; 定义会分配内存空间. 可以多次声明. 好吧, 这篇文章不能称之为研究, 仅仅是从C++ Primer抄下来的而已.","categories":[{"name":"CPP","slug":"CPP","permalink":"http://www.young40.com/categories/CPP/"}],"tags":[]},{"title":"在OS X上折腾OctoPress","slug":"2012-12-09-setup-octopress-on-os-x-10-dot-8","date":"2012-12-09T02:19:00.000Z","updated":"2017-03-14T07:53:34.000Z","comments":true,"path":"2012/12/09/2012-12-09-setup-octopress-on-os-x-10-dot-8/","link":"","permalink":"http://www.young40.com/2012/12/09/2012-12-09-setup-octopress-on-os-x-10-dot-8/","excerpt":"这两天心血来潮, 突然想在github上架设个博客玩玩了, 比较好的两个选择就是OctoPress和Jekyll-Bootstrap.昨天尝试了用Jekyll-Bootstrap, 感觉还不错啦, 我因为没有找到代码高亮的方法, 以及自定义的方法, 就放弃了. 然后今天就尝试OctoPress, 不想op需要ruby 1.9.3, 而OS X 10.8自带的是1.8.7. 果然在执行rake generate的时候出错. 我是有安装homebrew的软件包管理器的, 使用brew安装ruby, 结果Terminal下还是1.8.7.","text":"这两天心血来潮, 突然想在github上架设个博客玩玩了, 比较好的两个选择就是OctoPress和Jekyll-Bootstrap.昨天尝试了用Jekyll-Bootstrap, 感觉还不错啦, 我因为没有找到代码高亮的方法, 以及自定义的方法, 就放弃了. 然后今天就尝试OctoPress, 不想op需要ruby 1.9.3, 而OS X 10.8自带的是1.8.7. 果然在执行rake generate的时候出错. 我是有安装homebrew的软件包管理器的, 使用brew安装ruby, 结果Terminal下还是1.8.7. 然后就学习到有个东西叫做rvm, ruby版本管理器, 允许多个ruby同时安装. 官方的源速度太慢, 所以尝试用sed换成淘宝源, 网上别人给出的sed命令报错, 所以又复习了下vim替换, 全部替换了下. 再接着安装bundler, 报错说RedCloth无法安装.网上搜索了下无果, 注意到中间的时候有个地方提示查看log, 然后发现以这个log为名字的log在系统里面太多了, 也区分不出路径. 索性将所有搜索到的都删除掉. 然后发现RedCloth安装文件需要gcc-4.2, 所以将gcc ln了一个gcc-4.2. 另外, 由于对git不是很熟悉, octopress将主目录作为source分支, 而_deploy目录作为master分支, 为了弄明白这个问题, 我花费了更长的时间.不过也总算是对git的pull, push, branch理解更深入了一点 博客终于跑起来了, 还是非常开心. PS:我再说两点.1.github的服务器有缓存,更新后, 可能需要强制刷新才能看到更新.2.分类是支持中文的, 但rake preview不支持.3.Disqus支持中文, 但是可能需要申请.可以在Disqus设置页面找到申请链接.","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.young40.com/categories/杂谈/"}],"tags":[]}]}