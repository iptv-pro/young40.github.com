<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cocos2d-x | 喜气羊羊]]></title>
  <link href="http://young40.github.com/blog/categories/cocos2d-x/atom.xml" rel="self"/>
  <link href="http://young40.github.com/"/>
  <updated>2013-02-23T21:30:13+08:00</updated>
  <id>http://young40.github.com/</id>
  <author>
    <name><![CDATA[Young40]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基于Pomelo和Cocos2d-x的聊天室]]></title>
    <link href="http://young40.github.com/blog/2013/01/08/chat-of-pomelo-for-cocos2d-x/"/>
    <updated>2013-01-08T00:39:00+08:00</updated>
    <id>http://young40.github.com/blog/2013/01/08/chat-of-pomelo-for-cocos2d-x</id>
    <content type="html"><![CDATA[<p>据说聊天室和游戏系统有很多相似之处, 并且很多游戏本身就带着多人聊天系统. 所以Pomelo将聊天室作为了一个例子.</p>

<p>开源是非常棒的思想和运动, 我简单提两点体会,
1.发现了问题可以不用等官方响应,自己有能力就可以马上修复. 2.你可以贡献自己的代码,很多人都可以贡献代码,可以让项目快速发展.
当然一旦你的代码被接受并被很多人使用, 心中的成就感是不言而喻的.</p>

<p>之所以要提到开源, 是因为今天我们要用到的东西基本上全部是开源的, 并且我们还要对其中的代码做一些修改才能正常工作. 再一次为开源鼓掌!</p>

<p>这并不是一篇Pomelo,或者Cocos2d-x的入门说明, 需要你对这两者都有一定的了解.
同时, 无论是Pomelo还是Cocos2d-x, 我都是新手, 如果文章中有错误的地方, 希望您能不吝指出.
您可以在文章下面留言, 或者在新浪微博上发微薄 @杨世玲
(需要说明的一点是, 请勿私信提问非隐私性技术问题, 我是希望您的问题, 我的或者其他朋友的回复,能被更多朋友搜索到,
我希望我们的交流, 能让更多朋友受到启发, 受益. 这也是对社区和世界和平的一点贡献吧.)</p>

<!--more-->


<p>下面是我们需要使用到的工具及其版本:</p>

<ul>
<li>平台:OS X(10.8.2) Xcode(4.5.2)</li>
<li>Cocos2d-2.1beta3-x-2.1.0</li>
<li>Pomelo https://github.com/NetEase/pomelo</li>
<li>socket.io-clientpp https://github.com/ebshimizu/socket.io-clientpp</li>
<li>websocketpp https://github.com/zaphoyd/websocketpp</li>
<li>Rapidjson https://code.google.com/p/rapidjson/</li>
<li>chatofpomelo https://github.com/NetEase/chatofpomelo</li>
</ul>


<p>查阅本文时请注意版本差异.</p>

<h3>环境配置</h3>

<p>我们的目标是实现OS X, IOS, Android三个平台下的chatofpomelo的Cocos2d-x版本. <br/>
所以需要安装各自平台的开发工具如Xcode,Eclipse,NDK等, 不是本文需要关心的内容. 相信大家也已经轻车熟路了. <br/>
Pomelo的安装 <code>npm install pomelo -g</code>, 如有疑问请查看Pomelo的Wiki. <br/>
websocketpp需要著名的C++库, boost. 我是使用了HomeBrew来安装.
其他安装方式请自省查阅相关文档, 有一点需要指出的是, 必须编译为带有x86(i386)支持lib文件.
因为Cocos2d-x在OS X下是32位的.   <br/>
<code>sh HomeBrew安装boost库
brew install boost --universal
</code>
上面这条命令中<code>--universal</code>即代表编译出来的boost的lib文件同时支持x86和x64.</p>

<h3>项目配置</h3>

<p>Cocos2d-x跨平台无疑做的很好, 但是如果手动创建一个结构良好的跨平台项目,还是一件非常棘手的事. <br/>
幸好我们可以偷懒, 打开Cocos2d-x的源代码, samples目录下面都是已经配置好的跨平台的项目文件.
合理利用, 将事半功倍.</p>

<p>我们将samples目录下HelloCpp复制为ChatOfPomelo,打开找到proj.mac目录下面的<code>HelloCpp.xcodeproj</code>,
可以将其重命名为<code>ChatOfPomelo-Mac.xcodeproj</code>, 以便于和接下来的ios项目有所区分.</p>

<p>在ChatOfPomelo下创建lib目录, 下载socket.io-clientpp和websocketpp并解压到lib目录下面.
并将socket.io-clientpp/lib/rapidjson 复制到lib目录下面.  <br/>
目录结构应该是这样的.
<code>sh 目录
ChatOfPomelo/
├── Classes
├── Resources
├── lib
│   ├── rapidjson
│   ├── socket.io-clientpp
│   └── websocketpp
├── proj.android
├── proj.blackberry
├── proj.ios
├── proj.linux
├── proj.mac
├── proj.marmalade
└── proj.win32
</code>
我们打开proj.mac下的项目文件, 在Xcode中打开项目设置页, 点开Targets的设置.
在Build Settings下面找到<code>Search Paths</code>, 将<code>Always Search User Paths</code>设置为<code>Yes</code>. <br/>
给<code>Header Search Paths</code> 依次添加下面路径:
<code>
/usr/local/include_code
"$(SRCROOT)/../lib/socket.io-clientpp/src"
"$(SRCROOT)/../lib/websocketpp/src"
"$(SRCROOT)/../lib/rapidjson/include"
</code>
如下图所示:
{%img /upload/2013-01/chat-of-pomelo-cocos2d-x-001.png %}</p>

<p>给<code>Library Search Paths</code>添加路径<code>/usr/local/lib</code>. 如下图:
{%img /upload/2013-01/chat-of-pomelo-cocos2d-x-002.png %}</p>

<p>其中<code>/usr/local/include</code>和<code>/usr/local/lib</code>是boost的所在位置(HomeBrew的默认安装位置).
如果你的boost不在上述位置, 请自行更改.</p>

<p>接下来将<code>websocketpp</code>的工程文件添加进来.参见下图:    <br/>
{%img /upload/2013-01/chat-of-pomelo-cocos2d-x-003.png %}</p>

<p>然后打开工程的设置, 在Targets的Build Phases页面,找到<code>Link Binary With Libraries</code>,
添加<code>libwebsocketpp.a</code>, 以及boost的库文件(在/usr/local/lib中找到).     <br/>
<code>sh boost 需要添加的库文件列表
libboost_date_time-mt.a
libboost_graph-mt.a
libboost_random-mt.a
libboost_regex-mt.a
libboost_system-mt.a
libboost_thread-mt.a
libboost_timer-mt.a
</code>
添加的方法参见下图:  <br/>
{%img /upload/2013-01/chat-of-pomelo-cocos2d-x-004.png %}</p>

<h2>文件Hack</h2>

<p>我们在<code>HelloWorldScene.cpp</code>中添加一句<code>#include &lt;socket_io_client.hpp&gt;</code>. <br/>
然后试图运行项目的话, 会看到几处报错(有可能你看到这篇文章的时候相关库文件已经更新了, 没有报错的话, 直接跳过这段即可.) <br/>
报错的是<code>socket_io_client.hpp</code>中的<code>std::function</code>以及<code>std::unique_ptr</code>等.</p>

<p>这是因为这些语句是C++11的新语法. 而如果在Xcode中启用C++11的支持,则Cocos2d-x无法通过编译.
原因有人说是Cocos2d-x不支持C++11, 有人说是OS X自带的libc++库太旧的原因, Xcode4.6中会更新该库.
我是小菜鸟一只, 也分不清谁说的对.</p>

<p>但我们可以通过修改这些代码, 采用boost的API来完成相应的工作.
而websocketpp这个项目又大量采用了boost, 所以修改为boost的API还是挺划算的.</p>

<p>找到<code>socket_io_client.hpp</code>:<br/>
``` cpp socket_io_client.hpp
//typedef std::function<void (socketio_events&, const Value&)> eventFunc;
//修改为
typedef boost::function<void (socketio_events&, const Value&)> eventFunc;</p>

<p>//std::unique_ptr&lt;boost::asio::deadline_timer> m_heartbeatTimer;
//修改为
boost::shared_ptr&lt;boost::asio::deadline_timer> m_heartbeatTimer;
```</p>

<p>找到<code>socket_io_client.cpp</code>:
<code>cpp socket_io_client.cpp
//m_heartbeatTimer = std::unique_ptr&lt;boost::asio::deadline_timer&gt;(new boost::asio::deadline_timer(con-&gt;get_io_service(), boost::posix_time::seconds(0)));
//修改为
m_heartbeatTimer = boost::shared_ptr&lt;boost::asio::deadline_timer&gt;(new boost::asio::deadline_timer(con-&gt;get_io_service(), boost::posix_time::seconds(0)));
</code>
打开<code>lib/rapidjson/include/rapidjson/document.h</code>:
<code>cp document.h
//if (reader.Parse&lt;parseFlags&gt;(is, *this)) {
修改为
if (reader.template Parse&lt;parseFlags&gt;(is, *this)) {"
//这个是jsoncpp的一个bug, 新版本里面已经修复, 但socket_io_client绑定了旧版本, 暂未升级.
</code></p>

<p>这是整个项目应该就可以正常编译运行了. 如果没能正常运行, 你可能在某一步出错了,
可以在下面评论分享下你的问题, 如果已经找到解决办法, 也要把解决方法也贴出来, 分享给大家哦, 亲!</p>

<p>//将socket_io_client, websocketpp的cpp文件引入到项目.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2d-x深读4:CCAutoReleasePool]]></title>
    <link href="http://young40.github.com/blog/2013/01/03/cocos2d-x-source-code-research-4-ccautoreleasepool/"/>
    <updated>2013-01-03T15:09:00+08:00</updated>
    <id>http://young40.github.com/blog/2013/01/03/cocos2d-x-source-code-research-4-ccautoreleasepool</id>
    <content type="html"><![CDATA[<p><code>CCAutoReleasePool.h</code>主要定义了两个类<code>CCAutoReleasePool</code>和<code>CCPoolManager</code>.</p>

<p>其实因为cocos2d-x自动管理内存的原因, 所以, 我们平时很少需要直接使用这两个类.  <br/>
为了探究其中的自动管理内存的机制, 我们直接分析其代码.</p>

<p>总体上来讲, 内存管理这块的机制难度或许比较大. 我研究了一天, 还是有诸多疑问.  <br/>
暂时先放一放, 待我功力进化后再来继续研究这块.</p>

<!--more-->


<ul>
<li>版本:<code>cocos2d-2.1beta3-x-2.1.0</code></li>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/cocoa/CCAutoReleasePool.h</code></li>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/cocoa/CCAutoReleasePool.cpp</code></li>
</ul>


<p>{% include_code CCAutoReleasePool.h lang:cpp  cocos2d-x-research/2.1.1/cocos2dx/cocoa/CCAutoReleasePool.h %}
{% include_code CCAutoReleasePool.cpp lang:cpp  cocos2d-x-research/2.1.1/cocos2dx/cocoa/CCAutoReleasePool.cpp %}</p>

<ul>
<li>参考1: http://4137613.blog.51cto.com/4127613/784134</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2d-x深读3:CCObject]]></title>
    <link href="http://young40.github.com/blog/2012/12/31/cocos2d-x-source-code-research-3-ccobject/"/>
    <updated>2012-12-31T17:21:00+08:00</updated>
    <id>http://young40.github.com/blog/2012/12/31/cocos2d-x-source-code-research-3-ccobject</id>
    <content type="html"><![CDATA[<p>CCObject是绝大部分cocos2d-x类的基类, 我们就从这里一步一步揭开cocos2d-x的奥秘.</p>

<p>CCObject承担了两个重要的功能, 拷贝机制和内存管理.</p>

<h2>拷贝机制</h2>

<p>打开<code>CCObject.h</code> 首先看到的是类CCCopying, 而CCObject是从该类派生. 从这个意义上来讲CCCopying才是大部分类的基类. <br/>
但CCCopying其实非常简单, 再加上没有其他类从CCCopying派生, 所以说CCObject才是大部分类的基类也是不错的. 我认为CCCopying仅仅是一个接口性质.</p>

<p>CCCopying这个类非常简单, 只有一个成员函数copyWithZone(CCZone *pZone); 简单到其实现只是为了报错. 尽管如此, 但其却承担了拷贝机制这一重要的功能.</p>

<p>cocos2d-x和cocos2d-iphone是近亲, 所以cocos2d-x在API上会和cocos2d-iphone保持一致, 代码上也多有借鉴. CCObject明显就有很多NSObject的痕迹.
当然我对Objective-c并不熟悉, 这里都是些猜测罢了. copyWithZone或许就是借鉴了Obj-c.</p>

<p>我们先来看下拷贝机制, 至于CCObject的代码倒不忙着看.</p>

<!--more-->


<p>这两段代码来至于类CCArray, 我们可以看到调用了原对象的copy()来拷贝一份新的CCArray.<br/>
而copy()则定义于CCObject中, 其工作就是调用copyWithZone.</p>

<p>``` cpp CCArray
CCArray<em> CCArray::createWithArray(CCArray</em> otherArray)
{</p>

<pre><code>CCArray* pRet = (CCArray*)otherArray-&gt;copy();
pRet-&gt;autorelease();
return pRet;
</code></pre>

<p>}
/////----------////
CCObject<em> CCArray::copyWithZone(CCZone</em> pZone)
{</p>

<pre><code>CCAssert(pZone == NULL, "CCArray should not be inherited.");
CCArray* pArray = new CCArray();
pArray-&gt;initWithCapacity(this-&gt;data-&gt;num &gt; 0 ? this-&gt;data-&gt;num : 1);

CCObject* pObj = NULL;
CCObject* pTmpObj = NULL;
CCARRAY_FOREACH(this, pObj)
{
    pTmpObj = pObj-&gt;copy();
    pArray-&gt;addObject(pTmpObj);
    pTmpObj-&gt;release();
}
return pArray;
</code></pre>

<p>}
```
这里面牵涉到两个概念, 深拷贝和浅拷贝. 不清楚的大家可以搜索下, 简而言之, 深拷贝才真正的完全拷贝. cocos2d-x实现的是深拷贝. <br/>
我们在上面CCArray::copyWithZone中可以看到拷贝时对array的各个成员也执行了copy()的动作. <br/>
这样才能防止如果obj2是obj1的浅拷贝, 很容易出现array的元素有可能被过早释放的情况.</p>

<p>这里我们还可以一并说下CCZone这个类, 这个类也很简单, 只有一个构造函数和成员变量. <br/>
``` cpp CCZone
class CC_DLL CCZone
{
public:</p>

<pre><code>CCZone(CCObject *pObject = NULL);
</code></pre>

<p>public:</p>

<pre><code>CCObject *m_pCopyObject;
</code></pre>

<p>};
<code>
我想CCZone存在的目的就是为了调用copyWithZone的时候对象传递方便.比如我们还可以看下CCSpeed的copyWithZone函数.   
</code> cpp CCSpeed
CCObject <em>CCSpeed::copyWithZone(CCZone </em>pZone)
{</p>

<pre><code>CCZone* pNewZone = NULL;
CCSpeed* pRet = NULL;
if(pZone &amp;&amp; pZone-&gt;m_pCopyObject) //in case of being called at sub class
{
    pRet = (CCSpeed*)(pZone-&gt;m_pCopyObject);
}
else
{
    pRet = new CCSpeed();
    pZone = pNewZone = new CCZone(pRet);
}
CCAction::copyWithZone(pZone);

pRet-&gt;initWithAction( (CCActionInterval*)(m_pInnerAction-&gt;copy()-&gt;autorelease()) , m_fSpeed );

CC_SAFE_DELETE(pNewZone);
return pRet;
</code></pre>

<p>}
<code>``
我们可以看到构建了一个pZone, 然后调用父类的</code>CCAction::copyWithZone(pZone);`. <br/>
完全是为了copyWithZone方便传递变量而创建的.</p>

<p>拷贝机制看起来有点复杂, 但其实用起来很简单. 我觉得就两点, 1,使用copy()调用 2.各个类对自己的copyWithZone负责.</p>

<h2>内存管理</h2>

<p>cocos2d-x的内存管理采用了引用计数的方法. 曾经看到过有人吐槽其内存管理在多线程下不好用.</p>

<p>CCObject及其子类的对象在创建时, 引用计数默认为1, 每次retain后引用计数加1. 每次release后引用计数减1.
被自动管理的对象引用计数为0时, 会被自动释放.</p>

<p>老G总结的内存管理使用的几点原则(见参考1): <br/>
- 原则1: 谁生成(new, copy)谁负责release. <br/>
- 原则2: 谁retain, 谁负责release.  <br/>
- 原则3: 对于使用了autorelease的对象则不必管他.</p>

<h2>几个常用的函数指针</h2>

<p>当我看到下面这两句的时候, 我完全懵了. <br/>
``` cpp
typedef void (CCObject::*SEL_SCHEDULE)(float);</p>

<h1>define schedule_selector(<em>SELECTOR) (SEL_SCHEDULE)(&amp;</em>SELECTOR)</h1>

<p>```
如果你也对函数指针不熟悉的话, 请翻下相关内容吧.
在这两句里面, 第一句其实是定义了一个返回类型为void的, 名字为SEL_SCHEDULE的, 参数为float的函数指针. <br/>
第二句其实是一个函数类型转换, 将(&amp;_SELECTOR)强制转换成SEL_SCHEDULE类型的函数指针.</p>

<p>通常需要回调函数的时候, 就需要用到这些函数指针. 这里就不再赘述, 以后应该会提及相关知识.</p>

<p>好, 我们接下来直接翻代码吧.</p>

<ul>
<li>版本:<code>cocos2d-2.1beta3-x-2.1.0</code></li>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/cocoa/CCObject.h</code></li>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/cocoa/CCObject.cpp</code></li>
</ul>


<p>{% include_code CCobject.h lang:cpp  cocos2d-x-research/2.1.1/cocos2dx/cocoa/CCObject.h %}
{% include_code CCobject.cpp lang:cpp  cocos2d-x-research/2.1.1/cocos2dx/cocoa/CCObject.cpp %}</p>

<ul>
<li>参考1: http://4137613.blog.51cto.com/4127613/784134</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一步一步CocosBuilder(4)[完结]]]></title>
    <link href="http://young40.github.com/blog/2012/12/29/cocosbuilder-step-by-step-part-four/"/>
    <updated>2012-12-29T10:54:00+08:00</updated>
    <id>http://young40.github.com/blog/2012/12/29/cocosbuilder-step-by-step-part-four</id>
    <content type="html"><![CDATA[<p>这一节也是很轻松, 主要是牵涉到Timeline的切换. 其他的都是简单的界面制作. <br/>
所以CocosBuilder的威力也体现在这里, 很少的代码就能驱动界面了.</p>

<p>我们这次先做<code>Particle System</code>, <code>Scroll View</code>, 最后以<code>Animations</code>收官.</p>

<h5>1</h5>

<p>制作<code>Particle System</code>和<code>Scroll View</code>的界面很简单,我们也是以程序为重点, 所以不再赘述. <br/>
只需要一句<code>this-&gt;openTest("ccb/Scroll.ccbi");</code>就可以调用新的界面了. <br/>
其他诸如绑定之类相信大家已经是轻车熟路啦.</p>

<!--more-->


<p>{% img /upload/2012-12/ccb-sbs-4-001.png %}
{% img /upload/2012-12/ccb-sbs-4-002.png %}</p>

<h5>2</h5>

<p>好吧, 我承认一点, 制作<code>Animations</code>的界面的时候, 我直接复制了例子中的节点. <br/>
5个Timeline, 还是很复杂的, 应该是一个非常精细的工作. 向美术们致敬. <br/>
``` cpp AnimationsLayer.h
class AnimationsLayer
: public cocos2d::CCLayer
, public cocos2d::extension::CCBSelectorResolver
{
public:</p>

<pre><code>AnimationsLayer();
~AnimationsLayer();

CCB_STATIC_NEW_AUTORELEASE_OBJECT_WITH_INIT_METHOD(AnimationsLayer, create);

virtual cocos2d::SEL_MenuHandler onResolveCCBCCMenuItemSelector(CCObject * pTarget, const char* pSelectorName);
virtual cocos2d::extension::SEL_CCControlHandler onResolveCCBCCControlSelector(CCObject * pTarget, const char* pSelectorName);    
void setAnimationManager(cocos2d::extension::CCBAnimationManager *pAnimationManager);

void onIdle(cocos2d::CCObject * pSender, cocos2d::extension::CCControlEvent pCCControlEvent);
void onWave(cocos2d::CCObject * pSender, cocos2d::extension::CCControlEvent pCCControlEvent);
void onJump(cocos2d::CCObject * pSender, cocos2d::extension::CCControlEvent pCCControlEvent);
void onFunky(cocos2d::CCObject * pSender, cocos2d::extension::CCControlEvent pCCControlEvent);
</code></pre>

<p>private:</p>

<pre><code>cocos2d::extension::CCBAnimationManager *mAnimationManager;
</code></pre>

<p>};</p>

<p>class AnimationsLayerLoader : public cocos2d::extension::CCNodeLoader
{
public:</p>

<pre><code>CCB_STATIC_NEW_AUTORELEASE_OBJECT_METHOD(AnimationsLayerLoader, loader);
</code></pre>

<p>protected:</p>

<pre><code>CCB_VIRTUAL_NEW_AUTORELEASE_CREATECCNODE_METHOD(AnimationsLayer);
</code></pre>

<p>};
<code>
</code> cpp AnimationsLayer.cpp
AnimationsLayer::AnimationsLayer()
: mAnimationManager(NULL)
{}</p>

<p>AnimationsLayer::~AnimationsLayer()
{</p>

<pre><code>CC_SAFE_RELEASE_NULL(mAnimationManager);
</code></pre>

<p>}</p>

<p>SEL_MenuHandler AnimationsLayer::onResolveCCBCCMenuItemSelector(cocos2d::CCObject <em>pTarget, const char </em>pSelectorName)
{</p>

<pre><code>return NULL;
</code></pre>

<p>}</p>

<p>SEL_CCControlHandler AnimationsLayer::onResolveCCBCCControlSelector(cocos2d::CCObject <em>pTarget, const char </em>pSelectorName)
{</p>

<pre><code>CCB_SELECTORRESOLVER_CCCONTROL_GLUE(this, "onIdle", AnimationsLayer::onIdle);
CCB_SELECTORRESOLVER_CCCONTROL_GLUE(this, "onJump", AnimationsLayer::onJump);
CCB_SELECTORRESOLVER_CCCONTROL_GLUE(this, "onWave", AnimationsLayer::onWave);
CCB_SELECTORRESOLVER_CCCONTROL_GLUE(this, "onFunky", AnimationsLayer::onFunky);

return NULL;
</code></pre>

<p>}</p>

<p>void AnimationsLayer::setAnimationManager(cocos2d::extension::CCBAnimationManager *pAnimationManager)
{</p>

<pre><code>CC_SAFE_RELEASE_NULL(mAnimationManager);
mAnimationManager = pAnimationManager;
CC_SAFE_RETAIN(mAnimationManager);
</code></pre>

<p>}</p>

<p>void AnimationsLayer::onIdle(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)
{</p>

<pre><code>this-&gt;mAnimationManager-&gt;runAnimationsForSequenceNamedTweenDuration("Idle", 0.3f);
</code></pre>

<p>}</p>

<p>void AnimationsLayer::onJump(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)
{</p>

<pre><code>this-&gt;mAnimationManager-&gt;runAnimationsForSequenceNamedTweenDuration("Jump", 0.3f);
</code></pre>

<p>}</p>

<p>void AnimationsLayer::onWave(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)
{</p>

<pre><code>this-&gt;mAnimationManager-&gt;runAnimationsForSequenceNamedTweenDuration("Wave", 0.3f);
</code></pre>

<p>}</p>

<p>void AnimationsLayer::onFunky(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)
{</p>

<pre><code>this-&gt;mAnimationManager-&gt;runAnimationsForSequenceNamedTweenDuration("Funky", 0.3f);
</code></pre>

<p>}
<code>
整个代码还是很简单. 和以前的几个例子稍微有点不同的是在调用的时候, 需要把`CCBReader`里面的`AnimationManger`传入.   
好, 还是看下调用的代码吧.   
</code> cpp MainScene.cpp
void MainScene::onAnimations(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)
{</p>

<pre><code>const char * pCCBFileName = "ccb/Animations.ccbi";
const char * pCCNodeName = "AnimationsLayer";
cocos2d::extension::CCNodeLoader * pCCNodeLoader = AnimationsLayerLoader::loader();

CCScene *scene = CCScene::create();

CCNodeLoaderLibrary *lib = CCNodeLoaderLibrary::newDefaultCCNodeLoaderLibrary();

lib-&gt;registerCCNodeLoader("HeaderLayer", HeaderLayerLoader::loader());

if (pCCNodeName!=NULL &amp;&amp; pCCNodeLoader!=NULL)
{
    lib-&gt;registerCCNodeLoader(pCCNodeName, pCCNodeLoader);
}

CCBReader *reader = new CCBReader(lib);
CCNode *node = reader-&gt;readNodeGraphFromFile(pCCBFileName, this);
reader-&gt;autorelease();

if (node != NULL)
{
    //获取AnimationManger 并传给AnimationsLayer
    ((AnimationsLayer*)node) -&gt;setAnimationManager(reader-&gt;getAnimationManager());

    scene-&gt;addChild(node);
}

this-&gt;mTitleLabelTTF-&gt;setString(pCCBFileName);

CCDirector::sharedDirector()-&gt;pushScene(scene);
</code></pre>

<p>}
```</p>

<p>{% img /upload/2012-12/ccb-sbs-4-003.png %}</p>

<h3>后记</h3>

<p>看到微博上@做游戏的老G 吐槽说CocosBuilder如何不好用, 学习难度比较大. 我也是很认可这一点. <br/>
但是只要是坚持把TestCpp例子完全读完了, 相信掌握CocosBuilder也是很快能够做到的. <br/>
既然你看完了这个教程. 相信你也已经能够很好地驾驭CocosBuilder. 关键还在实践呦!</p>

<p>微博上@Ghost_233 说了一个很好的思路, 直接从ccb文件中生成对应的C++类, 而且他还做了一些实践. <br/>
我暂时还没有研究他的代码, 不过肯定是可行. 这是一个很赞的思路. <br/>
希望大家能动手, 最好合作出来一个较好的工具来, 我想, 是不是集成到CocosBuilder会更好?</p>

<p>谢谢大家耐心看完我的文章.</p>

<p>{% render_partial _posts/cocosbuilder-step-by-step-footer.markdown %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一步一步CocosBuilder(3)]]></title>
    <link href="http://young40.github.com/blog/2012/12/28/cocosbuilder-step-by-step-part-three/"/>
    <updated>2012-12-28T00:54:00+08:00</updated>
    <id>http://young40.github.com/blog/2012/12/28/cocosbuilder-step-by-step-part-three</id>
    <content type="html"><![CDATA[<p>今天要说的内容比较轻松, 重要的知识点不多. <br/>
目标是实现<code>Menus &amp; Items</code>, <code>Sprites &amp; 9 Slice</code>, <code>Buttons &amp; Labels</code>.</p>

<h5>1</h5>

<p>首先我们在CocosBuilder中建立一个新的<code>Header.ccb</code>.具体请参见CocosBuilder的项目.   <br/>
在创建的时候,勾选<code>Full Sceen</code>, 并且将分辨率的<code>Height</code>都修改为40. <br/>
这个文件很简单, 根节点下只包含一个<code>CCLayerColor</code>,根节点的<code>Custom class</code>设置为<code>HeaderLayer</code>. <br/>
<code>CCLayerColor</code>下面包含一个<code>CCLabelTTF</code>和<code>CCMenu</code>. <br/>
<code>CCLabelTTF</code>的变量绑定为类型<code>Owner var</code>, 值为<code>mTitleLabelTTF</code>. <br/>
<code>CCMenu</code>包含一个<code>CCMenuItemImage</code>. <code>CCMenuItemImage</code>的<code>Selector</code>属性设置为<code>onBackClicked</code>.    <br/>
这个ccb作为一个公用的元素被其他ccb文件所引用. 是属于模块化的一个例子. <br/>
然后我们在Xcode中新建一个<code>HeaderLayer</code>类, 并同时声明一个<code>HeaderLayerLoader</code>类.</p>

<!--more-->


<p>``` cpp HeaderLayer.h
class HeaderLayer
: public cocos2d::CCLayer
, public cocos2d::extension::CCBSelectorResolver
{
public:</p>

<pre><code>CCB_STATIC_NEW_AUTORELEASE_OBJECT_WITH_INIT_METHOD(HeaderLayer, create);

virtual cocos2d::SEL_MenuHandler onResolveCCBCCMenuItemSelector(CCObject * pTarget, const char* pSelectorName);
virtual cocos2d::extension::SEL_CCControlHandler onResolveCCBCCControlSelector(CCObject * pTarget, const char* pSelectorName);

void onBackClicked(CCObject *pSender);
</code></pre>

<p>};</p>

<p>class HeaderLayerLoader : public cocos2d::extension::CCLayerLoader
{
public:</p>

<pre><code>CCB_STATIC_NEW_AUTORELEASE_OBJECT_METHOD(HeaderLayerLoader, loader);
</code></pre>

<p>protected:</p>

<pre><code>CCB_VIRTUAL_NEW_AUTORELEASE_CREATECCNODE_METHOD(HeaderLayer);
</code></pre>

<p>};
<code>
</code> cpp HeaderLayer.cpp
SEL_MenuHandler HeaderLayer::onResolveCCBCCMenuItemSelector(cocos2d::CCObject <em>pTarget, const char </em>pSelectorName)
{</p>

<pre><code>CCB_SELECTORRESOLVER_CCMENUITEM_GLUE(this, "onBackClicked", HeaderLayer::onBackClicked);

return NULL;
</code></pre>

<p>}</p>

<p>SEL_CCControlHandler HeaderLayer::onResolveCCBCCControlSelector(cocos2d::CCObject <em>pTarget, const char </em>pSelectorName)
{</p>

<pre><code>return NULL;
</code></pre>

<p>}</p>

<p>void HeaderLayer::onBackClicked(cocos2d::CCObject *pSender)
{</p>

<pre><code>CCDirector::sharedDirector()-&gt;popScene();
</code></pre>

<p>}
```</p>

<h5>2</h5>

<p>在CocosBuilder中新建一个<code>Menus.ccb</code>, 并将根节点<code>Custom class</code>设置为<code>MenuLayer</code>. <br/>
再加入几个<code>CCMenuItemImage</code>, Selector分别设置为<code>onPressA</code>, <code>onPressB</code>, <code>onPressC</code>. <br/>
再加入一个<code>CCLabelBMFont</code>, 绑定<code>Doc root var</code>, 值为<code>mMessageLabelBMFont</code>. <br/>
在Xcode中新建一个类<code>MenuLayer</code>, 并且在<code>MenuLayer.h</code>中同时声明一个<code>MenuLayerLoader</code>类. <br/>
``` cpp MenuLayer.h
class MenuLayer
: public cocos2d::CCLayer
, public cocos2d::extension::CCBMemberVariableAssigner
, public cocos2d::extension::CCBSelectorResolver
{
public:</p>

<pre><code>MenuLayer();
~MenuLayer();

CCB_STATIC_NEW_AUTORELEASE_OBJECT_WITH_INIT_METHOD(MenuLayer, create);

virtual bool onAssignCCBMemberVariable(CCObject* pTarget, const char* pMemberVariableName, CCNode* pNode);
virtual cocos2d::SEL_MenuHandler onResolveCCBCCMenuItemSelector(CCObject * pTarget, const char* pSelectorName);
virtual cocos2d::extension::SEL_CCControlHandler onResolveCCBCCControlSelector(CCObject * pTarget, const char* pSelectorName);

void onPressA(cocos2d::CCObject *pSender);
void onPressB(cocos2d::CCObject *pSender);
void onPressC(cocos2d::CCObject *pSender);
</code></pre>

<p>private:</p>

<pre><code>cocos2d::CCLabelBMFont *mMessageLabelBMFont;
</code></pre>

<p>};</p>

<p>class MenuLayerLoader : public cocos2d::extension::CCNodeLoaderLibrary
{
public:</p>

<pre><code>CCB_STATIC_NEW_AUTORELEASE_OBJECT_METHOD(MenuLayerLoader, loader);
</code></pre>

<p>protected:</p>

<pre><code>CCB_VIRTUAL_NEW_AUTORELEASE_CREATECCNODE_METHOD(MenuLayer);    
</code></pre>

<p>};
<code>
</code> cpp MenuLayer.cpp
MenuLayer::MenuLayer()
: mMessageLabelBMFont(NULL)
{}</p>

<p>MenuLayer::~MenuLayer()
{</p>

<pre><code>CC_SAFE_DELETE(mMessageLabelBMFont);
</code></pre>

<p>}</p>

<p>bool MenuLayer::onAssignCCBMemberVariable(cocos2d::CCObject <em>pTarget, const char </em>pMemberVariableName, cocos2d::CCNode *pNode)
{</p>

<pre><code>CCB_MEMBERVARIABLEASSIGNER_GLUE(this, "mMessageLabelBMFont", CCLabelBMFont*, this-&gt;mMessageLabelBMFont);
return false;
</code></pre>

<p>}</p>

<p>SEL_MenuHandler MenuLayer::onResolveCCBCCMenuItemSelector(cocos2d::CCObject <em>pTarget, const char </em>pSelectorName)
{</p>

<pre><code>CCB_SELECTORRESOLVER_CCMENUITEM_GLUE(this, "onPressA", MenuLayer::onPressA);
CCB_SELECTORRESOLVER_CCMENUITEM_GLUE(this, "onPressB", MenuLayer::onPressB);
CCB_SELECTORRESOLVER_CCMENUITEM_GLUE(this, "onPressC_NO_Match", MenuLayer::onPressC);
</code></pre>

<p>   //注意这里, 我们给第三个绑定了一个不存在的SelectorName.</p>

<pre><code>return NULL;
</code></pre>

<p>}</p>

<p>SEL_CCControlHandler MenuLayer::onResolveCCBCCControlSelector(cocos2d::CCObject <em>pTarget, const char </em>pSelectorName)
{</p>

<pre><code>return NULL;
</code></pre>

<p>}</p>

<p>void MenuLayer::onPressA(cocos2d::CCObject *pSender)
{</p>

<pre><code>this-&gt;mMessageLabelBMFont-&gt;setString("A pressed.");
</code></pre>

<p>}</p>

<p>void MenuLayer::onPressB(cocos2d::CCObject *pSender)
{</p>

<pre><code>this-&gt;mMessageLabelBMFont-&gt;setString("B pressed.");
</code></pre>

<p>}</p>

<p>void MenuLayer::onPressC(cocos2d::CCObject *pSender)
{</p>

<pre><code>this-&gt;mMessageLabelBMFont-&gt;setString("C pressed.");
</code></pre>

<p>}
```</p>

<h5>3</h5>

<p>或许有点着急了吧, 我们如何让这个运行起来呢?  <br/>
首先给<code>MainScene</code>增加一个新函数的声明及定义, 还需要增加一个变量用于和<code>Header.ccb</code>中的<code>mTitleLabelTTF</code>绑定. <br/>
``` cpp MainScene.h
public:</p>

<pre><code>void openTest(const char * pCCBFileName, const char * pCCNodeName = NULL, cocos2d::extension::CCNodeLoader * pCCNodeLoader = NULL);
</code></pre>

<p>private:</p>

<pre><code>cocos2d::CCLabelTTF *mTitleLabelTTF;
</code></pre>

<p><code>
</code> cpp MainScene.cpp
void MainScene::openTest(const char * pCCBFileName, const char * pCCNodeName, cocos2d::extension::CCNodeLoader * pCCNodeLoader)
{</p>

<pre><code>CCScene *scene = CCScene::create();

CCNodeLoaderLibrary *lib = CCNodeLoaderLibrary::newDefaultCCNodeLoaderLibrary();

lib-&gt;registerCCNodeLoader("HeaderLayer", HeaderLayerLoader::loader());
lib-&gt;registerCCNodeLoader(pCCNodeName, pCCNodeLoader);

CCBReader *reader = new CCBReader(lib);
CCNode *node = reader-&gt;readNodeGraphFromFile(pCCBFileName, this);
reader-&gt;autorelease();

if (node != NULL)
{
    scene-&gt;addChild(node);
}

this-&gt;mTitleLabelTTF-&gt;setString(pCCBFileName);

CCDirector::sharedDirector()-&gt;pushScene(scene);
</code></pre>

<p>}</p>

<p>bool MainScene::onAssignCCBMemberVariable(cocos2d::CCObject <em>pTarget, const char </em>pMemberVariableName, cocos2d::CCNode *pNode)
{</p>

<pre><code>CCB_MEMBERVARIABLEASSIGNER_GLUE(this, "mLabelText", CCLabelBMFont*, this-&gt;mLabelText);
CCB_MEMBERVARIABLEASSIGNER_GLUE(this, "mTitleLabelTTF", CCLabelTTF*, this-&gt;mTitleLabelTTF);

return false;
</code></pre>

<p>}
void MainScene::onButtonTest(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)
{</p>

<pre><code>this-&gt;openTest("ccb/Menus.ccbi", "MenuLayer", MenuLayerLoader::loader());
</code></pre>

<p>}
```</p>

<h5>4</h5>

<p><code>Sprites &amp; 9 Slice</code> 这个比较简单, 只是靠CocosBuilder就能完成任务了.</p>

<p>{% img /upload/2012-12/ccb-sbs-3-001.png %}</p>

<p>我拼的不太好, 嘿嘿. 主要是着重代码, 并非设计, 漂亮的事情交给美术妹纸吧.</p>

<h5>5</h5>

<p><code>Buttons</code>这块主要是研究了<code>CCControlEvent</code>的各种情况. 我们只贴出核心代码. <br/>
``` cpp ButtonsLayer.cpp
void ButtonsLayer::onBtnClicked(cocos2d::CCObject *pSender, cocos2d::extension::CCControlEvent pCCControlEvent)
{</p>

<pre><code>switch (pCCControlEvent) {
    case CCControlEventTouchCancel:
        this-&gt;mEventLabelBMFont-&gt;setString("Cancel");
        break;
    case CCControlEventTouchDown:
        this-&gt;mEventLabelBMFont-&gt;setString("Touch Down");
        break;
    case CCControlEventTouchDragEnter:
        this-&gt;mEventLabelBMFont-&gt;setString("Drag Enter");
        break;
    case CCControlEventTouchDragExit:
        this-&gt;mEventLabelBMFont-&gt;setString("Drag Exit");
        break;
    case CCControlEventTouchDragInside:
        this-&gt;mEventLabelBMFont-&gt;setString("Drag Inside");
        break;
    case CCControlEventTouchDragOutside:
        this-&gt;mEventLabelBMFont-&gt;setString("Drag OutSide");
        break;
    case CCControlEventTouchUpInside:
        this-&gt;mEventLabelBMFont-&gt;setString("Up Inside");
        break;
    case CCControlEventTouchUpOutside:
        this-&gt;mEventLabelBMFont-&gt;setString("Up Outside");
        break;
    default://所有的定义都在上面了,TestCPP里面有句经典的点评, 想看的可以去翻一下.
        break;
}
</code></pre>

<p>}
```</p>

<p>{% img /upload/2012-12/ccb-sbs-3-002.png %}</p>

<p>{% render_partial _posts/cocosbuilder-step-by-step-footer.markdown %}</p>
]]></content>
  </entry>
  
</feed>
