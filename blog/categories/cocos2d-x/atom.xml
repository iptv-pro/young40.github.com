<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cocos2d-x | 喜气羊羊]]></title>
  <link href="http://young40.github.com/blog/categories/cocos2d-x/atom.xml" rel="self"/>
  <link href="http://young40.github.com/"/>
  <updated>2012-12-21T03:06:59+08:00</updated>
  <id>http://young40.github.com/</id>
  <author>
    <name><![CDATA[Young40]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一步一步CocosBuilder(1)]]></title>
    <link href="http://young40.github.com/blog/2012/12/21/cocosbuilder-step-by-step-part-one/"/>
    <updated>2012-12-21T02:46:00+08:00</updated>
    <id>http://young40.github.com/blog/2012/12/21/cocosbuilder-step-by-step-part-one</id>
    <content type="html"><![CDATA[<p>CocosBuilder是Cocos2d系列的配套开源工具,最新的版本是3.0a, 也是我们这个系列文章所采用的版本.
CCB(CocosBuilder简称)目前只有OS X版本, 没有Windows的版本, 而且源代码也是用Objective-c, 估计移植难度会比较大.
我想这个也是其不够流行的原因吧.</p>

<p>如果你是CCB的熟客,那么你一定会记得CCB v2.x以前版本附带的例子. 而CCB v3.0采用了一个叫做CocosDragonJS的例子, 主要是展示CCB的Javascript的调用能力.
我虽然很喜欢JS, 但是正在学习2d-x, 又很想学好, 所以还是打好基础, 学好原滋原味的2d-x才好, 以后换用无论是Html5, 还是JS, Lua, 心里才会觉得踏实.
我无论C++,还是2d-x都是新手,又是第一次想正儿八经的写博客文章, 难免有很多错误, 还望各位看客踊跃拍砖.</p>

<p>这次的目的是基本实现原来v2.0中的例子.
我采用的2d-x的版本是:cocos2d-2.1beta3-x-2.1.0, 以OS X版本为主, 以sample目录下的HelloCpp为基础改进. CCB的版本是v3.0alpha0.</p>

<!--more-->


<p>本文的目标是基本实现将CCB整合进Mac OS X版本的项目中.</p>

<p>首先将2d-x源代码中sample目录下的HelloCpp目录重命名为TestCocosBuilder.并使用CocosBuilder创建新项目文件在其Resources文件夹中.
还需要将项目需要的图片资源放入Resources目录中. 具体可以参见我打包后的整体项目文件.还可以参见文末的目录树说明.</p>

<p>贴下Xcode项目的目录,如果添加extensions应该逐个添加,否则可能会遇到编译错误,有可能会把其他平台文件错误添加进来.</p>

<p><img src="/upload/2012-12/ccb-sbs-1-001.png"></p>

<p>做完这些准备工作后, 我们接下来按步来讲解.</p>

<p>1.首先编辑下<code>AppMacros.h</code>, 修改以下代码
<code>cpp AppMacros.h
static Resource smallResource  =  { cocos2d::CCSizeMake(480, 320),   "resources-iphone" };
static Resource mediumResource =  { cocos2d::CCSizeMake(1024, 768),  "resources-ipad"   };
static Resource largeResource  =  { cocos2d::CCSizeMake(2048, 1536), "resources-ipadhd" };
</code>
这一段主要是修改<code>HelloCpp</code>默认的资源目录, 配合CCB的发布路径.同时可以将原来几个目录中文件分别移入对应目录.
2.添加一个新类<code>MainScene</code>如下
``` cpp MainScene.h</p>

<h1>ifndef <strong>HelloCpp</strong>MainScene__</h1>

<h1>define <strong>HelloCpp</strong>MainScene__</h1>

<h1>include "cocos2d.h"</h1>

<h1>include "cocos-ext.h"</h1>

<p>class MainScene
: public cocos2d::CCLayer //从CCLayer派生
{
public:</p>

<pre><code>static cocos2d::CCScene* scene();
</code></pre>

<p>};</p>

<h1>endif /<em> defined(<strong>HelloCpp</strong>MainScene__) </em>/</h1>

<p>```</p>

<p>``` cpp MainScene.cpp</p>

<h1>include "MainScene.h"</h1>

<p>USING_NS_CC;
USING_NS_CC_EXT;</p>

<p>CCScene* MainScene::scene()
{</p>

<pre><code>CCScene *scene = CCScene::create();

CCNodeLoaderLibrary *lib = CCNodeLoaderLibrary::newDefaultCCNodeLoaderLibrary(); //生成一个默认的Node Loader

CCBReader *reader = new CCBReader(lib); //用node load lib 初始化一个ccb reader

CCNode *node = reader-&gt;readNodeGraphFromFile("MainScene.ccbi", scene); //从ccbi文件中加载node

reader-&gt;release(); //注意手动释放内存

if (node!=NULL)
{
    scene-&gt;addChild(node); //将node 添加到scene中
}

return scene;
</code></pre>

<p>}
<code>
3.修改`AppDelegate.cpp`中默认的启动scene
</code> cpp
CCScene *pScene = MainScene::scene(); //HelloWorld::scene();
```
4.注意CCB中发布选项的设置, 并发布一次.
<img src="/upload/2012-12/ccb-sbs-1-002.png"></p>

<p>5.如果没有错误的话, 你应该可以看到运行的效果.
<img src="/upload/2012-12/ccb-sbs-1-003.png"></p>

<p><code>sh 目录结构
├── samples #目录结构和2d-x源代码保持一致,相信大家对2d-x源代码很熟悉了.
│   └── CocosBuilderTest #项目所在目录
│       ├── Classes #代码所在目录
│       ├── Resources #资源目录
│       │   ├── ccb #ccb发布后的目录
│       │   │   ├── HelloCocosBuilder.ccbi
│       │   │   ├── ...
│       │   │   └── TestSprites.ccbi
│       │   ├── ccbResources #发布后的默认ccb资源
│       │   ├── fonts
│       │   ├── resources-ipad #注意这几个目录, 稍后我们会提及
│       │   ├── resources-ipadhd
│       │   ├── resources-iphone
│       │   ├── resources-iphonehd
│       ├── ccb-source #ccb项目目录
│       │   ├── ccb
│       │   │   ├── HelloCocosBuilder.ccb #这几个是原CocosBuilder例子中的ccb, 直接复制过来了.
│       │   │   ├── ...
│       │   │   └── TestSprites.ccbi
│       │   ├── ccbResources
│       │   ├── resources-auto #CocosBuilderv3.0的资源目录, 似乎只能存放图片
│       │   │   ├── btn-a-0.png #否则会引起发布是造成CocosBuilder崩溃
│       │   │   ├── ...
│       │   │   └── scale-9-demo.png
│       │   ├── MainScene.ccb #默认生成的ccb, 我们这一次不对其更改
│       │   ├── MainScene.js
│       │   ├── animated-grossini.plist
│       │   ├── animated-grossini.png
│       │   ├── ccb-source.ccbproj
│       │   ├── comic\ andy.ttf
│       │   ├── grossini-generic.plist
│       │   ├── grossini-generic.png
│       │   ├── markerfelt24shadow.fnt
│       │   └── markerfelt24shadow.png
│       └── proj.mac
│           ├── HelloCpp.xcodeproj #项目文件, 暂时只支持mac os x
├── cocos2dx #2d-x文件
├── extensions #2d-x的扩展
│   ├── CCBReader #这个是解析CocosBuilder的主要CCBReader
│   │   ├── CCBAnimationManager.cpp
│   │   ├── CCBAnimationManager.h
│   │   ├── ...
│   │   └── CCSpriteLoader.h
│   ├── GUI
│   ├── network
│   ├── physics_nodes
│   ├── ExtensionMacros.h
│   └── cocos-ext.h
</code></p>

<p>代码打包下载:<a href="http://pan.baidu.com/share/link?shareid=158075&uk=2281999082" target="_blank">下载点</a></p>

<ul>
<li>本文是系列文章, 请查看其他文章:</li>
<li><a href="http://young40.github.com/blog/2012/12/21/cocosbuilder-step-by-step-part-one/">一步一步CocosBuilder(1)</a></li>
</ul>


<p>谢谢您耐心看完此文, 希望能对您有些帮助.如果有什么问题, 意见, 建议, 拍砖, 欢迎留言或者联系我.</p>

<p>新浪微博: <a href="http://weibo.com/young40">@杨世玲</a> <a href="http://weibo.com/young40">http://weibo.com/young40</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2d-x深读2:CCPlatformMacros.h]]></title>
    <link href="http://young40.github.com/blog/2012/12/17/cocos2d-x-source-code-research-2-ccplatformmacros-dot-h/"/>
    <updated>2012-12-17T01:49:00+08:00</updated>
    <id>http://young40.github.com/blog/2012/12/17/cocos2d-x-source-code-research-2-ccplatformmacros-dot-h</id>
    <content type="html"><![CDATA[<ul>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/include/ccConfig.h</code></li>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/platform/mac/CCPlatformDefine.h</code> //注意我是以mac平台研究的, 其他平台略有不同</li>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/platform/CCPlatformMacros.h</code></li>
</ul>


<!--more-->


<p>``` cpp ccConfig.h</p>

<h1>include "platform/CCPlatformConfig.h"</h1>

<p>//设置为1后会include CCPhysicsScript 和 CCPhysicsDebugNode 添加到物理引擎支持
//需要保证Chipmunk在搜索路径中</p>

<h1>ifndef CC_ENABLE_CHIPMUNK_INTEGRATION</h1>

<h1>define CC_ENABLE_CHIPMUNK_INTEGRATION 0</h1>

<h1>endif</h1>

<p>//设置为1后会include CCPhysicsScript 添加到Box2D的支持
//同样需要保证Box2D会在搜索路径中</p>

<h1>ifndef CC_ENABLE_BOX2D_INTEGRATION</h1>

<h1>define CC_ENABLE_BOX2D_INTEGRATION 0</h1>

<h1>endif</h1>

<p>/**
 设置为1后,2d学会维护一个OpenGL状态缓存来避免不必要的切换
 为了使用这个功能,需要用下列函数来替换GL的对应函数</p>

<pre><code>- ccGLUseProgram() instead of glUseProgram()
- ccGLDeleteProgram() instead of glDeleteProgram()
- ccGLBlendFunc() instead of glBlendFunc()
</code></pre>

<p>如果这个功能被禁止, 那么这些函数会直接调用对应的GL函数, 当然就没有缓存了
打开这个功能能提高速度
如果你的代码是从GL ES 1.1升级过来的, 保持这个功能被禁用. 如果各种功能正常的话, 你可以启用这个功能</p>

<h1>ifndef CC_ENABLE_GL_STATE_CACHE</h1>

<h1>define CC_ENABLE_GL_STATE_CACHE 1</h1>

<h1>endif</h1>

<p>/<em><em>
启用后,纹理的坐标会用这个公式来计算
- texCoord.left = (rect.origin.x</em>2+1) / (texture.wide</em>2);
- texCoord.right = texCoord.left + (rect.size.width<em>2-2)/(texture.wide</em>2);</p>

<p>The same for bottom and top.</p>

<p>This formula prevents artifacts by using 99% of the texture.
The "correct" way to prevent artifacts is by using the spritesheet-artifact-fixer.py or a similar tool.</p>

<p>受影响的类:
- CCSprite / CCSpriteBatchNode and subclasses: CCLabelBMFont, CCTMXTiledMap
- CCLabelAtlas
- CCQuadParticleSystem
- CCTileMap
*/</p>

<h1>ifndef CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL</h1>

<h1>define CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL 0</h1>

<h1>endif</h1>

<p>//默认0.5秒, 更新下FPS的数据. 数字越大FPS数据越可靠.</p>

<h1>ifndef CC_DIRECTOR_STATS_INTERVAL</h1>

<h1>define CC_DIRECTOR_STATS_INTERVAL (0.5f)</h1>

<h1>endif</h1>

<p>//FPS数据显示位置,默认左下</p>

<h1>ifndef CC_DIRECTOR_FPS_POSITION</h1>

<h1>define CC_DIRECTOR_FPS_POSITION ccp(0,0)</h1>

<h1>endif</h1>

<p>/** @def CC_DIRECTOR_DISPATCH_FAST_EVENTS
 If enabled, and only when it is used with CCFastDirector, the main loop will wait 0.04 seconds to
 dispatch all the events, even if there are not events to dispatch.
 If your game uses lot's of events (eg: touches) it might be a good idea to enable this feature.
 Otherwise, it is safe to leave it disabled.</p>

<p> To enable set it to 1. Disabled by default.</p>

<p> @warning This feature is experimental
 */</p>

<h1>ifndef CC_DIRECTOR_DISPATCH_FAST_EVENTS</h1>

<p> #define CC_DIRECTOR_DISPATCH_FAST_EVENTS 0</p>

<h1>endif</h1>

<p>/** @def CC_DIRECTOR_MAC_USE_DISPLAY_LINK_THREAD
If enabled, cocos2d-mac will run on the Display Link thread. If disabled cocos2d-mac will run in its own thread.</p>

<p>If enabled, the images will be drawn at the "correct" time, but the events might not be very responsive.
If disabled, some frames might be skipped, but the events will be dispatched as they arrived.</p>

<p>To enable set it to a 1, to disable it set to 0. Enabled by default.</p>

<p>Only valid for cocos2d-mac. Not supported on cocos2d-ios.</p>

<p>*/</p>

<h1>ifndef CC_DIRECTOR_MAC_USE_DISPLAY_LINK_THREAD</h1>

<h1>define CC_DIRECTOR_MAC_USE_DISPLAY_LINK_THREAD 1</h1>

<h1>endif</h1>

<p>/** @def CC_NODE_RENDER_SUBPIXEL
 If enabled, the CCNode objects (CCSprite, CCLabel,etc) will be able to render in subpixels.
 If disabled, integer pixels will be used.</p>

<p> To enable set it to 1. Enabled by default.
 */</p>

<h1>ifndef CC_NODE_RENDER_SUBPIXEL</h1>

<h1>define CC_NODE_RENDER_SUBPIXEL 1</h1>

<h1>endif</h1>

<p>/** @def CC_SPRITEBATCHNODE_RENDER_SUBPIXEL
 If enabled, the CCSprite objects rendered with CCSpriteBatchNode will be able to render in subpixels.
 If disabled, integer pixels will be used.</p>

<p> To enable set it to 1. Enabled by default.
 */</p>

<h1>ifndef CC_SPRITEBATCHNODE_RENDER_SUBPIXEL</h1>

<h1>define CC_SPRITEBATCHNODE_RENDER_SUBPIXEL    1</h1>

<h1>endif</h1>

<p>/** @def CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP
 Use GL_TRIANGLE_STRIP instead of GL_TRIANGLES when rendering the texture atlas.
 It seems it is the recommend way, but it is much slower, so, enable it at your own risk</p>

<p> To enable set it to a value different than 0. Disabled by default.</p>

<p> */</p>

<h1>ifndef CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP</h1>

<h1>define CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP 0</h1>

<h1>endif</h1>

<p>//VAO定点数组对象
/** @def CC_TEXTURE_ATLAS_USE_VAO
 By default, CCTextureAtlas (used by many cocos2d classes) will use VAO (Vertex Array Objects).
 Apple recommends its usage but they might consume a lot of memory, specially if you use many of them.
 So for certain cases, where you might need hundreds of VAO objects, it might be a good idea to disable it.</p>

<p> To disable it set it to 0. Enabled by default.</p>

<p> */</p>

<h1>ifndef CC_TEXTURE_ATLAS_USE_VAO</h1>

<pre><code>#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS) || (CC_TARGET_PLATFORM == CC_PLATFORM_MAC)
    #define CC_TEXTURE_ATLAS_USE_VAO 1
#else
    /* Some Windows display adapter driver cannot support VAO. */
    /* Some android devices cannot support VAO very well, so we disable it by default for android platform. */
    /* Blackberry also doesn't support this feature. */
    #define CC_TEXTURE_ATLAS_USE_VAO 0
#endif
</code></pre>

<h1>endif</h1>

<p>/** @def CC_USE_LA88_LABELS
 If enabled, it will use LA88 (Luminance Alpha 16-bit textures) for CCLabelTTF objects.
 If it is disabled, it will use A8 (Alpha 8-bit textures).
 LA88 textures are 6% faster than A8 textures, but they will consume 2x memory.</p>

<p> This feature is enabled by default.</p>

<p> @since v0.99.5
 */</p>

<h1>ifndef CC_USE_LA88_LABELS</h1>

<h1>define CC_USE_LA88_LABELS 1</h1>

<h1>endif</h1>

<p>/<em>*
  启用后,所有CCSprite的子类都会花上一个边框,方便调试
 0 -- disabled
 1 -- draw bounding box
 2 -- draw texture box
</em>/</p>

<h1>ifndef CC_SPRITE_DEBUG_DRAW</h1>

<h1>define CC_SPRITE_DEBUG_DRAW 0</h1>

<h1>endif</h1>

<p>//CCSpriteBatchNode的调试用加边框</p>

<h1>ifndef CC_SPRITEBATCHNODE_DEBUG_DRAW</h1>

<h1>define CC_SPRITEBATCHNODE_DEBUG_DRAW 0</h1>

<h1>endif</h1>

<p>//CCLabelBMFont调试加边框</p>

<h1>ifndef CC_LABELBMFONT_DEBUG_DRAW</h1>

<h1>define CC_LABELBMFONT_DEBUG_DRAW 0</h1>

<h1>endif</h1>

<p>//LabeltAtlas调试加边框</p>

<h1>ifndef CC_LABELATLAS_DEBUG_DRAW</h1>

<h1>define CC_LABELATLAS_DEBUG_DRAW 0</h1>

<h1>endif</h1>

<p>/** @def CC_ENABLE_PROFILERS
 If enabled, will activate various profilers within cocos2d. This statistical data will be output to the console
 once per second showing average time (in milliseconds) required to execute the specific routine(s).
 Useful for debugging purposes only. It is recommended to leave it disabled.</p>

<p> To enable set it to a value different than 0. Disabled by default.
 */</p>

<h1>ifndef CC_ENABLE_PROFILERS</h1>

<h1>define CC_ENABLE_PROFILERS 0</h1>

<h1>endif</h1>

<p>/<em>* Enable Lua engine debug log </em>/</p>

<h1>ifndef CC_LUA_ENGINE_DEBUG</h1>

<h1>define CC_LUA_ENGINE_DEBUG 0</h1>

<h1>endif</h1>

<p>```</p>

<p>``` cpp mac/CCPlatformDefine.h</p>

<h1>include &lt;assert.h> //引入assert</h1>

<h1>define CC_DLL //CC_DLL只在win32平台下有效</h1>

<h1>if CC_DISABLE_ASSERT > 0</h1>

<h1>define CC_ASSERT(cond) //禁用了assert</h1>

<h1>else</h1>

<h1>define CC_ASSERT(cond) assert(cond) //启用了assert</h1>

<h1>endif</h1>

<h1>define CC_UNUSED_PARAM(unusedparam) (void)unusedparam</h1>

<p>//定义空指针</p>

<h1>ifndef NULL</h1>

<h1>ifdef __cplusplus</h1>

<h1>define NULL    0</h1>

<h1>else</h1>

<h1>define NULL    ((void *)0)</h1>

<h1>endif</h1>

<h1>endif</h1>

<p><code>
我们可以看到win32中不同的部分比如`CC_DLL`
</code> cpp win32/CCPlatformDefine.h</p>

<h1>if defined(_USRDLL)</h1>

<pre><code>#define CC_DLL     __declspec(dllexport)
</code></pre>

<h1>else         /<em> use a DLL library </em>/</h1>

<pre><code>#define CC_DLL     __declspec(dllimport)
</code></pre>

<h1>endif</h1>

<p>```</p>

<p>Linux部分也是<code>CC_DLL</code>不同
``` cpp linux/CCPlatformDefine.h</p>

<h1>if defined(_USRDLL)</h1>

<h1>define CC_DLL <strong>attribute</strong> ((visibility ("default")))</h1>

<h1>else         /<em> use a DLL library </em>/</h1>

<h1>define CC_DLL <strong>attribute</strong> ((visibility ("default")))</h1>

<h1>endif</h1>

<p>```</p>

<p>Android中比较不同的部分是<code>CC_ASSERT</code>
``` cpp android/CCPlatformDefine.h</p>

<h1>define CC_ASSERT(cond) \</h1>

<p>if (! (cond)) \
{ \</p>

<pre><code>char content[256]; \
sprintf(content, "%s function:%s line:%d", __FILE__, __FUNCTION__, __LINE__);  \
CCMessageBox(content, "Assert error"); \
</code></pre>

<p>}
```</p>

<p>我们最后再来看下<code>CCPlatformMacros.h</code>
``` cpp CCPlatformMacros.h</p>

<h1>include "ccConfig.h"</h1>

<h1>include "CCPlatformConfig.h"</h1>

<h1>include "CCPlatformDefine.h"</h1>

<p>//CREATE_FUNC是2d-x的一个核心功能,一般采用例如<code>MySpriter *my = MySpriter::create()</code>的形式调用.
//这里的create()成员函数即是由CREATE_FUNC创建, 来达到让2d-x来管理内存分配的功能</p>

<h1>define CREATE_FUNC(<strong>TYPE</strong>) \</h1>

<p>static <strong>TYPE</strong>* create() \
{ \</p>

<pre><code>__TYPE__ *pRet = new __TYPE__(); \
if (pRet &amp;&amp; pRet-&gt;init()) \
{ \
    pRet-&gt;autorelease(); \
    return pRet; \
} \
else \
{ \
    delete pRet; \
    pRet = NULL; \
    return NULL; \
} \
</code></pre>

<p>}
//早期版本还有一个NODE_FUNC完成和CREATE_FUNC一样的功能,已经废弃,不再讨论</p>

<p>//CC_ENABLE_CACHE_TEXTURE_DATA 只在Android上启用, 会缓存纹理</p>

<h1>if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)</h1>

<pre><code>#define CC_ENABLE_CACHE_TEXTURE_DATA       1
</code></pre>

<h1>else</h1>

<pre><code>#define CC_ENABLE_CACHE_TEXTURE_DATA       0
</code></pre>

<h1>endif</h1>

<h1>if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID) || (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)</h1>

<p>//重新绑定indices, 避免在android和win32下glDrawElements函数crash的bug</p>

<pre><code>#define CC_REBIND_INDICES_BUFFER  1
</code></pre>

<h1>else</h1>

<pre><code>#define CC_REBIND_INDICES_BUFFER  0
</code></pre>

<h1>endif</h1>

<p>//常用宏定义</p>

<h1>ifdef __cplusplus //namespace只在C++中起作用</h1>

<pre><code>#define NS_CC_BEGIN                     namespace cocos2d {
#define NS_CC_END                       }
#define USING_NS_CC                     using namespace cocos2d  //应该尽量使用USING_NS_CC, 兼容性更好
</code></pre>

<h1>else</h1>

<pre><code>#define NS_CC_BEGIN 
#define NS_CC_END 
#define USING_NS_CC 
</code></pre>

<h1>endif</h1>

<p>//成员函数快捷声明/定义宏
//多使用这些宏, 可以方便地定义出合乎面向对象原则的成员变量.
//需要注意的是这些调用了这些宏之后, 应该养成重新写public, private等标号的习惯. 因为之后的都会变成public
//定义的成员变量都是protected的
//只读的成员变量</p>

<h1>define CC_PROPERTY_READONLY(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual varType get##funName(void);</p>

<p>//getter是为引用</p>

<h1>define CC_PROPERTY_READONLY_PASS_BY_REF(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual const varType&amp; get##funName(void);</p>

<p>//可读可写成员变量</p>

<h1>define CC_PROPERTY(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual varType get##funName(void);\
public: virtual void set##funName(varType var);</p>

<h1>define CC_PROPERTY_PASS_BY_REF(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual varType get##funName(void);\
public: virtual void set##funName(const varType&amp; var);</p>

<p>//以上的getter,setter只有声明, 下面的这些带有定义</p>

<h1>define CC_SYNTHESIZE_READONLY(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual varType get##funName(void) const { return varName; }</p>

<h1>define CC_SYNTHESIZE_READONLY_PASS_BY_REF(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual const varType&amp; get##funName(void) const { return varName; }</p>

<h1>define CC_SYNTHESIZE(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual varType get##funName(void) const { return varName; }\
public: virtual void set##funName(varType var){ varName = var; }</p>

<h1>define CC_SYNTHESIZE_PASS_BY_REF(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual varType get##funName(void) const { return varName; }\
public: virtual void set##funName(const varType&amp; var){ varName = var; }</p>

<p>//setter中会retain一次var, 防止被gc回收.</p>

<h1>define CC_SYNTHESIZE_RETAIN(varType, varName, funName)    \</h1>

<p>private: varType varName; \
public: virtual varType get##funName(void) const { return varName; } \
public: virtual void set##funName(varType var)   \
{ \</p>

<pre><code>if (varName != var) \
{ \
    CC_SAFE_RETAIN(var); \
    CC_SAFE_RELEASE(varName); \
    varName = var; \
} \
</code></pre>

<p>}</p>

<h1>define CC_SAFE_DELETE(p)            do { if(p) { delete (p); (p) = 0; } } while(0)</h1>

<h1>define CC_SAFE_DELETE_ARRAY(p)     do { if(p) { delete[] (p); (p) = 0; } } while(0)</h1>

<h1>define CC_SAFE_FREE(p)                do { if(p) { free(p); (p) = 0; } } while(0)</h1>

<h1>define CC_SAFE_RELEASE(p)            do { if(p) { (p)->release(); } } while(0)</h1>

<h1>define CC_SAFE_RELEASE_NULL(p)        do { if(p) { (p)->release(); (p) = 0; } } while(0)</h1>

<h1>define CC_SAFE_RETAIN(p)            do { if(p) { (p)->retain(); } } while(0)</h1>

<h1>define CC_BREAK_IF(cond)            if(cond) break</h1>

<h1>define __CCLOGWITHFUNCTION(s, ...) \</h1>

<pre><code>CCLog("%s : %s",__FUNCTION__, CCString::createWithFormat(s, ##__VA_ARGS__)-&gt;getCString())
</code></pre>

<p>//这个宏定义要注意大小写, 会很容易和cocos2d::CCLog弄错, 因为代码提示的问题.
// cocos2d debug</p>

<h1>if !defined(COCOS2D_DEBUG) || COCOS2D_DEBUG == 0</h1>

<h1>define CCLOG(...)       do {} while (0)</h1>

<h1>define CCLOGINFO(...)   do {} while (0)</h1>

<h1>define CCLOGERROR(...)  do {} while (0)</h1>

<h1>define CCLOGWARN(...)   do {} while (0)</h1>

<h1>elif COCOS2D_DEBUG == 1</h1>

<h1>define CCLOG(format, ...)      cocos2d::CCLog(format, ##<strong>VA_ARGS</strong>)</h1>

<h1>define CCLOGERROR(format,...)  cocos2d::CCLog(format, ##<strong>VA_ARGS</strong>)</h1>

<h1>define CCLOGINFO(format,...)   do {} while (0)</h1>

<h1>define CCLOGWARN(...) <strong>CCLOGWITHFUNCTION(</strong>VA_ARGS__)</h1>

<h1>elif COCOS2D_DEBUG > 1</h1>

<h1>define CCLOG(format, ...)      cocos2d::CCLog(format, ##<strong>VA_ARGS</strong>)</h1>

<h1>define CCLOGERROR(format,...)  cocos2d::CCLog(format, ##<strong>VA_ARGS</strong>)</h1>

<h1>define CCLOGINFO(format,...)   cocos2d::CCLog(format, ##<strong>VA_ARGS</strong>)</h1>

<h1>define CCLOGWARN(...) <strong>CCLOGWITHFUNCTION(</strong>VA_ARGS__)</h1>

<h1>endif // COCOS2D_DEBUG</h1>

<p>// Lua engine debug</p>

<h1>if !defined(COCOS2D_DEBUG) || COCOS2D_DEBUG == 0 || CC_LUA_ENGINE_DEBUG == 0</h1>

<h1>define LUALOG(...)</h1>

<h1>else</h1>

<h1>define LUALOG(format, ...)     cocos2d::CCLog(format, ##<strong>VA_ARGS</strong>)</h1>

<h1>endif // Lua engine debug</h1>

<p>//定义废弃(deprecated)属性</p>

<h1>if defined(<strong>GNUC</strong>) &amp;&amp; ((<strong>GNUC</strong> >= 4) || ((<strong>GNUC</strong> == 3) &amp;&amp; (<strong>GNUC_MINOR</strong> >= 1)))</h1>

<pre><code>#define CC_DEPRECATED_ATTRIBUTE __attribute__((deprecated))
</code></pre>

<h1>elif _MSC_VER >= 1400 //vs 2005 or higher</h1>

<pre><code>#define CC_DEPRECATED_ATTRIBUTE __declspec(deprecated) 
</code></pre>

<h1>else</h1>

<pre><code>#define CC_DEPRECATED_ATTRIBUTE
</code></pre>

<h1>endif</h1>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2d-x深读1:CCPlatformConfig.h]]></title>
    <link href="http://young40.github.com/blog/2012/12/17/cocos2d-x-source-code-research-1-ccplatformconfig-dot-h/"/>
    <updated>2012-12-17T00:43:00+08:00</updated>
    <id>http://young40.github.com/blog/2012/12/17/cocos2d-x-source-code-research-1-ccplatformconfig-dot-h</id>
    <content type="html"><![CDATA[<p>准备好好学习下Cocos2d-x(以下简称2dx), 我正在很努力地学习C++.</p>

<p>作为新手的我, 只能从最基本的代码读起. 就从<code>CCPlatformConfig.h</code>开始研究起吧, 这个文件没有include其他文件, 是最基本的文件.</p>

<p>研究成果见代码.</p>

<!--more-->


<ul>
<li>版本:<code>cocos2d-2.1beta3-x-2.1.0</code></li>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/platform</code></li>
</ul>


<p>``` cpp CCPlatformConfig.h</p>

<h1>ifndef <strong>CC_PLATFORM_CONFIG_H</strong></h1>

<h1>define <strong>CC_PLATFORM_CONFIG_H</strong></h1>

<p>/<em>*
  Config of cocos2d-x project, per target platform.
  </em>/</p>

<p>//////////////////////////////////////////////////////////////////////////
// pre configure
//////////////////////////////////////////////////////////////////////////</p>

<p>// define supported target platform macro which CC uses.</p>

<h1>define CC_PLATFORM_UNKNOWN            0</h1>

<h1>define CC_PLATFORM_IOS                1</h1>

<h1>define CC_PLATFORM_ANDROID            2</h1>

<h1>define CC_PLATFORM_WIN32              3</h1>

<h1>define CC_PLATFORM_MARMALADE          4</h1>

<h1>define CC_PLATFORM_LINUX              5</h1>

<h1>define CC_PLATFORM_BADA               6</h1>

<h1>define CC_PLATFORM_BLACKBERRY         7</h1>

<h1>define CC_PLATFORM_MAC                8</h1>

<p>//默认是unknown的
// Determine target platform by compile environment macro.</p>

<h1>define CC_TARGET_PLATFORM             CC_PLATFORM_UNKNOWN</h1>

<p>//CC_TARGET_OS_MAC等是从编译器的环境变量传入的. 参加各编译器或者IDE的预定义宏设置</p>

<p>// mac</p>

<h1>if defined(CC_TARGET_OS_MAC)</h1>

<h1>undef  CC_TARGET_PLATFORM //先取消定义</h1>

<h1>define CC_TARGET_PLATFORM         CC_PLATFORM_MAC //定义为MAC平台</h1>

<h1>endif</h1>

<p>// iphone</p>

<h1>if defined(CC_TARGET_OS_IPHONE)</h1>

<pre><code>#undef  CC_TARGET_PLATFORM
#define CC_TARGET_PLATFORM         CC_PLATFORM_IOS
#define CC_SUPPORT_PVRTC //支持prv压缩格式
</code></pre>

<h1>endif</h1>

<p>// android</p>

<h1>if defined(ANDROID)</h1>

<pre><code>#undef  CC_TARGET_PLATFORM
#define CC_TARGET_PLATFORM         CC_PLATFORM_ANDROID
</code></pre>

<h1>endif</h1>

<p>// win32</p>

<h1>if defined(WIN32) &amp;&amp; defined(_WINDOWS)</h1>

<pre><code>#undef  CC_TARGET_PLATFORM
#define CC_TARGET_PLATFORM         CC_PLATFORM_WIN32
</code></pre>

<h1>endif</h1>

<p>// linux</p>

<h1>if defined(LINUX)</h1>

<pre><code>#undef  CC_TARGET_PLATFORM
#define CC_TARGET_PLATFORM         CC_PLATFORM_LINUX
</code></pre>

<h1>endif</h1>

<p>// marmalade</p>

<h1>if defined(MARMALADE)</h1>

<h1>undef  CC_TARGET_PLATFORM</h1>

<h1>define CC_TARGET_PLATFORM         CC_PLATFORM_MARMALADE</h1>

<h1>endif</h1>

<p>// bada</p>

<h1>if defined(SHP)</h1>

<h1>undef  CC_TARGET_PLATFORM</h1>

<h1>define CC_TARGET_PLATFORM         CC_PLATFORM_BADA</h1>

<h1>endif</h1>

<p>// qnx</p>

<h1>if defined(<strong>QNX</strong>)</h1>

<pre><code>#undef  CC_TARGET_PLATFORM
#define CC_TARGET_PLATFORM     CC_PLATFORM_BLACKBERRY
</code></pre>

<h1>endif</h1>

<p>//////////////////////////////////////////////////////////////////////////
// post configure
//////////////////////////////////////////////////////////////////////////</p>

<p>//不支持的平台,如果你在上面平台上遇到这个错误, 就可能是预定义变量, 或者编译器的环境变量设置错误
// check user set platform</p>

<h1>if ! CC_TARGET_PLATFORM</h1>

<pre><code>#error  "Cannot recognize the target platform; are you targeting an unsupported platform?"
</code></pre>

<h1>endif</h1>

<h1>if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)</h1>

<h1>pragma warning (disable:4127) //在win32平台不显示4127的warning, 这个具体用法可以参见</h1>

<p>//http://blog.csdn.net/wowolook/article/details/8060334</p>

<h1>endif  // CC_PLATFORM_WIN32</h1>

<h1>endif  // <strong>CC_PLATFORM_CONFIG_H</strong></h1>

<p>```</p>
]]></content>
  </entry>
  
</feed>
