<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cocos2d-x 源代码研究 | 喜气羊羊]]></title>
  <link href="http://young40.github.com/blog/categories/cocos2d-x-源代码研究/atom.xml" rel="self"/>
  <link href="http://young40.github.com/"/>
  <updated>2012-12-31T02:47:54+08:00</updated>
  <id>http://young40.github.com/</id>
  <author>
    <name><![CDATA[Young40]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[2d-x深读2:CCPlatformMacros.h]]></title>
    <link href="http://young40.github.com/blog/2012/12/17/cocos2d-x-source-code-research-2-ccplatformmacros-dot-h/"/>
    <updated>2012-12-17T01:49:00+08:00</updated>
    <id>http://young40.github.com/blog/2012/12/17/cocos2d-x-source-code-research-2-ccplatformmacros-dot-h</id>
    <content type="html"><![CDATA[<ul>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/include/ccConfig.h</code></li>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/platform/mac/CCPlatformDefine.h</code> //注意我是以mac平台研究的, 其他平台略有不同</li>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/platform/CCPlatformMacros.h</code></li>
</ul>


<!--more-->


<p>``` cpp ccConfig.h</p>

<h1>include "platform/CCPlatformConfig.h"</h1>

<p>//设置为1后会include CCPhysicsScript 和 CCPhysicsDebugNode 添加到物理引擎支持
//需要保证Chipmunk在搜索路径中</p>

<h1>ifndef CC_ENABLE_CHIPMUNK_INTEGRATION</h1>

<h1>define CC_ENABLE_CHIPMUNK_INTEGRATION 0</h1>

<h1>endif</h1>

<p>//设置为1后会include CCPhysicsScript 添加到Box2D的支持
//同样需要保证Box2D会在搜索路径中</p>

<h1>ifndef CC_ENABLE_BOX2D_INTEGRATION</h1>

<h1>define CC_ENABLE_BOX2D_INTEGRATION 0</h1>

<h1>endif</h1>

<p>/**
 设置为1后,2d学会维护一个OpenGL状态缓存来避免不必要的切换
 为了使用这个功能,需要用下列函数来替换GL的对应函数</p>

<pre><code>- ccGLUseProgram() instead of glUseProgram()
- ccGLDeleteProgram() instead of glDeleteProgram()
- ccGLBlendFunc() instead of glBlendFunc()
</code></pre>

<p>如果这个功能被禁止, 那么这些函数会直接调用对应的GL函数, 当然就没有缓存了
打开这个功能能提高速度
如果你的代码是从GL ES 1.1升级过来的, 保持这个功能被禁用. 如果各种功能正常的话, 你可以启用这个功能</p>

<h1>ifndef CC_ENABLE_GL_STATE_CACHE</h1>

<h1>define CC_ENABLE_GL_STATE_CACHE 1</h1>

<h1>endif</h1>

<p>/<em><em>
启用后,纹理的坐标会用这个公式来计算
- texCoord.left = (rect.origin.x</em>2+1) / (texture.wide</em>2);
- texCoord.right = texCoord.left + (rect.size.width<em>2-2)/(texture.wide</em>2);</p>

<p>The same for bottom and top.</p>

<p>This formula prevents artifacts by using 99% of the texture.
The "correct" way to prevent artifacts is by using the spritesheet-artifact-fixer.py or a similar tool.</p>

<p>受影响的类:
- CCSprite / CCSpriteBatchNode and subclasses: CCLabelBMFont, CCTMXTiledMap
- CCLabelAtlas
- CCQuadParticleSystem
- CCTileMap
*/</p>

<h1>ifndef CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL</h1>

<h1>define CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL 0</h1>

<h1>endif</h1>

<p>//默认0.5秒, 更新下FPS的数据. 数字越大FPS数据越可靠.</p>

<h1>ifndef CC_DIRECTOR_STATS_INTERVAL</h1>

<h1>define CC_DIRECTOR_STATS_INTERVAL (0.5f)</h1>

<h1>endif</h1>

<p>//FPS数据显示位置,默认左下</p>

<h1>ifndef CC_DIRECTOR_FPS_POSITION</h1>

<h1>define CC_DIRECTOR_FPS_POSITION ccp(0,0)</h1>

<h1>endif</h1>

<p>/** @def CC_DIRECTOR_DISPATCH_FAST_EVENTS
 If enabled, and only when it is used with CCFastDirector, the main loop will wait 0.04 seconds to
 dispatch all the events, even if there are not events to dispatch.
 If your game uses lot's of events (eg: touches) it might be a good idea to enable this feature.
 Otherwise, it is safe to leave it disabled.</p>

<p> To enable set it to 1. Disabled by default.</p>

<p> @warning This feature is experimental
 */</p>

<h1>ifndef CC_DIRECTOR_DISPATCH_FAST_EVENTS</h1>

<p> #define CC_DIRECTOR_DISPATCH_FAST_EVENTS 0</p>

<h1>endif</h1>

<p>/** @def CC_DIRECTOR_MAC_USE_DISPLAY_LINK_THREAD
If enabled, cocos2d-mac will run on the Display Link thread. If disabled cocos2d-mac will run in its own thread.</p>

<p>If enabled, the images will be drawn at the "correct" time, but the events might not be very responsive.
If disabled, some frames might be skipped, but the events will be dispatched as they arrived.</p>

<p>To enable set it to a 1, to disable it set to 0. Enabled by default.</p>

<p>Only valid for cocos2d-mac. Not supported on cocos2d-ios.</p>

<p>*/</p>

<h1>ifndef CC_DIRECTOR_MAC_USE_DISPLAY_LINK_THREAD</h1>

<h1>define CC_DIRECTOR_MAC_USE_DISPLAY_LINK_THREAD 1</h1>

<h1>endif</h1>

<p>/** @def CC_NODE_RENDER_SUBPIXEL
 If enabled, the CCNode objects (CCSprite, CCLabel,etc) will be able to render in subpixels.
 If disabled, integer pixels will be used.</p>

<p> To enable set it to 1. Enabled by default.
 */</p>

<h1>ifndef CC_NODE_RENDER_SUBPIXEL</h1>

<h1>define CC_NODE_RENDER_SUBPIXEL 1</h1>

<h1>endif</h1>

<p>/** @def CC_SPRITEBATCHNODE_RENDER_SUBPIXEL
 If enabled, the CCSprite objects rendered with CCSpriteBatchNode will be able to render in subpixels.
 If disabled, integer pixels will be used.</p>

<p> To enable set it to 1. Enabled by default.
 */</p>

<h1>ifndef CC_SPRITEBATCHNODE_RENDER_SUBPIXEL</h1>

<h1>define CC_SPRITEBATCHNODE_RENDER_SUBPIXEL    1</h1>

<h1>endif</h1>

<p>/** @def CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP
 Use GL_TRIANGLE_STRIP instead of GL_TRIANGLES when rendering the texture atlas.
 It seems it is the recommend way, but it is much slower, so, enable it at your own risk</p>

<p> To enable set it to a value different than 0. Disabled by default.</p>

<p> */</p>

<h1>ifndef CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP</h1>

<h1>define CC_TEXTURE_ATLAS_USE_TRIANGLE_STRIP 0</h1>

<h1>endif</h1>

<p>//VAO定点数组对象
/** @def CC_TEXTURE_ATLAS_USE_VAO
 By default, CCTextureAtlas (used by many cocos2d classes) will use VAO (Vertex Array Objects).
 Apple recommends its usage but they might consume a lot of memory, specially if you use many of them.
 So for certain cases, where you might need hundreds of VAO objects, it might be a good idea to disable it.</p>

<p> To disable it set it to 0. Enabled by default.</p>

<p> */</p>

<h1>ifndef CC_TEXTURE_ATLAS_USE_VAO</h1>

<pre><code>#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS) || (CC_TARGET_PLATFORM == CC_PLATFORM_MAC)
    #define CC_TEXTURE_ATLAS_USE_VAO 1
#else
    /* Some Windows display adapter driver cannot support VAO. */
    /* Some android devices cannot support VAO very well, so we disable it by default for android platform. */
    /* Blackberry also doesn't support this feature. */
    #define CC_TEXTURE_ATLAS_USE_VAO 0
#endif
</code></pre>

<h1>endif</h1>

<p>/** @def CC_USE_LA88_LABELS
 If enabled, it will use LA88 (Luminance Alpha 16-bit textures) for CCLabelTTF objects.
 If it is disabled, it will use A8 (Alpha 8-bit textures).
 LA88 textures are 6% faster than A8 textures, but they will consume 2x memory.</p>

<p> This feature is enabled by default.</p>

<p> @since v0.99.5
 */</p>

<h1>ifndef CC_USE_LA88_LABELS</h1>

<h1>define CC_USE_LA88_LABELS 1</h1>

<h1>endif</h1>

<p>/<em>*
  启用后,所有CCSprite的子类都会花上一个边框,方便调试
 0 -- disabled
 1 -- draw bounding box
 2 -- draw texture box
</em>/</p>

<h1>ifndef CC_SPRITE_DEBUG_DRAW</h1>

<h1>define CC_SPRITE_DEBUG_DRAW 0</h1>

<h1>endif</h1>

<p>//CCSpriteBatchNode的调试用加边框</p>

<h1>ifndef CC_SPRITEBATCHNODE_DEBUG_DRAW</h1>

<h1>define CC_SPRITEBATCHNODE_DEBUG_DRAW 0</h1>

<h1>endif</h1>

<p>//CCLabelBMFont调试加边框</p>

<h1>ifndef CC_LABELBMFONT_DEBUG_DRAW</h1>

<h1>define CC_LABELBMFONT_DEBUG_DRAW 0</h1>

<h1>endif</h1>

<p>//LabeltAtlas调试加边框</p>

<h1>ifndef CC_LABELATLAS_DEBUG_DRAW</h1>

<h1>define CC_LABELATLAS_DEBUG_DRAW 0</h1>

<h1>endif</h1>

<p>/** @def CC_ENABLE_PROFILERS
 If enabled, will activate various profilers within cocos2d. This statistical data will be output to the console
 once per second showing average time (in milliseconds) required to execute the specific routine(s).
 Useful for debugging purposes only. It is recommended to leave it disabled.</p>

<p> To enable set it to a value different than 0. Disabled by default.
 */</p>

<h1>ifndef CC_ENABLE_PROFILERS</h1>

<h1>define CC_ENABLE_PROFILERS 0</h1>

<h1>endif</h1>

<p>/<em>* Enable Lua engine debug log </em>/</p>

<h1>ifndef CC_LUA_ENGINE_DEBUG</h1>

<h1>define CC_LUA_ENGINE_DEBUG 0</h1>

<h1>endif</h1>

<p>```</p>

<p>``` cpp mac/CCPlatformDefine.h</p>

<h1>include &lt;assert.h> //引入assert</h1>

<h1>define CC_DLL //CC_DLL只在win32平台下有效</h1>

<h1>if CC_DISABLE_ASSERT > 0</h1>

<h1>define CC_ASSERT(cond) //禁用了assert</h1>

<h1>else</h1>

<h1>define CC_ASSERT(cond) assert(cond) //启用了assert</h1>

<h1>endif</h1>

<h1>define CC_UNUSED_PARAM(unusedparam) (void)unusedparam</h1>

<p>//定义空指针</p>

<h1>ifndef NULL</h1>

<h1>ifdef __cplusplus</h1>

<h1>define NULL    0</h1>

<h1>else</h1>

<h1>define NULL    ((void *)0)</h1>

<h1>endif</h1>

<h1>endif</h1>

<p><code>
我们可以看到win32中不同的部分比如`CC_DLL`
</code> cpp win32/CCPlatformDefine.h</p>

<h1>if defined(_USRDLL)</h1>

<pre><code>#define CC_DLL     __declspec(dllexport)
</code></pre>

<h1>else         /<em> use a DLL library </em>/</h1>

<pre><code>#define CC_DLL     __declspec(dllimport)
</code></pre>

<h1>endif</h1>

<p>```</p>

<p>Linux部分也是<code>CC_DLL</code>不同
``` cpp linux/CCPlatformDefine.h</p>

<h1>if defined(_USRDLL)</h1>

<h1>define CC_DLL <strong>attribute</strong> ((visibility ("default")))</h1>

<h1>else         /<em> use a DLL library </em>/</h1>

<h1>define CC_DLL <strong>attribute</strong> ((visibility ("default")))</h1>

<h1>endif</h1>

<p>```</p>

<p>Android中比较不同的部分是<code>CC_ASSERT</code>
``` cpp android/CCPlatformDefine.h</p>

<h1>define CC_ASSERT(cond) \</h1>

<p>if (! (cond)) \
{ \</p>

<pre><code>char content[256]; \
sprintf(content, "%s function:%s line:%d", __FILE__, __FUNCTION__, __LINE__);  \
CCMessageBox(content, "Assert error"); \
</code></pre>

<p>}
```</p>

<p>我们最后再来看下<code>CCPlatformMacros.h</code>
``` cpp CCPlatformMacros.h</p>

<h1>include "ccConfig.h"</h1>

<h1>include "CCPlatformConfig.h"</h1>

<h1>include "CCPlatformDefine.h"</h1>

<p>//CREATE_FUNC是2d-x的一个核心功能,一般采用例如<code>MySpriter *my = MySpriter::create()</code>的形式调用.
//这里的create()成员函数即是由CREATE_FUNC创建, 来达到让2d-x来管理内存分配的功能</p>

<h1>define CREATE_FUNC(<strong>TYPE</strong>) \</h1>

<p>static <strong>TYPE</strong>* create() \
{ \</p>

<pre><code>__TYPE__ *pRet = new __TYPE__(); \
if (pRet &amp;&amp; pRet-&gt;init()) \
{ \
    pRet-&gt;autorelease(); \
    return pRet; \
} \
else \
{ \
    delete pRet; \
    pRet = NULL; \
    return NULL; \
} \
</code></pre>

<p>}
//早期版本还有一个NODE_FUNC完成和CREATE_FUNC一样的功能,已经废弃,不再讨论</p>

<p>//CC_ENABLE_CACHE_TEXTURE_DATA 只在Android上启用, 会缓存纹理</p>

<h1>if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)</h1>

<pre><code>#define CC_ENABLE_CACHE_TEXTURE_DATA       1
</code></pre>

<h1>else</h1>

<pre><code>#define CC_ENABLE_CACHE_TEXTURE_DATA       0
</code></pre>

<h1>endif</h1>

<h1>if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID) || (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)</h1>

<p>//重新绑定indices, 避免在android和win32下glDrawElements函数crash的bug</p>

<pre><code>#define CC_REBIND_INDICES_BUFFER  1
</code></pre>

<h1>else</h1>

<pre><code>#define CC_REBIND_INDICES_BUFFER  0
</code></pre>

<h1>endif</h1>

<p>//常用宏定义</p>

<h1>ifdef __cplusplus //namespace只在C++中起作用</h1>

<pre><code>#define NS_CC_BEGIN                     namespace cocos2d {
#define NS_CC_END                       }
#define USING_NS_CC                     using namespace cocos2d  //应该尽量使用USING_NS_CC, 兼容性更好
</code></pre>

<h1>else</h1>

<pre><code>#define NS_CC_BEGIN 
#define NS_CC_END 
#define USING_NS_CC 
</code></pre>

<h1>endif</h1>

<p>//成员函数快捷声明/定义宏
//多使用这些宏, 可以方便地定义出合乎面向对象原则的成员变量.
//需要注意的是这些调用了这些宏之后, 应该养成重新写public, private等标号的习惯. 因为之后的都会变成public
//定义的成员变量都是protected的
//只读的成员变量</p>

<h1>define CC_PROPERTY_READONLY(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual varType get##funName(void);</p>

<p>//getter是为引用</p>

<h1>define CC_PROPERTY_READONLY_PASS_BY_REF(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual const varType&amp; get##funName(void);</p>

<p>//可读可写成员变量</p>

<h1>define CC_PROPERTY(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual varType get##funName(void);\
public: virtual void set##funName(varType var);</p>

<h1>define CC_PROPERTY_PASS_BY_REF(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual varType get##funName(void);\
public: virtual void set##funName(const varType&amp; var);</p>

<p>//以上的getter,setter只有声明, 下面的这些带有定义</p>

<h1>define CC_SYNTHESIZE_READONLY(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual varType get##funName(void) const { return varName; }</p>

<h1>define CC_SYNTHESIZE_READONLY_PASS_BY_REF(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual const varType&amp; get##funName(void) const { return varName; }</p>

<h1>define CC_SYNTHESIZE(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual varType get##funName(void) const { return varName; }\
public: virtual void set##funName(varType var){ varName = var; }</p>

<h1>define CC_SYNTHESIZE_PASS_BY_REF(varType, varName, funName)\</h1>

<p>protected: varType varName;\
public: virtual varType get##funName(void) const { return varName; }\
public: virtual void set##funName(const varType&amp; var){ varName = var; }</p>

<p>//setter中会retain一次var, 防止被gc回收.</p>

<h1>define CC_SYNTHESIZE_RETAIN(varType, varName, funName)    \</h1>

<p>private: varType varName; \
public: virtual varType get##funName(void) const { return varName; } \
public: virtual void set##funName(varType var)   \
{ \</p>

<pre><code>if (varName != var) \
{ \
    CC_SAFE_RETAIN(var); \
    CC_SAFE_RELEASE(varName); \
    varName = var; \
} \
</code></pre>

<p>}</p>

<h1>define CC_SAFE_DELETE(p)            do { if(p) { delete (p); (p) = 0; } } while(0)</h1>

<h1>define CC_SAFE_DELETE_ARRAY(p)     do { if(p) { delete[] (p); (p) = 0; } } while(0)</h1>

<h1>define CC_SAFE_FREE(p)                do { if(p) { free(p); (p) = 0; } } while(0)</h1>

<h1>define CC_SAFE_RELEASE(p)            do { if(p) { (p)->release(); } } while(0)</h1>

<h1>define CC_SAFE_RELEASE_NULL(p)        do { if(p) { (p)->release(); (p) = 0; } } while(0)</h1>

<h1>define CC_SAFE_RETAIN(p)            do { if(p) { (p)->retain(); } } while(0)</h1>

<h1>define CC_BREAK_IF(cond)            if(cond) break</h1>

<h1>define __CCLOGWITHFUNCTION(s, ...) \</h1>

<pre><code>CCLog("%s : %s",__FUNCTION__, CCString::createWithFormat(s, ##__VA_ARGS__)-&gt;getCString())
</code></pre>

<p>//这个宏定义要注意大小写, 会很容易和cocos2d::CCLog弄错, 因为代码提示的问题.
// cocos2d debug</p>

<h1>if !defined(COCOS2D_DEBUG) || COCOS2D_DEBUG == 0</h1>

<h1>define CCLOG(...)       do {} while (0)</h1>

<h1>define CCLOGINFO(...)   do {} while (0)</h1>

<h1>define CCLOGERROR(...)  do {} while (0)</h1>

<h1>define CCLOGWARN(...)   do {} while (0)</h1>

<h1>elif COCOS2D_DEBUG == 1</h1>

<h1>define CCLOG(format, ...)      cocos2d::CCLog(format, ##<strong>VA_ARGS</strong>)</h1>

<h1>define CCLOGERROR(format,...)  cocos2d::CCLog(format, ##<strong>VA_ARGS</strong>)</h1>

<h1>define CCLOGINFO(format,...)   do {} while (0)</h1>

<h1>define CCLOGWARN(...) <strong>CCLOGWITHFUNCTION(</strong>VA_ARGS__)</h1>

<h1>elif COCOS2D_DEBUG > 1</h1>

<h1>define CCLOG(format, ...)      cocos2d::CCLog(format, ##<strong>VA_ARGS</strong>)</h1>

<h1>define CCLOGERROR(format,...)  cocos2d::CCLog(format, ##<strong>VA_ARGS</strong>)</h1>

<h1>define CCLOGINFO(format,...)   cocos2d::CCLog(format, ##<strong>VA_ARGS</strong>)</h1>

<h1>define CCLOGWARN(...) <strong>CCLOGWITHFUNCTION(</strong>VA_ARGS__)</h1>

<h1>endif // COCOS2D_DEBUG</h1>

<p>// Lua engine debug</p>

<h1>if !defined(COCOS2D_DEBUG) || COCOS2D_DEBUG == 0 || CC_LUA_ENGINE_DEBUG == 0</h1>

<h1>define LUALOG(...)</h1>

<h1>else</h1>

<h1>define LUALOG(format, ...)     cocos2d::CCLog(format, ##<strong>VA_ARGS</strong>)</h1>

<h1>endif // Lua engine debug</h1>

<p>//定义废弃(deprecated)属性</p>

<h1>if defined(<strong>GNUC</strong>) &amp;&amp; ((<strong>GNUC</strong> >= 4) || ((<strong>GNUC</strong> == 3) &amp;&amp; (<strong>GNUC_MINOR</strong> >= 1)))</h1>

<pre><code>#define CC_DEPRECATED_ATTRIBUTE __attribute__((deprecated))
</code></pre>

<h1>elif _MSC_VER >= 1400 //vs 2005 or higher</h1>

<pre><code>#define CC_DEPRECATED_ATTRIBUTE __declspec(deprecated) 
</code></pre>

<h1>else</h1>

<pre><code>#define CC_DEPRECATED_ATTRIBUTE
</code></pre>

<h1>endif</h1>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2d-x深读1:CCPlatformConfig.h]]></title>
    <link href="http://young40.github.com/blog/2012/12/17/cocos2d-x-source-code-research-1-ccplatformconfig-dot-h/"/>
    <updated>2012-12-17T00:43:00+08:00</updated>
    <id>http://young40.github.com/blog/2012/12/17/cocos2d-x-source-code-research-1-ccplatformconfig-dot-h</id>
    <content type="html"><![CDATA[<p>准备好好学习下Cocos2d-x(以下简称2dx), 我正在很努力地学习C++.</p>

<p>作为新手的我, 只能从最基本的代码读起. 就从<code>CCPlatformConfig.h</code>开始研究起吧, 这个文件没有include其他文件, 是最基本的文件.</p>

<p>研究成果见代码.</p>

<!--more-->


<ul>
<li>版本:<code>cocos2d-2.1beta3-x-2.1.0</code></li>
<li>路径:<code>cocos2d-2.1beta3-x-2.1.0/cocos2dx/platform</code></li>
</ul>


<p>``` cpp CCPlatformConfig.h</p>

<h1>ifndef <strong>CC_PLATFORM_CONFIG_H</strong></h1>

<h1>define <strong>CC_PLATFORM_CONFIG_H</strong></h1>

<p>/<em>*
  Config of cocos2d-x project, per target platform.
  </em>/</p>

<p>//////////////////////////////////////////////////////////////////////////
// pre configure
//////////////////////////////////////////////////////////////////////////</p>

<p>// define supported target platform macro which CC uses.</p>

<h1>define CC_PLATFORM_UNKNOWN            0</h1>

<h1>define CC_PLATFORM_IOS                1</h1>

<h1>define CC_PLATFORM_ANDROID            2</h1>

<h1>define CC_PLATFORM_WIN32              3</h1>

<h1>define CC_PLATFORM_MARMALADE          4</h1>

<h1>define CC_PLATFORM_LINUX              5</h1>

<h1>define CC_PLATFORM_BADA               6</h1>

<h1>define CC_PLATFORM_BLACKBERRY         7</h1>

<h1>define CC_PLATFORM_MAC                8</h1>

<p>//默认是unknown的
// Determine target platform by compile environment macro.</p>

<h1>define CC_TARGET_PLATFORM             CC_PLATFORM_UNKNOWN</h1>

<p>//CC_TARGET_OS_MAC等是从编译器的环境变量传入的. 参加各编译器或者IDE的预定义宏设置</p>

<p>// mac</p>

<h1>if defined(CC_TARGET_OS_MAC)</h1>

<h1>undef  CC_TARGET_PLATFORM //先取消定义</h1>

<h1>define CC_TARGET_PLATFORM         CC_PLATFORM_MAC //定义为MAC平台</h1>

<h1>endif</h1>

<p>// iphone</p>

<h1>if defined(CC_TARGET_OS_IPHONE)</h1>

<pre><code>#undef  CC_TARGET_PLATFORM
#define CC_TARGET_PLATFORM         CC_PLATFORM_IOS
#define CC_SUPPORT_PVRTC //支持prv压缩格式
</code></pre>

<h1>endif</h1>

<p>// android</p>

<h1>if defined(ANDROID)</h1>

<pre><code>#undef  CC_TARGET_PLATFORM
#define CC_TARGET_PLATFORM         CC_PLATFORM_ANDROID
</code></pre>

<h1>endif</h1>

<p>// win32</p>

<h1>if defined(WIN32) &amp;&amp; defined(_WINDOWS)</h1>

<pre><code>#undef  CC_TARGET_PLATFORM
#define CC_TARGET_PLATFORM         CC_PLATFORM_WIN32
</code></pre>

<h1>endif</h1>

<p>// linux</p>

<h1>if defined(LINUX)</h1>

<pre><code>#undef  CC_TARGET_PLATFORM
#define CC_TARGET_PLATFORM         CC_PLATFORM_LINUX
</code></pre>

<h1>endif</h1>

<p>// marmalade</p>

<h1>if defined(MARMALADE)</h1>

<h1>undef  CC_TARGET_PLATFORM</h1>

<h1>define CC_TARGET_PLATFORM         CC_PLATFORM_MARMALADE</h1>

<h1>endif</h1>

<p>// bada</p>

<h1>if defined(SHP)</h1>

<h1>undef  CC_TARGET_PLATFORM</h1>

<h1>define CC_TARGET_PLATFORM         CC_PLATFORM_BADA</h1>

<h1>endif</h1>

<p>// qnx</p>

<h1>if defined(<strong>QNX</strong>)</h1>

<pre><code>#undef  CC_TARGET_PLATFORM
#define CC_TARGET_PLATFORM     CC_PLATFORM_BLACKBERRY
</code></pre>

<h1>endif</h1>

<p>//////////////////////////////////////////////////////////////////////////
// post configure
//////////////////////////////////////////////////////////////////////////</p>

<p>//不支持的平台,如果你在上面平台上遇到这个错误, 就可能是预定义变量, 或者编译器的环境变量设置错误
// check user set platform</p>

<h1>if ! CC_TARGET_PLATFORM</h1>

<pre><code>#error  "Cannot recognize the target platform; are you targeting an unsupported platform?"
</code></pre>

<h1>endif</h1>

<h1>if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)</h1>

<h1>pragma warning (disable:4127) //在win32平台不显示4127的warning, 这个具体用法可以参见</h1>

<p>//http://blog.csdn.net/wowolook/article/details/8060334</p>

<h1>endif  // CC_PLATFORM_WIN32</h1>

<h1>endif  // <strong>CC_PLATFORM_CONFIG_H</strong></h1>

<p>```</p>
]]></content>
  </entry>
  
</feed>
