#+TITLE: UniRx源码分析(三) Observable
#+DATE: 2021-06-26T22:08:46+08:00
#+TAGS[]: Unity UniRx
#+CATEGORIES[]: UniRx源码分析
#+LAYOUT: post
#+OPTIONS: toc:nil
#+DRAFT: true

=Observable= 类由多个文件组成, 如下:

# more

|-----------------------------+------------------------------|
| 文件                        | 说明                         |
|-----------------------------+------------------------------|
| Observable.cs               | Select, Where, ToArray等函数 |
| Observable.Aggregate.cs     |                              |
| Observable.Awaiter.cs       |                              |
| Observable.Binding.cs       |                              |
| Observable.Blocking.cs      |                              |
| Observable.Concatenate.cs   |                              |
| Observable.Concurrency.cs   |                              |
| Observable.Conversions.cs   |                              |
| Observable.Creation.cs      |                              |
| Observable.ErrorHandling.cs |                              |
| Observable.Events.cs        |                              |
| Observable.FromAsync.cs     |                              |
| Observable.Joins.cs         |                              |
| Observable.Paging.cs        |                              |
| Observable.Time.cs          |                              |
|-----------------------------+------------------------------|

表格中文件都有提供了类似的功能， 或给 =Observable= 类实现了新的静态成员函数，或给 =IObservable= 对象扩展了新的成员函数。

例如, 在 =Observable.Time.cs= 中:
#+begin_src csharp
  public static partial class Observable
  {
      public static IObservable<long> Interval(TimeSpan period)
      {
          return new TimerObservable(period, period, Scheduler.DefaultSchedulers.TimeBasedOperations);
      }  
      // .....
      public static IObservable<TSource> Delay<TSource>(this IObservable<TSource> source, TimeSpan dueTime, IScheduler scheduler)
      {
          return new DelayObservable<TSource>(source, dueTime, scheduler);
      }
      // .....
  }
#+end_src

注意到函数 =Interval= 返回了 =IObservable= 对象， 而 =Delay= 又对 =IObservable= 进行了扩展。所以，我们就可以使用链式调用的方式连续调用 =Interval= 和 =Delay= 。

例如：
#+begin_src csharp
  Observable.Interval(TimeSpan.FromSeconds(1)) // IObservable<long>
      .Delay(TimeSpan.FromSeconds(3)) // IObservable<long>
      .Subscribe(x => Debug.Log(DateTime.Now));
      // Subscribe 函数我们上次分析 Observer.cs文件时有提及.
#+end_src

翻看个 =Observable.*.cs= 的实现，我们可以看到各函数的实现大体都很短，为桥接性质。例如 =Interval= 和 =Delay= 都是返回了一个新的对象。
后续我们会分析他们的真正实现。
